<?xml version="1.0" encoding="UTF-8"?>
<chapter id="manipulating_temporal_types">
	<title>Manipulación de tipos temporales</title>
	<para>A continuación presentamos las funciones y operadores para tipos temporales. Estas funciones y operadores son polimórficos, es decir, sus argumentos pueden ser de varios tipos y el tipo del resultado puede depender del tipo de los argumentos. Para expresar esto, usamos la siguiente notación:</para>

	<itemizedlist>
		<listitem>
			<para><varname>ttype</varname> representa cualquier tipo temporal,</para>
		</listitem>

		<listitem>
			<para><varname>time</varname> representa cualquier tipo de tiempo, es decir, <varname>timestamptz</varname>, <varname>period</varname>, <varname>timestampset</varname> o <varname>periodset</varname>,</para>
		</listitem>

		<listitem>
			<para><varname>tnumber</varname> representa cualquier tipo de número temporal, es decir, <varname>tint</varname> o <varname>tfloat</varname>,</para>
		</listitem>

		<listitem>
			<para><varname>torder</varname> representa cualquier tipo temporal cuyo tipo de base tiene definido un orden total, es decir, <varname>tint</varname>, <varname>tfloat</varname> o <varname>ttext</varname>,</para>
		</listitem>

		<listitem>
			<para><varname>tpoint</varname> representa un tipo de punto temporal, es decir, <varname>tgeompoint</varname> o <varname>tgeogpoint</varname>,</para>
		</listitem>

		<listitem>
			<para><varname>ttypeinst</varname> representa cualquier tipo temporal con subtipo instante,</para>
		</listitem>

		<listitem>
			<para><varname>ttypei</varname> representa cualquier tipo temporal con subtipo conjunto de instantes,</para>
		</listitem>

		<listitem>
			<para><varname>ttypeseq</varname> representa cualquier tipo temporal con subtipo secuencia,</para>
		</listitem>

		<listitem>
			<para><varname>tdiscseq</varname> representa cualquier tipo temporal con subtipo secuencia y con tipo de base discreto,</para>
		</listitem>

		<listitem>
			<para><varname>tcontseq</varname> representa cualquier tipo temporal con subtipo secuencia y con tipo de base continuo,</para>
		</listitem>

		<listitem>
			<para><varname>ttypes</varname> representa cualquier tipo temporal con subtipo conjunto de secuencias</para>
		</listitem>

		<listitem>
			<para><varname>base</varname> representa cualquier tipo de base de un tipo temporal, es decir, <varname>boolean</varname>, <varname>integer</varname>, <varname>float</varname>, <varname>text</varname>, <varname>geometry</varname> o <varname>geography</varname>,</para>
		</listitem>

		<listitem>
			<para><varname>number</varname> representa cualquier tipo de base numérico, es decir, <varname>integer</varname> o <varname>float</varname>,</para>
		</listitem>

		<listitem>
			<para><varname>numrange</varname> representa cualquier tipo de rango numérico, es decir, <varname>intrange</varname> o <varname>floatrange</varname>,</para>
		</listitem>

		<listitem>
			<para><varname>geo</varname> representa los tipos <varname>geometry</varname> o <varname>geography</varname>,</para>
		</listitem>

		<listitem>
			<para><varname>point</varname> representa los tipos  <varname>geometry</varname> o <varname>geography</varname> restringidos a un punto.</para>
		</listitem>

		<listitem>
			<para><varname>type[]</varname> representa una matriz de <varname>type</varname>.</para>
		</listitem>
	</itemizedlist>

	<para>Una forma común de generalizar las operaciones tradicionales a los tipos temporales es aplicar la operación en <emphasis>cada instante</emphasis>, lo que da un valor temporal como resultado. En ese caso, la operación sólo se define en la intersección de las extensiones temporales de los operandos; si las extensiones temporales son disjuntas, el resultado es nulo. Por ejemplo, los operadores de comparación temporal, como <varname>#&lt;</varname>, determinan si los valores tomados por sus operandos en cada instante satisfacen la condición y devuelven un booleano temporal. A continuación se dan ejemplos de las diversas generalizaciones de los operadores.
		<programlisting>
-- Comparación temporal
SELECT tint '[2@2001-01-01, 2@2001-01-03)' #&lt; tfloat '[1@2001-01-01, 3@2001-01-03)';
-- "{[f@2001-01-01, f@2001-01-02], (t@2001-01-02, t@2001-01-03)}"
SELECT tfloat '[1@2001-01-01, 3@2001-01-03)' #&lt; tfloat '[3@2001-01-03, 1@2001-01-05)';
-- NULL
-- Adición temporal
SELECT tint '[1@2001-01-01, 1@2001-01-03)' + tint '[2@2001-01-02, 2@2001-01-05)';
-- "[3@2001-01-02, 3@2001-01-03)"
-- Intersección temporal
SELECT tintersects(tgeompoint '[Point(0 1)@2001-01-01, Point(3 1)@2001-01-04)',
geometry 'Polygon((1 0,1 2,2 2,2 0,1 0))');
-- "{[f@2001-01-01, t@2001-01-02, t@2001-01-03], (f@2001-01-03, f@2001-01-04]}"
-- Distancia temporal
SELECT tgeompoint '[Point(0 0)@2001-01-01 08:00:00, Point(0 1)@2001-01-03 08:10:00)' &lt;-&gt;
tgeompoint '[Point(0 0)@2001-01-02 08:05:00, Point(1 1)@2001-01-05 08:15:00)';
-- "[0.5@2001-01-02 08:05:00+00, 0.745184033794557@2001-01-03 08:10:00+00)"
		</programlisting>
	</para>

	<para>Otro requisito común es determinar si los operandos satisfacen <emphasis>alguna vez</emphasis> o <emphasis>siempre</emphasis> una condición con respecto a una operación. Estos se pueden obtener aplicando los operadores de comparación alguna vez/siempre. Estos operadores se indican anteponiendo los operadores de comparación tradicionales con, respectivamente, <varname>?</varname> (alguna vez) y <varname>%</varname> (siempre). A continuación se dan ejemplos de operadores de comparación alguna vez y siempre.
		<programlisting>
-- ¿Se cruzan los operandos alguna vez?
SELECT tintersects(tgeompoint '[Point(0 1)@2001-01-01, Point(3 1)@2001-01-04)',
geometry 'Polygon((1 0,1 2,2 2,2 0,1 0))') ?= true;
-- true
-- ¿Se cruzan los operandos siempre?
SELECT tintersects(tgeompoint '[Point(0 1)@2001-01-01, Point(3 1)@2001-01-04)',
geometry 'Polygon((0 0,0 2,4 2,4 0,0 0))') %= true;
-- true
-- ¿Es el operando izquierdo alguna vez menor que el derecho?
SELECT (tfloat '[1@2001-01-01, 3@2001-01-03)' #&lt;
tfloat '[3@2001-01-01, 1@2001-01-03)') ?= true;
-- true
-- ¿Es el operando izquierdo siempre menor que el derecho?
SELECT (tfloat '[1@2001-01-01, 3@2001-01-03)' #&lt;
tfloat '[2@2001-01-01, 4@2001-01-03)') %= true;
-- true
		</programlisting>
		Por razones de eficiencia, algunas operaciones comunes con la semántica alguna vez o siempre se proporcionan de forma nativa. Por ejemplo, la función <varname>intersects</varname> determina si hay un instante en el que los dos argumentos se cruzan espacialmente.</para>

	<para>A continuación describimos las funciones y operadores para tipos temporales. Para mayor concisión, en los ejemplos usamos principalmente secuencias compuestas por dos instantes.</para>

	<sect1 id="input_output_temporal_types">
		<title>Entrada/salida de tipos temporales</title>
		<para>Un valor de instante es un par de la forma <varname>v@t</varname>, donde <varname>v</varname> es un valor del tipo de base y <varname>t</varname> es un valor de <varname>timestamptz</varname>. Un valor de secuencia es un conjunto de valores <varname>v1@t1,...,vn@tn</varname> delimitado por límites superior e inferior, que pueden ser inclusivo (representados por &lsquo;<varname>[</varname>&rsquo; y &lsquo;<varname>]</varname>&rsquo;) o exclusivos (representados por &lsquo;<varname>(</varname>&rsquo; y &lsquo;<varname>)</varname>&rsquo;). Ejemplos de entrada de valores temporales unitarios son los siguientes:
			<programlisting>
SELECT tbool 'true@2001-01-01 08:00:00';
SELECT tint '1@2001-01-01 08:00:00';
SELECT tfloat '1.5@2001-01-01 08:00:00';
SELECT ttext 'AAA@2001-01-01 08:00:00';
SELECT tgeompoint 'Point(0 0)@2017-01-01 08:00:05';
SELECT tgeogpoint 'Point(0 0)@2017-01-01 08:00:05';
SELECT tbool '[true@2001-01-01 08:00:00, true@2001-01-03 08:00:00]';
SELECT tint '[1@2001-01-01 08:00:00, 1@2001-01-03 08:00:00]';
SELECT tfloat '[2.5@2001-01-01 08:00:00, 3@2001-01-03 08:00:00, 1@2001-01-04 08:00:00]';
SELECT tfloat '[1.5@2001-01-01 08:00:00]';  -- Instant sequence
SELECT ttext '[BBB@2001-01-01 08:00:00, BBB@2001-01-03 08:00:00]';
SELECT tgeompoint '[Point(0 0)@2017-01-01 08:00:00, Point(0 0)@2017-01-01 08:05:00)';
SELECT tgeogpoint '[Point(0 0)@2017-01-01 08:00:00, Point(0 1)@2017-01-01 08:05:00,
Point(0 0)@2017-01-01 08:10:00)';
			</programlisting>
		</para>

		<para>La extensión temporal de un valor de instante es un sólo instante, mientras que la extensión temporal de un valor de secuencia es un período definido por el primer y último instantes, así como por los límites superior e inferior.</para>

		<para>Un valor temporal de conjunto es un conjunto <varname>{v1,...,vn}</varname> donce cada <varname>vi</varname> es un valor unitario del tipo correspondiente. Ejemplos de entrada de valores temporales de conjunto son los siguientes:
			<programlisting>
SELECT tbool '{true@2001-01-01 08:00:00, false@2001-01-03 08:00:00}';
SELECT tint '{1@2001-01-01 08:00:00, 2@2001-01-03 08:00:00}';
SELECT tfloat '{1.0@2001-01-01 08:00:00, 2.0@2001-01-03 08:00:00}';
SELECT ttext '{AAA@2001-01-01 08:00:00, BBB@2001-01-03 08:00:00}';
SELECT tgeompoint '{Point(0 0)@2017-01-01 08:00:00, Point(0 1)@2017-01-02 08:05:00}';
SELECT tgeogpoint '{Point(0 0)@2017-01-01 08:00:00, Point(0 1)@2017-01-02 08:05:00}';
SELECT tbool '{[false@2001-01-01 08:00:00, false@2001-01-03 08:00:00),
[true@2001-01-03 08:00:00], (false@2001-01-04 08:00:00, false@2001-01-06 08:00:00]}';
SELECT tint '{[1@2001-01-01 08:00:00, 1@2001-01-03 08:00:00),
[2@2001-01-04 08:00:00, 3@2001-01-05 08:00:00, 3@2001-01-06 08:00:00]}';
SELECT tfloat '{[1@2001-01-01 08:00:00, 2@2001-01-03 08:00:00, 2@2001-01-04 08:00:00,
3@2001-01-06 08:00:00]}';
SELECT ttext '{[AAA@2001-01-01 08:00:00, BBB@2001-01-03 08:00:00, BBB@2001-01-04 08:00:00),
[CCC@2001-01-05 08:00:00, CCC@2001-01-06 08:00:00]}';
SELECT tgeompoint '{[Point(0 0)@2017-01-01 08:00:00, Point(0 1)@2017-01-01 08:05:00),
[Point(0 1)@2017-01-01 08:10:00, Point(1 1)@2017-01-01 08:15:00)}';
SELECT tgeogpoint '{[Point(0 0)@2017-01-01 08:00:00, Point(0 1)@2017-01-01 08:05:00),
[Point(0 1)@2017-01-01 08:10:00, Point(1 1)@2017-01-01 08:15:00)}';
			</programlisting>
			La extensión temporal de un valor de conjunto de instantes es un conjunto de marcas de tiempo, mientras que la extensión temporal de un valor de conjunto de secuencias es un conjunto de períodos.</para>

		<para>Los valores de secuencia o conjunto de secuencias cuyo tipo de base es continuo pueden especificar que la interpolación es escalonada. Si no se especifica, se supone que la interpolación es lineal por defecto.
			<programlisting>
-- Interpolación lineal por defecto
SELECT tfloat '[2.5@2001-01-01, 3@2001-01-03, 1@2001-01-04]';
SELECT tgeompoint '{[Point(2.5 2.5)@2001-01-01, Point(3 3)@2001-01-03],
[Point(1 1)@2001-01-04, Point(1 1)@2001-01-04]}';
-- Interpolación escalonada
SELECT tfloat 'Interp=Stepwise;[2.5@2001-01-01, 3@2001-01-03, 1@2001-01-04]';
SELECT tgeompoint 'Interp=Stepwise;{[Point(2.5 2.5)@2001-01-01, Point(3 3)@2001-01-03],
[Point(1 1)@2001-01-04, Point(1 1)@2001-01-04]}';
			</programlisting>
			Para los valores de subtipo conjunto de secuencias se supone que todas las secuencias componentes tienen la misma interpolación, ya sea por escalonada o lineal, como en los ejemplos anteriores.</para>

		<para>Para los puntos temporales, es posible especificar el identificador de referencia espacial (SRID) utilizando la representación extendida de texto conocido (EWKT) de la siguiente manera:
			<programlisting>
SELECT tgeompoint 'SRID=5435;[Point(0 0)@2000-01-01,Point(0 1)@2000-01-02]'
			</programlisting>
			Todas las geometrías componentes serán entonces del SRID dado. Además, cada geometría componente puede especificar su SRID con el formato EWKT como en el siguiente ejemplo
			<programlisting>
SELECT tgeompoint '[SRID=5435;Point(0 0)@2000-01-01,SRID=5435;Point(0 1)@2000-01-02]'
			</programlisting>
			Se genera un error si las geometrías componentes no están todas en el mismo SRID o si el SRID de una geometría componente es diferente al del punto temporal.
			<programlisting>
SELECT tgeompoint '[SRID=5435;Point(0 0)@2000-01-01,SRID=4326;Point(0 1)@2000-01-02]';
ERROR: Geometry SRID (4326) does not match temporal type SRID (5435)
SELECT tgeompoint 'SRID=5435;[SRID=4326;Point(0 0)@2000-01-01,
  SRID=4326;Point(0 1)@2000-01-02]'
ERROR: Geometry SRID (4326) does not match temporal type SRID (5435)
			</programlisting>
		</para>
	</sect1>

	<sect1 id="constructor_temporal_tyes">
		<title>Funciones de constructor</title>

		<para>Cada tipo temporal tiene funciones de constructor con el mismo nombre que el tipo y con un sufijo para el subtipo, donde el sufijo &lsquo;<varname>inst</varname>&rsquo;, &lsquo;<varname>i</varname>&rsquo;, &lsquo;<varname>seq</varname>&rsquo; y &lsquo;<varname>s</varname>&rsquo; corresponden, respectivamente, a los subtipos instante, conjunto de instantes, secuencia y conjunto de secuencias. Ejemplos son <varname>tintseq</varname> o <varname>tgeompoints</varname>. El uso de la función constructora suele ser más conveniente que escribir una constante literal.</para>

		<itemizedlist>
			<listitem>
				<para>Un primer conjunto de funciones tiene dos argumentos, un tipo base y un tipo de tiempo, donde el último es un valor de <varname>timestamptz</varname>, <varname>timestampset</varname>, <varname>period</varname> o <varname>periodset</varname> para construir, respectivamente, un valor de subtipo instante, conjunto de instantes, secuencia o conjunto de secuencias. Las funciones para valores de secuencia o de conjunto de secuencias con tipo base continuo tienen además un tercer argumento opcional que es un booleano para indicar si el valor temporal resultante tiene interpolación lineal o no. Por defecto, este argumento es verdadero si no se especifica.</para>
			</listitem>

			<listitem>
				<para>Otro conjunto de funciones para valores de conjunto de instantes tiene un solo argumento, que es una matriz de valores de instante correspondientes.</para>
			</listitem>

			<listitem>
				<para>Otro conjunto de funciones para valores de secuencia tiene un argumento para la matriz de valores de instante correspondiente y dos argumentos booleanos opcionales que indican, respectivamente, si los límites izquierdo y derecho son inclusivos o exclusivos. Si estos argumentos no se especifican, se supone que son verdaderos por defecto. Además, las funciones para valores de secuencia con tipo base continuo tienen un argumento booleano adicional que indica si la interpolación es lineal o no. Si este argumento no se especifica, se asume que es verdadero por defecto.</para>
			</listitem>

			<listitem>
				<para>Otro conjunto de funciones para valores de conjuntos de secuencias tiene un único argumento, que es una matriz de valores de secuencia correspondientes. Para valores de secuencia con tipo de base continuo, la interpolación del valor temporal resultante depende de la interpolación de las secuencias que la componen. Se genera un error si las secuencias que componen la matriz tienen interpolación diferentes.</para>
			</listitem>
		</itemizedlist>

		<para>A continuación, damos las funciones de constructor para los distintos subtipos.</para>

		<itemizedlist>
			<listitem id="ttypeinst">
				<indexterm><primary><varname>ttypeinst</varname></primary></indexterm>
				<para>Constructor para tipos temporales de subtipo instante</para>
				<para><varname>ttypeinst(base,timestamptz):ttypeinst</varname></para>
				<programlisting>
SELECT tboolinst(true, '2001-01-01');
SELECT tfloatinst(1.5, '2001-01-01');
SELECT tgeompointinst('Point(0 0)', '2001-01-01');
				</programlisting>
			</listitem>

			<listitem id="ttypei">
				<indexterm><primary><varname>ttypei</varname></primary></indexterm>
				<para>Constructor para tipos temporales de subtipo conjunto de instantes</para>
				<para><varname>ttypei(base,timestampset):ttypei</varname></para>
				<para><varname>ttypei(ttypeinst[]):ttypei</varname></para>
				<programlisting>
SELECT tinti(2, '{2001-01-01, 2001-01-02, 2001-01-03}');
SELECT tgeompointi('Point(0 0)', '{2001-01-01, 2001-01-02}');
SELECT tbooli(ARRAY[tbool 'true@2001-01-01 08:00:00', 'false@2001-01-01 08:05:00']);
SELECT tinti(ARRAY[tint '1@2001-01-01 08:00:00', '2@2001-01-01 08:05:00']);
SELECT tfloati(ARRAY[tfloat '1.0@2001-01-01 08:00:00', '2.0@2001-01-01 08:05:00']);
SELECT ttexti(ARRAY[ttext 'AAA@2001-01-01 08:00:00', 'BBB@2001-01-01 08:05:00']);
SELECT tgeompointi(ARRAY[tgeompoint 'Point(0 0)@2001-01-01 08:00:00',
'Point(0 1)@2001-01-01 08:05:00', 'Point(1 1)@2001-01-01 08:10:00']);
SELECT tgeogpointi(ARRAY[tgeogpoint 'Point(1 1)@2001-01-01 08:00:00',
'Point(2 2)@2001-01-01 08:05:00']);
				</programlisting>
			</listitem>

			<listitem id="ttypeseq">
				<indexterm><primary><varname>ttypeseq</varname></primary></indexterm>
				<para>Constructor para tipos temporales de subtipo secuencia</para>
				<para><varname>tdiscseq(base,period):tdiscseq</varname></para>
				<para><varname>tdiscseq(ttypeinst[],left_inc=true,right_inc=true}):tdiscseq</varname></para>
				<para><varname>tcontseq(base,period,linear=true):tcontseq</varname></para>
				<para><varname>tcontseq(ttypeinst[],left_inc=true,right_inc=true,linear=true}):tcontseq</varname></para>
				<programlisting>
SELECT tfloatseq(1.5, '[2001-01-01, 2001-01-02]');
SELECT tfloatseq(2.0, '[2001-01-01, 2001-01-02]', false);
SELECT tboolseq(ARRAY[tbool 'true@2001-01-01 08:00:00', 'true@2001-01-03 08:05:00'],
true, true);
SELECT tintseq(ARRAY[tintinst(2,'2001-01-01 08:00:00'),
tintinst(2,'2001-01-01 08:10:00')], true, false);
SELECT tfloatseq(ARRAY[tfloat '2.0@2001-01-01 08:00:00', '3@2001-01-03 08:05:00',
'1@2001-01-03 08:10:00'], true, false);
SELECT tfloatseq(ARRAY[tfloat '2.0@2001-01-01 08:00:00', '3@2001-01-03 08:05:00',
'1@2001-01-03 08:10:00'], true, true, false);
SELECT ttextseq(ARRAY[ttextinst('AAA', '2001-01-01 08:00:00'),
ttextinst('BBB', '2001-01-03 08:05:00'), ttextinst('BBB', '2001-01-03 08:10:00')]);
SELECT tgeompointseq(ARRAY[tgeompoint 'Point(0 0)@2001-01-01 08:00:00',
'Point(0 1)@2001-01-03 08:05:00', 'Point(1 1)@2001-01-03 08:10:00']);
SELECT tgeogpointseq(ARRAY[tgeogpoint 'Point(0 0)@2001-01-01 08:00:00',
'Point(0 0)@2001-01-03 08:05:00'], true, true, false);
				</programlisting>
			</listitem>

			<listitem id="ttypes">
				<indexterm><primary><varname>ttypes</varname></primary></indexterm>
				<para>Constructor para tipos temporales de subtipo conjunto de secuencias</para>
				<para><varname>tdiscs(base,periodset):tdiscs</varname></para>
				<para><varname>tconts(base,periodset,linear=true):tconts</varname></para>
				<para><varname>ttypes(ttypeseq[]):ttypes</varname></para>
				<programlisting>
SELECT ttexts('AAA', '{[2001-01-01, 2001-01-02], [2001-01-03, 2001-01-04]}');
SELECT tgeogpointseq('Point(1 1)', '[2001-01-01, 2001-01-02]', false);
SELECT tbools(ARRAY[tbool '[false@2001-01-01 08:00:00, false@2001-01-01 08:05:00)',
'[true@2001-01-01 08:05:00]','(false@2001-01-01 08:05:00, false@2001-01-01 08:10:00)']);
SELECT tints(ARRAY[tint '[1@2001-01-01 08:00:00, 2@2001-01-01 08:05:00,
2@2001-01-01 08:10:00, 2@2001-01-01 08:15:00)']);
SELECT tfloats(ARRAY[tfloat '[1.0@2001-01-01 08:00:00, 2.0@2001-01-01 08:05:00,
2.0@2001-01-01 08:10:00]', '[2.0@2001-01-01 08:15:00, 3.0@2001-01-01 08:20:00)']);
SELECT tfloats(ARRAY[tfloat 'Interp=Stepwise;[1.0@2001-01-01 08:00:00,
2.0@2001-01-01 08:05:00, 2.0@2001-01-01 08:10:00]',
'Interp=Stepwise;[3.0@2001-01-01 08:15:00, 3.0@2001-01-01 08:20:00)']);
SELECT ttexts(ARRAY[ttext '[AAA@2001-01-01 08:00:00, AAA@2001-01-01 08:05:00)',
'[BBB@2001-01-01 08:10:00, BBB@2001-01-01 08:15:00)']);
SELECT tgeompoints(ARRAY[tgeompoint '[Point(0 0)@2001-01-01 08:00:00,
Point(0 1)@2001-01-01 08:05:00, Point(0 1)@2001-01-01 08:10:00)',
'[Point(0 1)@2001-01-01 08:15:00, Point(0 0)@2001-01-01 08:20:00)']);
SELECT tgeogpoints(ARRAY[tgeogpoint
'Interp=Stepwise;[Point(0 0)@2001-01-01 08:00:00, Point(0 0)@2001-01-01 08:05:00)',
'Interp=Stepwise;[Point(1 1)@2001-01-01 08:10:00, Point(1 1)@2001-01-01 08:15:00)']);
SELECT tfloats(ARRAY[tfloat 'Interp=Stepwise;[1.0@2001-01-01 08:00:00,
2.0@2001-01-01 08:05:00, 2.0@2001-01-01 08:10:00]',
'[3.0@2001-01-01 08:15:00, 3.0@2001-01-01 08:20:00)']);
-- ERROR:  Input sequences must have the same interpolation
				</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 id="casting_temporal_types">
		<title>Conversión de tipos</title>

		<para>Un valor temporal se puede convertir en un valor temporal de un tipo compatible. Esto se puede hacer usando la notación <varname>CAST(ttype1 AS ttype2)</varname> o <varname>ttype1::ttype2</varname>.</para>
		<itemizedlist>
			<listitem id="tint_tfloat">
				<indexterm><primary><varname>::</varname></primary></indexterm>
				<para>Convertir un entero temporal en un flotante temporal</para>
				<para><varname>tint::tfloat</varname></para>
				<programlisting>
SELECT tint '[1@2001-01-01, 2@2001-01-03]'::tfloat;
-- "[1@2001-01-01 00:00:00+00, 2@2001-01-03 00:00:00+00]"
SELECT tint '[1@2000-01-01, 2@2000-01-03, 3@2000-01-05]'::tfloat;
-- "Interp=Stepwise;[1@2000-01-01, 2@2000-01-03, 3@2000-01-05]"
				</programlisting>
			</listitem>

			<listitem id="tfloat_tint">
				<indexterm><primary><varname>::</varname></primary></indexterm>
				<para>Convertir un flotante temporal en un entero temporal</para>
				<para><varname>tfloat::tint</varname></para>
				<programlisting>
SELECT tfloat 'Interp=Stepwise;[1.5@2001-01-01, 2.5@2001-01-03]'::tint;
-- "[1@2001-01-01 00:00:00+00, 2@2001-01-03 00:00:00+00]"
SELECT tfloat '[1.5@2001-01-01, 2.5@2001-01-03]'::tint;
-- ERROR:  Cannot cast temporal float with linear interpolation to temporal integer
				</programlisting>
			</listitem>

			<listitem id="tgeompoint_tgeogpoint">
				<indexterm><primary><varname>::</varname></primary></indexterm>
				<para>Convertir un punto geométrico temporal en un punto geográfico temporal</para>
				<para><varname>tgeompoint::tgeogpoint</varname></para>
				<programlisting>
SELECT asText((tgeogpoint 'Point(0 0)@2001-01-01')::tgeompoint);
-- "{POINT(0 0)@2001-01-01}"
				</programlisting>
			</listitem>

			<listitem id="tgeogpoint_tgeompoint">
				<indexterm><primary><varname>::</varname></primary></indexterm>
				<para>Convertir un punto geográfico temporal en un punto geométrico temporal</para>
				<para><varname>tgeogpoint::tgeompoint</varname></para>
				<programlisting>
SELECT asText((tgeompoint '[Point(0 0)@2001-01-01, Point(0 1)@2001-01-02)')::tgeogpoint);
-- "{[POINT(0 0)@2001-01-01, POINT(0 1)@2001-01-02)}"
				</programlisting>
			</listitem>

		</itemizedlist>

		<para>Una forma común de almacenar puntos temporales en PostGIS es representarlos como geometrías de tipo <varname>LINESTRING M</varname> y utilizar la dimensión M para codificar marcas de tiempo como segundos desde 1970-01-01 00:00:00. Estas geometrías aumentadas con tiempo, llamadas <emphasis>trayectorias</emphasis>, se pueden validar con la función <varname>ST_IsValidTrajectory</varname> para verificar quel el valor M está creciendo de cada vértice al siguiente. Las trayectorias se pueden manipular con las funciones <varname>ST_ClosestPointOfApproach</varname>, <varname>ST_DistanceCPA</varname> y <varname>ST_CPAWithin</varname>. Los valores de puntos temporales se pueden convertir a/desde trayectorias de PostGIS.</para>

		<itemizedlist>
			<listitem id="tgeompoint_geometry">
				<indexterm><primary><varname>::</varname></primary></indexterm>
				<para>Convertir un punto temporal en una trayectoria PostGIS</para>
				<para><varname>tgeompoint::geometry</varname></para>
				<para><varname>tgeogpoint::geography</varname></para>
				<programlisting>
SELECT ST_AsText((tgeompoint 'Point(0 0)@2001-01-01')::geometry);
-- "POINT M (0 0 978307200)"
SELECT ST_AsText((tgeompoint '{Point(0 0)@2001-01-01, Point(1 1)@2001-01-02,
Point(1 1)@2001-01-03}')::geometry);
-- "MULTIPOINT M (0 0 978307200,1 1 978393600,1 1 978480000)"
SELECT ST_AsText((tgeompoint '[Point(0 0)@2001-01-01, Point(1 1)@2001-01-02)')::geometry);
-- "LINESTRING M (0 0 978307200,1 1 978393600)"
SELECT ST_AsText((tgeompoint '{[Point(0 0)@2001-01-01, Point(1 1)@2001-01-02),
[Point(1 1)@2001-01-03, Point(1 1)@2001-01-04),
[Point(1 1)@2001-01-05, Point(0 0)@2001-01-06)}')::geometry);
-- "MULTILINESTRING M ((0 0 978307200,1 1 978393600),(1 1 978480000,1 1 978566400),
(1 1 978652800,0 0 978739200))"
SELECT ST_AsText((tgeompoint '{[Point(0 0)@2001-01-01, Point(1 1)@2001-01-02),
[Point(1 1)@2001-01-03],
[Point(1 1)@2001-01-05, Point(0 0)@2001-01-06)}')::geometry);
-- "GEOMETRYCOLLECTION M (LINESTRING M (0 0 978307200,1 1 978393600),
POINT M (1 1 978480000),LINESTRING M (1 1 978652800,0 0 978739200))"
				</programlisting>
			</listitem>

			<listitem id="geometry_tgeompoint">
				<indexterm><primary><varname>::</varname></primary></indexterm>
				<para>Convertir una trayectoria PostGIS a un punto temporal</para>
				<para><varname>geometry::tgeompoint</varname></para>
				<para><varname>geography::tgeogpoint</varname></para>
				<programlisting>
SELECT asText(geometry 'LINESTRING M (0 0 978307200,0 1 978393600,
1 1 978480000)'::tgeompoint);
-- "[POINT(0 0)@2001-01-01, POINT(0 1)@2001-01-02, POINT(1 1)@2001-01-03]";
SELECT asText(geometry 'GEOMETRYCOLLECTION M (LINESTRING M (0 0 978307200,1 1 978393600),
POINT M (1 1 978480000),LINESTRING M (1 1 978652800,0 0 978739200))'::tgeompoint);
-- "{[POINT(0 0)@2001-01-01, POINT(1 1)@2001-01-02], [POINT(1 1)@2001-01-03],
[POINT(1 1)@2001-01-05, POINT(0 0)@2001-01-06]}"
				</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 id="transformation_functions">
		<title>Funciones de transformación</title>
		<para>Un valor temporal se puede transformar en otro subtipo. Se genera un error si los subtipos son incompatibles.</para>
		<itemizedlist>
			<listitem id="ttype_transform">
				<indexterm><primary><varname>ttypeinst</varname></primary></indexterm>
				<indexterm><primary><varname>ttypei</varname></primary></indexterm>
				<indexterm><primary><varname>ttypeseq</varname></primary></indexterm>
				<indexterm><primary><varname>ttypes</varname></primary></indexterm>
				<para>Transformar un tipo temporal a otro subtipo</para>
				<para><varname>ttypeinst(ttype):ttypeinst</varname></para>
				<para><varname>ttypei(ttype):ttypei</varname></para>
				<para><varname>ttypeseq(ttype):ttypeseq</varname></para>
				<para><varname>ttypes(ttype):ttypes</varname></para>
				<programlisting>
SELECT tboolinst(tbool '{[true@2001-01-01]}');
-- "t@2001-01-01 00:00:00+00"
SELECT tboolinst(tbool '{[true@2001-01-01, true@2001-01-02]}');
-- ERROR: Cannot transform input to a temporal instant
SELECT tbooli(tbool 'true@2001-01-01');
-- "{t@2001-01-01}"
SELECT tintseq(tint '1@2001-01-01');
-- "[1@2001-01-01]"
SELECT tfloats(tfloat '2.5@2001-01-01');
-- "{[2.5@2001-01-01]}"
SELECT tfloats(tfloat '{2.5@2001-01-01, 1.5@2001-01-02, 3.5@2001-01-02}');
-- "{[2.5@2001-01-01],[1.5@2001-01-02],[3.5@2001-01-03]}"
				</programlisting>
			</listitem>

			<listitem id="toLinear">
				<indexterm><primary><varname>toLinear</varname></primary></indexterm>
				<para>Transformar un valor temporal con tipo de base continuo de interpolación escalonada a lineal</para>
				<para><varname>toLinear(ttype):ttype</varname></para>
				<programlisting>
SELECT toLinear(tfloat 'Interp=Stepwise;[1@2000-01-01, 2@2000-01-02,
1@2000-01-03, 2@2000-01-04]');
-- "{[1@2000-01-01, 1@2000-01-02), [2@2000-01-02, 2@2000-01-03),
[1@2000-01-03, 1@2000-01-04), [2@2000-01-04]}"
SELECT asText(toLinear(tgeompoint 'Interp=Stepwise;{[Point(1 1)@2000-01-01,
Point(2 2)@2000-01-02], [Point(3 3)@2000-01-05, Point(4 4)@2000-01-06]}'));
-- "{[POINT(1 1)@2000-01-01, POINT(1 1)@2000-01-02), [POINT(2 2)@2000-01-02],
[POINT(3 3)@2000-01-05, POINT(3 3)@2000-01-06), [POINT(4 4)@2000-01-06]}"
				</programlisting>
			</listitem>

			<listitem id="appendInstant">
				<indexterm><primary><varname>appendInstant</varname></primary></indexterm>
				<para>Anexar un instante temporal a un valor temporal</para>
				<para><varname>appendInstant(ttype,ttypeinst):ttype</varname></para>
				<programlisting>
SELECT appendInstant(tint '1@2000-01-01', tint '1@2000-01-02');
-- "{1@2000-01-01, 1@2000-01-02}"
SELECT appendInstant(tintseq(tint '1@2000-01-01'), tint '1@2000-01-02');
-- "[1@2000-01-01, 1@2000-01-02]"
SELECT asText(appendInstant(tgeompoint '{[Point(1 1 1)@2000-01-01,
Point(2 2 2)@2000-01-02], [Point(3 3 3)@2000-01-04, Point(3 3 3)@2000-01-05]}',
tgeompoint 'Point(1 1 1)@2000-01-06'));
-- "{[POINT Z (1 1 1)@2000-01-01, POINT Z (2 2 2)@2000-01-02],
[POINT Z (3 3 3)@2000-01-04, POINT Z (3 3 3)@2000-01-05, POINT Z (1 1 1)@2000-01-06]}"
				</programlisting>
			</listitem>

			<listitem id="merge">
				<indexterm><primary><varname>merge</varname></primary></indexterm>
				<para>Fusionar los valores temporales</para>
				<para><varname>merge(ttype,ttype):ttype</varname></para>
				<para><varname>merge(ttype[]):ttype</varname></para>
				<para>Los valores pueden compartir una sola marca de tiempo, en ese caso, los valores temporales se unen en el resultado si su valor en la marca de tiempo común es el mismo; de lo contrario, se genera un error.</para>
				<programlisting>
SELECT merge(tint '1@2000-01-01', tint '1@2000-01-02');
-- "{1@2000-01-01, 1@2000-01-02}"
SELECT merge(tint '[1@2000-01-01, 2@2000-01-02]', tint '[2@2000-01-02, 1@2000-01-03]');
-- "[1@2000-01-01, 2@2000-01-02, 1@2000-01-03]"
SELECT merge(tint '[1@2000-01-01, 2@2000-01-02]', tint '[3@2000-01-03, 1@2000-01-04]');
-- "{[1@2000-01-01, 2@2000-01-02], [3@2000-01-03, 1@2000-01-04]}"
SELECT merge(tint '[1@2000-01-01, 2@2000-01-02]', tint '[1@2000-01-02, 2@2000-01-03]');
-- ERROR:  Both arguments have different value at their overlapping timestamp
SELECT asText(merge(tgeompoint '{[Point(1 1 1)@2000-01-01,
Point(2 2 2)@2000-01-02], [Point(3 3 3)@2000-01-04, Point(3 3 3)@2000-01-05]}',
tgeompoint '{[Point(3 3 3)@2000-01-05, Point(1 1 1)@2000-01-06]}'));
-- "{[POINT Z (1 1 1)@2000-01-01, POINT Z (2 2 2)@2000-01-02],
[POINT Z (3 3 3)@2000-01-04, POINT Z (3 3 3)@2000-01-05, POINT Z (1 1 1)@2000-01-06]}"

SELECT merge(ARRAY[tint '1@2000-01-01', '1@2000-01-02']);
-- "{1@2000-01-01, 1@2000-01-02}"
SELECT merge(ARRAY[tint '{1@2000-01-01, 2@2000-01-02}', '{2@2000-01-02, 3@2000-01-03}']);
-- "{1@2000-01-01, 2@2000-01-02, 3@2000-01-03}"
SELECT merge(ARRAY[tint '{1@2000-01-01, 2@2000-01-02}', '{3@2000-01-03, 4@2000-01-04}']);
-- "{1@2000-01-01, 2@2000-01-02, 3@2000-01-03, 4@2000-01-04}"
SELECT merge(ARRAY[tint '[1@2000-01-01, 2@2000-01-02]', '[2@2000-01-02, 1@2000-01-03]']);
-- "[1@2000-01-01, 2@2000-01-02, 1@2000-01-03]"
SELECT merge(ARRAY[tint '[1@2000-01-01, 2@2000-01-02]', '[3@2000-01-03, 4@2000-01-04]']);
-- "{[1@2000-01-01, 2@2000-01-02], [3@2000-01-03, 4@2000-01-04]}"
SELECT merge(ARRAY[tgeompoint '{[Point(1 1)@2000-01-01, Point(2 2)@2000-01-02],
[Point(3 3)@2000-01-03, Point(4 4)@2000-01-04]}', '{[Point(4 4)@2000-01-04,
Point(3 3)@2000-01-05], [Point(6 6)@2000-01-06, Point(7 7)@2000-01-07]}']);
-- "{[Point(1 1)@2000-01-01, Point(2 2)@2000-01-02], [Point(3 3)@2000-01-03,
Point(4 4)@2000-01-04, Point(3 3)@2000-01-05],
[Point(6 6)@2000-01-06, Point(7 7)@2000-01-07]}"
SELECT merge(ARRAY[tgeompoint '{[Point(1 1)@2000-01-01, Point(2 2)@2000-01-02]}',
'{[Point(2 2)@2000-01-02, Point(1 1)@2000-01-03]}']);
-- "[Point(1 1)@2000-01-01, Point(2 2)@2000-01-02, Point(1 1)@2000-01-03]"
				</programlisting>
			</listitem>
		</itemizedlist>

	</sect1>

	<sect1>
		<title>Funciones de accesor</title>
		<itemizedlist>

			<listitem id="ttype_memSize">
				<indexterm><primary><varname>memSize</varname></primary></indexterm>
				<para>Obtener el tamaño de la memoria en bytes</para>
				<para><varname>memSize(ttype):integer</varname></para>
				<programlisting>
SELECT memSize(tint '{1@2012-01-01, 2@2012-01-02, 3@2012-01-03}');
-- 280
				</programlisting>
			</listitem>

			<listitem id="tempSubtype">
				<indexterm><primary><varname>tempSubtype</varname></primary></indexterm>
				<para>Obtener el subtipo temporal</para>
				<para><varname>tempSubtype(ttype):{'Instant','InstantSet','Sequence','SequenceSet'}</varname></para>
				<programlisting>
SELECT tempSubtype(tint '[1@2012-01-01, 2@2012-01-02, 3@2012-01-03]');
-- "Sequence"
				</programlisting>
			</listitem>

			<listitem id="interpolation">
				<indexterm><primary><varname>interpolation</varname></primary></indexterm>
				<para>Obtener la interpolación</para>
				<para><varname>interpolation(ttype):{'Discrete','Stepwise','Linear'}</varname></para>
				<programlisting>
SELECT interpolation(tfloat '{1@2012-01-01, 2@2012-01-02, 3@2012-01-03}');
-- "Discrete"
SELECT interpolation(tint '[1@2012-01-01, 2@2012-01-02, 3@2012-01-03]');
-- "Stepwise"
SELECT interpolation(tfloat '[1@2012-01-01, 2@2012-01-02, 3@2012-01-03]');
-- "Linear"
SELECT interpolation(tfloat 'Interp=Stepwise;[1@2012-01-01, 2@2012-01-02, 3@2012-01-03]');
-- "Stepwise"
SELECT interpolation(tgeompoint 'Interp=Stepwise;[Point(1 1)@2012-01-01, Point(2 2)@2012-01-02, Point(3 3)@2012-01-03]');
-- "Stepwise"
				</programlisting>
			</listitem>

			<listitem id="getValue">
				<indexterm><primary><varname>getValue</varname></primary></indexterm>
				<para>Obtener el valor</para>
				<para><varname>getValue(ttypeinst):base</varname></para>
				<programlisting>
SELECT getValue(tint '1@2012-01-01');
-- 1
SELECT ST_AsText(getValue(tgeompoint 'Point(0 0)@2012-01-01'));
-- "POINT(0 0)"
				</programlisting>
			</listitem>

			<listitem id="getValues">
				<indexterm><primary><varname>getValues</varname></primary></indexterm>
				<para>Obtener los valores</para>
				<para><varname>getValues(ttype):{base[],floatrange[],geo}</varname></para>
				<programlisting>
SELECT getValues(tint '[1@2012-01-01, 2@2012-01-03]');
-- "{1,2}"
SELECT getValues(tfloat '[1@2012-01-01, 2@2012-01-03)');
-- "{[1,2)}"
SELECT getValues(tfloat '{[1@2012-01-01, 2@2012-01-03), [3@2012-01-03, 4@2012-01-05)}');
-- "{[1,2),[3,4)}"
SELECT getValues(tfloat 'Interp=Stepwise;{[1@2012-01-01, 2@2012-01-02],
[3@2012-01-03, 4@2012-01-05]}');
-- "{"[1,1]","[2,2]","[3,3]","[4,4]"}"
SELECT ST_AsText(getValues(tgeompoint '{[Point(0 0)@2012-01-01, Point(0 1)@2012-01-02),
[Point(0 1)@2012-01-03, Point(1 1)@2012-01-04)}'));
-- "LINESTRING(0 0,0 1,1 1)"
SELECT ST_AsText(getValues(tgeompoint '{[Point(0 0)@2012-01-01, Point(0 1)@2012-01-02),
[Point(1 1)@2012-01-03, Point(2 2)@2012-01-04)}'));
-- "MULTILINESTRING((0 0,0 1),(1 1,2 2)"
SELECT ST_AsText(getValues(tgeompoint 'Interp=Stepwise;{[Point(0 0)@2012-01-01,
Point(0 1)@2012-01-02], [Point(0 1)@2012-01-03, Point(1 1)@2012-01-04]}'));
-- "GEOMETRYCOLLECTION(MULTIPOINT(0 0,0 1),MULTIPOINT(0 1,1 1))"
SELECT ST_AsText(getValues(tgeompoint '{Point(0 0)@2012-01-01, Point(0 1)@2012-01-02}'));
-- "MULTIPOINT(0 0,0 1)"
SELECT ST_AsText(getValues(tgeompoint '{[Point(0 0)@2012-01-01, Point(0 1)@2012-01-02),
[Point(1 1)@2012-01-03, Point(1 1)@2012-01-04),
[Point(2 1)@2012-01-05, Point(2 2)@2012-01-06)}'));
-- "GEOMETRYCOLLECTION(POINT(1 1),LINESTRING(0 0,0 1),LINESTRING(2 1,2 2))"
				</programlisting>
			</listitem>

			<listitem id="startValue">
				<indexterm><primary><varname>startValue</varname></primary></indexterm>
				<para>Obtener el valor inicial</para>
				<para><varname>startValue(ttype):base</varname></para>
				<para>La función no tiene en cuenta si los límites son inclusivos o no.</para>
				<programlisting>
SELECT startValue(tfloat '(1@2012-01-01, 2@2012-01-03)');
-- 1
				</programlisting>
			</listitem>

			<listitem id="endValue">
				<indexterm><primary><varname>endValue</varname></primary></indexterm>
				<para>Obtener el valor final</para>
				<para><varname>endValue(ttype):base</varname></para>
				<para>La función no tiene en cuenta si los límites son inclusivos o no.</para>
				<programlisting>
SELECT endValue(tfloat '{[1@2012-01-01, 2@2012-01-03), [3@2012-01-03, 5@2012-01-05)}');
-- 5
				</programlisting>
			</listitem>

			<listitem id="minValue">
				<indexterm><primary><varname>minValue</varname></primary></indexterm>
				<para>Obtener el valor mínimo</para>
				<para><varname>minValue(torder):base</varname></para>
				<para>La función no tiene en cuenta si los límites son inclusivos o no.</para>
				<programlisting>
SELECT minValue(tfloat '{1@2012-01-01, 2@2012-01-03, 3@2012-01-05}');
-- 1
				</programlisting>
			</listitem>

			<listitem id="maxValue">
				<indexterm><primary><varname>maxValue</varname></primary></indexterm>
				<para>Obtener el valor máximo</para>
				<para><varname>maxValue(torder):base</varname></para>
				<para>La función no tiene en cuenta si los límites son inclusivos o no.</para>
				<programlisting>
SELECT maxValue(tfloat '{[1@2012-01-01, 2@2012-01-03), [3@2012-01-03, 5@2012-01-05)}');
-- 5
				</programlisting>
			</listitem>

			<listitem id="valueRange">
				<indexterm><primary><varname>valueRange</varname></primary></indexterm>
				<para>Obtener el rango de valores</para>
				<para><varname>valueRange(tnumber):numrange</varname></para>
				<para>La función no tiene en cuenta si los límites son inclusivos o no.</para>
				<programlisting>
SELECT valueRange(tfloat '{[2@2012-01-01, 1@2012-01-03), [4@2012-01-03, 6@2012-01-05)}');
-- "[1,6]"
SELECT valueRange(tfloat '{1@2012-01-01, 2@2012-01-03, 3@2012-01-05}');
-- "[1,3])"
				</programlisting>
			</listitem>

			<listitem id="valueAtTimestamp">
				<indexterm><primary><varname>valueAtTimestamp</varname></primary></indexterm>
				<para>Obtener el valor en una marca de tiempo</para>
				<para><varname>valueAtTimestamp(ttype,timestamptz):base</varname></para>
				<programlisting>
SELECT valueAtTimestamp(tfloat '[1@2012-01-01, 4@2012-01-04)', '2012-01-02');
-- "2"
				</programlisting>
			</listitem>

			<listitem id="getTimestamp">
				<indexterm><primary><varname>getTimestamp</varname></primary></indexterm>
				<para>Obtener la marca de tiempo</para>
				<para><varname>getTimestamp(ttypeinst):timestamptz</varname></para>
				<programlisting>
SELECT getTimestamp(tint '1@2012-01-01');
-- "2012-01-01"
				</programlisting>
			</listitem>

			<listitem id="getTime">
				<indexterm><primary><varname>getTime</varname></primary></indexterm>
				<para>Obtener el tiempo</para>
				<para><varname>getTime(ttype):periodset</varname></para>
				<programlisting>
SELECT getTime(tint '[1@2012-01-01, 1@2012-01-15)');
-- "{[2012-01-01, 2012-01-15)}"
				</programlisting>
			</listitem>

			<listitem id="ttype_duration">
				<indexterm><primary><varname>duration</varname></primary></indexterm>
				<para>Obtener el intervalo de tiempo</para>
				<para><varname>duration(ttype):interval</varname></para>
				<programlisting>
SELECT duration(tfloat '[1@2012-01-01, 2@2012-01-03, 2@2012-01-05)');
-- "4 days"
SELECT duration(tfloat '{[1@2012-01-01, 2@2012-01-03), [2@2012-01-04, 2@2012-01-05)}');
-- "3 days"
				</programlisting>
			</listitem>

			<listitem id="ttype_timespan">
				<indexterm><primary><varname>timespan</varname></primary></indexterm>
				<para>Obtener el intervalo de tiempo ignorando las posibles brechas de tiempo</para>
				<para><varname>timespan(ttype):interval</varname></para>
				<programlisting>
SELECT timespan(tfloat '{1@2012-01-01, 2@2012-01-03, 2@2012-01-05}');
-- "4 days"
SELECT timespan(tfloat '{[1@2012-01-01, 2@2012-01-03), [2@2012-01-04, 2@2012-01-05)}');
-- "4 days"
				</programlisting>
			</listitem>

			<listitem id="ttype_period">
				<indexterm><primary><varname>period</varname></primary></indexterm>
				<para>Obtener el período en el que está definido el valor temporal ignorando las posibles brechas de tiempo</para>
				<para><varname>period(ttype):period</varname></para>
				<programlisting>
SELECT period(tint '{1@2012-01-01, 2@2012-01-03, 3@2012-01-05}');
-- "[2012-01-01, 2012-01-05]"
SELECT period(tfloat '{[1@2012-01-01, 1@2012-01-02), [2@2012-01-03, 3@2012-01-04)}');
-- "[2012-01-01, 2012-01-04)"
				</programlisting>
			</listitem>

			<listitem id="numInstants">
				<indexterm><primary><varname>numInstants</varname></primary></indexterm>
				<para>Obtener el número de instantes diferentes</para>
				<para><varname>numInstants(ttype):integer</varname></para>
				<programlisting>
SELECT numInstants(tfloat '{[1@2000-01-01, 2@2000-01-02), (2@2000-01-02, 3@2000-01-03)}');
-- 3
				</programlisting>
			</listitem>

			<listitem id="startInstant">
				<indexterm><primary><varname>startInstant</varname></primary></indexterm>
				<para>Obtener el instante inicial</para>
				<para><varname>startInstant(ttype):ttypeinst</varname></para>
				<para>La función no tiene en cuenta si los límites son inclusivos o no.</para>
				<programlisting>
SELECT startInstant(tfloat '{[1@2000-01-01, 2@2000-01-02),
(2@2000-01-02, 3@2000-01-03)}');
-- "1@2000-01-01"
				</programlisting>
			</listitem>

			<listitem id="endInstant">
				<indexterm><primary><varname>endInstant</varname></primary></indexterm>
				<para>Obtener el instante final</para>
				<para><varname>endInstant(ttype):ttypeinst</varname></para>
				<para>La función no tiene en cuenta si los límites son inclusivos o no.</para>
				<programlisting>
SELECT endInstant(tfloat '{[1@2000-01-01, 2@2000-01-02), (2@2000-01-02, 3@2000-01-03)}');
-- "3@2000-01-03"
				</programlisting>
			</listitem>

			<listitem id="instantN">
				<indexterm><primary><varname>instantN</varname></primary></indexterm>
				<para>Obtener el enésimo instante diferente</para>
				<para><varname>instantN(ttype,integer):ttypeinst</varname></para>
				<programlisting>
SELECT instantN(tfloat '{[1@2000-01-01, 2@2000-01-02), (2@2000-01-02, 3@2000-01-03)}', 3);
-- "3@2000-01-03"
				</programlisting>
			</listitem>

			<listitem id="instants">
				<indexterm><primary><varname>instants</varname></primary></indexterm>
				<para>Obtener los instantes diferentes</para>
				<para><varname>instants(ttype):ttypeinst[]</varname></para>
				<programlisting>
SELECT instants(tfloat '{[1@2000-01-01, 2@2000-01-02), (2@2000-01-02, 3@2000-01-03)}');
-- "{"1@2000-01-01","2@2000-01-02","3@2000-01-03"}"
				</programlisting>
			</listitem>

			<listitem id="ttype_numTimestamps">
				<indexterm><primary><varname>numTimestamps</varname></primary></indexterm>
				<para>Obtener el número de marcas de tiempo diferentes</para>
				<para><varname>numTimestamps(ttype):integer</varname></para>
				<programlisting>
SELECT numTimestamps(tfloat '{[1@2012-01-01, 2@2012-01-03),
[3@2012-01-03, 5@2012-01-05)}');
-- 3
				</programlisting>
			</listitem>

			<listitem id="ttype_startTimestamp">
				<indexterm><primary><varname>startTimestamp</varname></primary></indexterm>
				<para>Obtener la marca de tiempo inicial</para>
				<para><varname>startTimestamp(ttype):timestamptz</varname></para>
				<para>La función no tiene en cuenta si los límites son inclusivos o no.</para>
				<programlisting>
SELECT startTimestamp(tfloat '[1@2012-01-01, 2@2012-01-03)');
-- "2012-01-01"
				</programlisting>
			</listitem>

			<listitem id="ttype_endTimestamp">
				<indexterm><primary><varname>endTimestamp</varname></primary></indexterm>
				<para>Obtener la marca de tiempo final</para>
				<para><varname>endTimestamp(ttype):timestamptz</varname></para>
				<para>La función no tiene en cuenta si los límites son inclusivos o no.</para>
				<programlisting>
SELECT endTimestamp(tfloat '{[1@2012-01-01, 2@2012-01-03),
[3@2012-01-03, 5@2012-01-05)}');
-- "2012-01-05"
				</programlisting>
			</listitem>

			<listitem id="ttype_timestampN">
				<indexterm><primary><varname>timestampN</varname></primary></indexterm>
				<para>Obtener la enésima marca de tiempo diferente</para>
				<para><varname>timestampN(ttype,integer):timestamptz</varname></para>
				<programlisting>
SELECT timestampN(tfloat '{[1@2012-01-01, 2@2012-01-03),
[3@2012-01-03, 5@2012-01-05)}', 3);
-- "2012-01-05"
				</programlisting>
			</listitem>

			<listitem id="ttype_timestamps">
				<indexterm><primary><varname>timestamps</varname></primary></indexterm>
				<para>Obtner las marcas de tiempo diferentes</para>
				<para><varname>timestamps(ttype):timestamptz[]</varname></para>
				<programlisting>
SELECT timestamps(tfloat '{[1@2012-01-01, 2@2012-01-03), [3@2012-01-03, 5@2012-01-05)}');
-- "{"2012-01-01", "2012-01-03", "2012-01-05"}"
				</programlisting>
			</listitem>

			<listitem id="numSequences">
				<indexterm><primary><varname>numSequences</varname></primary></indexterm>
				<para>Obtener el número de secuencias</para>
				<para><varname>numSequences({ttypeseq,ttypes}):integer</varname></para>
				<programlisting>
SELECT numSequences(tfloat '{[1@2012-01-01, 2@2012-01-03),
[3@2012-01-03, 5@2012-01-05)}');
-- 2
				</programlisting>
			</listitem>

			<listitem id="startSequence">
				<indexterm><primary><varname>startSequence</varname></primary></indexterm>
				<para>Obtener la secuencia inicial</para>
				<para><varname>startSequence({ttypeseq,ttypes}):ttypeseq</varname></para>
				<programlisting>
SELECT startSequence(tfloat '{[1@2012-01-01, 2@2012-01-03),
[3@2012-01-03, 5@2012-01-05)}');
-- "[1@2012-01-01, 2@2012-01-03)"
				</programlisting>
			</listitem>

			<listitem id="endSequence">
				<indexterm><primary><varname>endSequence</varname></primary></indexterm>
				<para>Obtener la secuencia final</para>
				<para><varname>endSequence({ttypeseq,ttypes}):ttypeseq</varname></para>
				<programlisting>
SELECT endSequence(tfloat '{[1@2012-01-01, 2@2012-01-03), [3@2012-01-03, 5@2012-01-05)}');
-- "[3@2012-01-03, 5@2012-01-05)"
				</programlisting>
			</listitem>

			<listitem id="sequenceN">
				<indexterm><primary><varname>sequenceN</varname></primary></indexterm>
				<para>Obtener la enésima secuencia</para>
				<para><varname>sequenceN({ttypeseq,ttypes},integer):ttypeseq</varname></para>
				<programlisting>
SELECT sequenceN(tfloat '{[1@2012-01-01, 2@2012-01-03),
[3@2012-01-03, 5@2012-01-05)}', 2);
-- "[3@2012-01-03, 5@2012-01-05)"
				</programlisting>
			</listitem>

			<listitem id="sequences">
				<indexterm><primary><varname>sequences</varname></primary></indexterm>
				<para>Obtener las secuencias</para>
				<para><varname>sequences({ttypeseq,ttypes}):ttypeseq[]</varname></para>
				<programlisting>
SELECT sequences(tfloat '{[1@2012-01-01, 2@2012-01-03), [3@2012-01-03, 5@2012-01-05)}');
-- "{"[1@2012-01-01, 2@2012-01-03)", "[3@2012-01-03, 5@2012-01-05)"}"
				</programlisting>
			</listitem>

			<listitem id="segments">
				<indexterm><primary><varname>segments</varname></primary></indexterm>
				<para>Obtener los segmentos</para>
				<para><varname>segments({ttypeseq,ttypes}):ttypeseq[]</varname></para>
				<programlisting>
SELECT segments(tint '{[1@2012-01-01, 3@2012-01-02, 2@2012-01-03],
  (3@2012-01-03, 5@2012-01-05]}');
-- {"[1@2012-01-01, 1@2012-01-02)","[3@2012-01-02, 3@2012-01-03)","[2@2012-01-03]",
  "(3@2012-01-03, 3@2012-01-05)","[5@2012-01-05]"}
SELECT segments(tfloat '{[1@2012-01-01, 3@2012-01-02, 2@2012-01-03],
  (3@2012-01-03, 5@2012-01-05]}');
-- {"[1@2012-01-01, 3@2012-01-02)","[3@2012-01-02, 2@2012-01-03]",
  "(3@2012-01-03, 5@2012-01-05]"}
				</programlisting>
			</listitem>

			<listitem id="shift">
				<indexterm><primary><varname>shift</varname></primary></indexterm>
				<para>Desplazar el intervalo de tiempo del valor temporal con un intervalo</para>
				<para><varname>shift(ttype,interval):ttype</varname></para>
				<programlisting>
SELECT shift(tint '{1@2001-01-01, 2@2001-01-03, 1@2001-01-05}', '1 day');
-- "{1@2001-01-02, 2@2001-01-04, 1@2001-01-06}"
SELECT shift(tfloat '[1@2001-01-01, 2@2001-01-03]', '1 day');
-- "[1@2001-01-02, 2@2001-01-04]"
SELECT asText(shift(tgeompoint '{[Point(1 1)@2001-01-01, Point(2 2)@2001-01-03],
  [Point(2 2)@2001-01-04, Point(1 1)@2001-01-05]}', '1 day'));
-- "{[POINT(1 1)@2001-01-02, POINT(2 2)@2001-01-04],
  [POINT(2 2)@2001-01-05, POINT(1 1)@2001-01-06]}"
				</programlisting>
			</listitem>

			<listitem id="tscale">
				<indexterm><primary><varname>tscale</varname></primary></indexterm>
				<para>Escalear el intervalo de tiempo del valor temporal a un intervalo. Si el intervalo de tiempo del valor temporal es cero (por ejemplo, para un instante temporal), el resultado es el valor temporal. El intervalo dado debe ser estrictamente mayor que cero.</para>
				<para><varname>tscale(ttype,interval):ttype</varname></para>
				<programlisting>
SELECT tscale(tint '1@2001-01-01', '1 day');
-- "1@2001-01-01"
SELECT tscale(tint '{1@2001-01-01, 2@2001-01-03, 1@2001-01-05}', '1 day');
-- "{1@2001-01-01 00:00:00+01, 2@2001-01-01 12:00:00+01, 1@2001-01-02 00:00:00+01}"
SELECT tscale(tfloat '[1@2001-01-01, 2@2001-01-03]', '1 day');
-- "[1@2001-01-01, 2@2001-01-02]"
SELECT asText(tscale(tgeompoint '{[Point(1 1)@2001-01-01, Point(2 2)@2001-01-02,
  Point(1 1)@2001-01-03], [Point(2 2)@2001-01-04, Point(1 1)@2001-01-05]}', '1 day'));
-- "{[POINT(1 1)@2001-01-01 00:00:00+01, POINT(2 2)@2001-01-01 06:00:00+01,
  POINT(1 1)@2001-01-01 12:00:00+01], [POINT(2 2) @2001-01-01 18:00:00+01,
  POINT(1 1)@2001-01-02 00:00:00+01]}"
SELECT tscale(tint '1@2001-01-01', '-1 day');
-- ERROR:  The duration must be a positive interval: -1 days
				</programlisting>
			</listitem>

			<listitem id="shiftTscale">
				<indexterm><primary><varname>shiftTscale</varname></primary></indexterm>
				<para>Desplazar y escalear el intervalo de tiempo del valor temporal a los dos intervalos. Esta función combina en un solo paso las funciones <link linkend="shift"><varname>shift</varname></link> y <link linkend="tscale"><varname>tscale</varname></link>.</para>
				<para><varname>shiftTscale(ttype,interval,interval):ttype</varname></para>
				<programlisting>
SELECT shiftTscale(tint '1@2001-01-01', '1 day', '1 day');
-- "1@2001-01-02"
SELECT shiftTscale(tint '{1@2001-01-01, 2@2001-01-03, 1@2001-01-05}', '1 day', '1 day');
-- "{1@2001-01-02 00:00:00+01, 2@2001-01-02 12:00:00+01, 1@2001-01-03 00:00:00+01}"
SELECT shiftTscale(tfloat '[1@2001-01-01, 2@2001-01-03]', '1 day', '1 day');
-- "[1@2001-01-02, 2@2001-01-03]"
SELECT asText(shiftTscale(tgeompoint '{[Point(1 1)@2001-01-01, Point(2 2)@2001-01-02,
  Point(1 1)@2001-01-03], [Point(2 2)@2001-01-04, Point(1 1)@2001-01-05]}',
  '1 day', '1 day'));
-- "{[POINT(1 1)@2001-01-02 00:00:00+01, POINT(2 2)@2001-01-02 06:00:00+01,
  POINT(1 1)@2001-01-02 12:00:00+01], [POINT(2 2) @2001-01-02 18:00:00+01,
  POINT(1 1)@2001-01-03 00:00:00+01]}"
				</programlisting>
			</listitem>

			<listitem id="intersectsTimestamp">
				<indexterm><primary><varname>intersectsTimestamp</varname></primary></indexterm>
				<para>¿Se cruza el valor temporal con la marca de tiempo?</para>
				<para><varname>intersectsTimestamp(ttype,timestamptz):boolean</varname></para>
				<programlisting>
SELECT intersectsTimestamp(tint '[1@2012-01-01, 1@2012-01-15)', timestamptz '2012-01-03');
-- true
				</programlisting>
			</listitem>

			<listitem id="intersectsTimestampSet">
				<indexterm><primary><varname>intersectsTimestampSet</varname></primary></indexterm>
				<para>¿Se cruza el valor temporal con el conjunto de marcas tiempo?</para>
				<para><varname>intersectsTimestampSet(ttype,timestampset):boolean</varname></para>
				<programlisting>
SELECT intersectsTimestampSet(tint '[1@2012-01-01, 1@2012-01-15)',
  timestampset '{2012-01-01, 2012-01-03}');
-- true
				</programlisting>
			</listitem>

			<listitem id="intersectsPeriod">
				<indexterm><primary><varname>intersectsPeriod</varname></primary></indexterm>
				<para>¿Se cruza el valor temporal con el período?</para>
				<para><varname>intersectsPeriod(ttype,period):boolean</varname></para>
				<programlisting>
SELECT intersectsPeriod(tint '[1@2012-01-01, 1@2012-01-04)',
  period '[2012-01-01,2012-01-05)');
-- true
				</programlisting>
			</listitem>

			<listitem id="intersectsPeriodSet">
				<indexterm><primary><varname>intersectsPeriodSet</varname></primary></indexterm>
				<para>¿Se cruza el valor temporal con el conjunto de períodos?</para>
				<para><varname>intersectsPeriodSet(ttype,periodset):boolean</varname></para>
				<programlisting>
SELECT intersectsPeriodSet(tbool '[t@2012-01-01, f@2012-01-15]',
  periodset '{[2012-01-01, 2012-01-03), [2012-01-05, 2012-01-07)}');
-- true
				</programlisting>
			</listitem>

			<listitem id="twAvg">
				<indexterm><primary><varname>twAvg</varname></primary></indexterm>
				<para>Obtener el promedio ponderado en el tiempo</para>
				<para><varname>twAvg(tnumber):float</varname></para>
				<programlisting>
SELECT twAvg(tfloat '{[1@2012-01-01, 2@2012-01-03), [2@2012-01-04, 2@2012-01-06)}');
-- 1.75
				</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1>
		<title>Funciones espaciales</title>
		<para>A continuación, especificamos con el símbolo &Z_support; que la función admite puntos 3D y con el  símbolo &geography_support; que la función está disponible para geografías.</para>

		<itemizedlist>
			<listitem id="asText">
				<indexterm><primary><varname>asText</varname></primary></indexterm>
				<para>Obtener la representación de texto conocido (Well-Known Text o WKT) &Z_support; &geography_support;</para>
				<para><varname>asText({tpoint,tpoint[],geo[]}):{text,text[]}</varname></para>
				<programlisting>
SELECT asText(tgeompoint 'SRID=4326;[Point(0 0 0)@2012-01-01, Point(1 1 1)@2012-01-02)');
-- "[POINT Z (0 0 0)@2012-01-01 00:00:00+00, POINT Z (1 1 1)@2012-01-02 00:00:00+00)"
SELECT asText(ARRAY[geometry 'Point(0 0)', 'Point(1 1)']);
-- "{"POINT(0 0)","POINT(1 1)"}"
				</programlisting>
			</listitem>

			<listitem id="asEWKT">
				<indexterm><primary><varname>asEWKT</varname></primary></indexterm>
				<para>Obtener la representación extendida de texto conocido (Extended Well-Known Text o EWKT)</para>
				<para><varname>asEWKT({tpoint,tpoint[],geo[]}):{text,text[]}</varname></para>
				<programlisting>
SELECT asEWKT(tgeompoint 'SRID=4326;[Point(0 0 0)@2012-01-01, Point(1 1 1)@2012-01-02)');
-- "SRID=4326;[POINT Z (0 0 0)@2012-01-01 00:00:00+00,
POINT Z (1 1 1)@2012-01-02 00:00:00+00)"
SELECT asEWKT(ARRAY[geometry 'SRID=5676;Point(0 0)', 'SRID=5676;Point(1 1)']);
-- "{"SRID=5676;POINT(0 0)","SRID=5676;POINT(1 1)"}"
				</programlisting>
			</listitem>

			<listitem id="asMFJSON">
				<indexterm><primary><varname>asMFJSON</varname></primary></indexterm>
				<para>Obtener la representación JSON de característica móviles (Moving Features) &Z_support; &geography_support;</para>
				<para><varname>asMFJSON(tpoint,maxdecdigits integer=15,options integer=0):bytea</varname></para>
				<para>El último argumento <varname>options</varname> puede usarse para agregar BBOX y/o CRS en la salida MFJSON:</para>
				<itemizedlist>
					<listitem><para>0: significa que no hay opción (valor por defecto)</para></listitem>
					<listitem><para>1: MFJSON BBOX</para></listitem>
					<listitem><para>2: MFJSON Short CRS (e.g EPSG:4326)</para></listitem>
					<listitem><para>4: MFJSON Long CRS (e.g urn:ogc:def:crs:EPSG::4326)</para></listitem>
				</itemizedlist>
				<programlisting>
SELECT asMFJSON(tgeompoint 'Point(1 2)@2019-01-01 18:00:00.15+02');
-- "{"type":"MovingPoint","coordinates":[1,2],"datetimes":"2019-01-01T17:00:00.15+01",
"interpolations":["Discrete"]}"
SELECT asMFJSON(tgeompoint 'SRID=4326;
Point(50.813810 4.384260)@2019-01-01 18:00:00.15+02', 2, 3);
-- "{"type":"MovingPoint","crs":{"type":"name","properties":{"name":"EPSG:4326"}},
"stBoundedBy":{"bbox":[50.81,4.38,50.81,4.38],
"period":{"begin":"2019-01-01 17:00:00.15+01","end":"2019-01-01 17:00:00.15+01"}},
"coordinates":[50.81,4.38],"datetimes":"2019-01-01T17:00:00.15+01",
"interpolations":["Discrete"]}"
				</programlisting>
			</listitem>

			<listitem id="asBinary">
				<indexterm><primary><varname>asBinary</varname></primary></indexterm>
				<para>Obtener la representación binaria conocida (Well-Known Binary o WKB) &Z_support; &geography_support;</para>
				<para><varname>asBinary(tpoint):bytea</varname></para>
				<para><varname>asBinary(tpoint,text):bytea</varname></para>
				<para>El resultado se codifica utilizando la codificación little-endian (NDR) o big-endian (XDR). Si no se especifica ninguna codificación, se utiliza la codificación de la máquina.</para>
				<programlisting>
SELECT asBinary(tgeompoint 'SRID=4326;Point(1 2 3)@2012-01-01');
-- "\001\001\000\000\000\000\000\000\360?\000\000\000\000\000\000\000@\000\000\000\000\000\000\010@\000\374\340\023jX\001\000"
				</programlisting>
			</listitem>

			<listitem id="asEWKB">
				<indexterm><primary><varname>asEWKB</varname></primary></indexterm>
				<para>Obtener la representación extendida binaria conocida (Extended Well-Known Binary o EWKB) &Z_support; &geography_support;</para>
				<para><varname>asEWKB(tpoint):bytea</varname></para>
				<para><varname>asEWKB(tpoint,text):bytea</varname></para>
				<para>El resultado se codifica utilizando la codificación little-endian (NDR) o big-endian (XDR). Si no se especifica ninguna codificación, se utiliza la codificación de la máquina.</para>
				<programlisting>
SELECT asEWKB(tgeompoint 'SRID=4326;Point(1 2 3)@2012-01-01');
-- "\0011\346\020\000\000\000\000\000\000\000\000\360?\000\000\000\000\000\000\000@\000\000\000\000\000\000\010@\000\374\340\023jX\001\000"
				</programlisting>
			</listitem>

			<listitem id="asHexEWKB">
				<indexterm><primary><varname>asHexEWKB</varname></primary></indexterm>
				<para>Obtener la representación hexadecimal extendida binaria conocida (Extended Well-Known Binary o EWKB) en formato texto &Z_support; &geography_support;</para>
				<para><varname>asHexEWKB(tpoint):text</varname></para>
				<para><varname>asHexEWKB(tpoint,text):text</varname></para>
				<para>El resultado se codifica utilizando la codificación little-endian (NDR) o big-endian (XDR). Si no se especifica ninguna codificación, se utiliza NDR.</para>
				<programlisting>
SELECT asHexEWKB(tgeompoint 'SRID=4326;Point(1 2 3)@2012-01-01');
-- "0131E6100000000000000000F03F0000000000000040000000000000084000FCE0136A580100"
				</programlisting>
			</listitem>

			<listitem id="tgeompointFromMFJSON">
				<indexterm><primary><varname>tgeompointFromMFJSON</varname></primary></indexterm>
				<para>Entrar un punto temporal geométrico en una representación JSON de características móviles (Moving Features) &Z_support;</para>
				<para><varname>tgeompointFromMFJSON(text):tgeompoint</varname></para>
				<programlisting>
SELECT asEWKT(tgeompointFromMFJSON(text '{"type":"MovingPoint","crs":{"type":"name",
"properties":{"name":"EPSG:4326"}},"coordinates":[50.81,4.38],
"datetimes":"2019-01-01T17:00:00.15+01","interpolations":["Discrete"]}'));
-- "SRID=4326;POINT(50.81 4.38)@2019-01-01 17:00:00.15+01"
				</programlisting>
			</listitem>

			<listitem id="tgeogpointFromMFJSON">
				<indexterm><primary><varname>tgeogpointFromMFJSON</varname></primary></indexterm>
				<para>Entrar un punto temporal geográfico en una representación JSON de características móviles (Moving Features) &Z_support; &geography_support;</para>
				<para><varname>tgeogpointFromMFJSON(text):tgeogpoint</varname></para>
				<programlisting>
SELECT asEWKT(tgeogpointFromMFJSON(text '{"type":"MovingPoint","crs":{"type":"name",
"properties":{"name":"EPSG:4326"}},"coordinates":[50.81,4.38],
"datetimes":"2019-01-01T17:00:00.15+01","interpolations":["Discrete"]}'));
-- "SRID=4326;POINT(50.81 4.38)@2019-01-01 17:00:00.15+01"
				</programlisting>
			</listitem>

			<listitem id="tgeompointFromEWKB">
				<indexterm><primary><varname>tgeompointFromEWKB</varname></primary></indexterm>
				<para>Entrar un punto temporal geométrico en una representación extendida binaria conocida (EWKB) &Z_support;</para>
				<para><varname>tgeompointFromEWKB(bytea):tgeompoint</varname></para>
				<programlisting>
SELECT asEWKT(tgeompointFromEWKB(bytea
'\0011\346\020\000\000\000\000\000\000\000\000\360?\000\000\000\000\000\000\000@\000\000\000\000\000\000\010@\000\374\340\023jX\001\000'));
-- "SRID=4326;POINT Z (1 2 3)@2012-01-01"
				</programlisting>
			</listitem>

			<listitem id="tgeogpointFromEWKB">
				<indexterm><primary><varname>tgeogpointFromEWKB</varname></primary></indexterm>
				<para>Entrar un punto temporal geográfico en una representación extendida binaria conocida (EWKB) &Z_support; &geography_support;</para>
				<para><varname>tgeogpointFromEWKB(bytea):tgeogpoint</varname></para>
				<programlisting>
SELECT asEWKT(tgeogpointFromEWKB(bytea
'\0011\346\020\000\000\000\000\000\000\000\000\360?\000\000\000\000\000\000\000@\000\000\000\000\000\000\010@\000\374\340\023jX\001\000'));
-- "SRID=4326;POINT Z (1 2 3)@2012-01-01"
				</programlisting>
			</listitem>

			<listitem id="tpoint_SRID">
				<indexterm><primary><varname>SRID</varname></primary></indexterm>
				<para>Obtener el identificador de referencia espacial &Z_support; &geography_support;</para>
				<para><varname>SRID(tpoint):integer</varname></para>
				<programlisting>
SELECT SRID(tgeompoint 'Point(0 0)@2012-01-01');
-- 0
				</programlisting>
			</listitem>

			<listitem id="tpoint_setSRID">
				<indexterm><primary><varname>setSRID</varname></primary></indexterm>
				<para>Establecer el identificador de referencia espacial &Z_support; &geography_support;</para>
				<para><varname>setSRID(tpoint):tpoint</varname></para>
				<programlisting>
SELECT asEWKT(setSRID(tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-02)', 4326));
-- "SRID=4326;[POINT(0 0)@2012-01-01 00:00:00+00, POINT(1 1)@2012-01-02 00:00:00+00)"
				</programlisting>
				</listitem>

			<listitem id="tpoint_transform">
				<indexterm><primary><varname>transform</varname></primary></indexterm>
				<para>Transformar a una referencia espacial diferente &Z_support; &geography_support;</para>
				<para><varname>transform(tpoint,integer):tpoint</varname></para>
				<programlisting>
SELECT asEWKT(transform(tgeompoint 'SRID=4326;Point(4.35 50.85)@2012-01-01', 3812));
-- "SRID=3812;POINT(648679.018035303 671067.055638114)@2012-01-01 00:00:00+00"
				</programlisting>
			</listitem>

			<listitem id="tpoint_setPrecision">
				<indexterm><primary><varname>setPrecision</varname></primary></indexterm>
				<para>Redondear los valores de las coordenadas a un número de decimales &Z_support; &geography_support;</para>
				<para><varname>setPrecision(tpoint,integer):tpoint</varname></para>
				<programlisting>
SELECT asText(setPrecision(tgeompoint '{Point(1.12345 1.12345 1.12345)@2000-01-01,
Point(2 2 2)@2000-01-02, Point(1.12345 1.12345 1.12345)@2000-01-03}', 2));
-- "{POINT Z (1.12 1.12 1.12)@2000-01-01, POINT Z (2 2 2)@2000-01-02,
POINT Z (1.12 1.12 1.12)@2000-01-03}"
SELECT asText(setPrecision(tgeogpoint 'Point(1.12345 1.12345)@2000-01-01', 2));
-- "POINT(1.12 1.12)@2000-01-01"
				</programlisting>
			</listitem>

			<listitem id="getX">
				<indexterm><primary><varname>getX</varname></primary></indexterm>
				<para>Obtener los valores de las coordenadas X como un número flotante temporal &Z_support; &geography_support;</para>
				<para><varname>getX(tpoint):tfloat</varname></para>
				<programlisting>
SELECT getX(tgeompoint '{Point(1 2)@2000-01-01, Point(3 4)@2000-01-02,
  Point(5 6)@2000-01-03}');
-- "{1@2000-01-01, 3@2000-01-02, 5@2000-01-03}"
SELECT getX(tgeogpoint 'Interp=Stepwise;[Point(1 2 3)@2000-01-01, Point(4 5 6)@2000-01-02,
  Point(7 8 9)@2000-01-03]');
-- "Interp=Stepwise;[1@2000-01-01, 4@2000-01-02, 7@2000-01-03]"
				</programlisting>
			</listitem>

			<listitem id="getY">
				<indexterm><primary><varname>getY</varname></primary></indexterm>
				<para>Obtener los valores de las coordenadas Y como un número flotante temporal &Z_support; &geography_support;</para>
				<para><varname>getY(tpoint):tfloat</varname></para>
				<programlisting>
SELECT getY(tgeompoint '{Point(1 2)@2000-01-01, Point(3 4)@2000-01-02,
  Point(5 6)@2000-01-03}');
-- "{2@2000-01-01, 4@2000-01-02, 6@2000-01-03}"
SELECT getY(tgeogpoint 'Interp=Stepwise;[Point(1 2 3)@2000-01-01, Point(4 5 6)@2000-01-02,
  Point(7 8 9)@2000-01-03]');
-- "Interp=Stepwise;[2@2000-01-01, 5@2000-01-02, 8@2000-01-03]"
				</programlisting>
			</listitem>

			<listitem id="getZ">
				<indexterm><primary><varname>getZ</varname></primary></indexterm>
				<para>Obtener los valores de las coordenadas Z como un número flotante temporal &Z_support; &geography_support;</para>
				<para><varname>getZ(tpoint):tfloat</varname></para>
				<programlisting>
SELECT getZ(tgeompoint '{Point(1 2)@2000-01-01, Point(3 4)@2000-01-02,
  Point(5 6)@2000-01-03}');
-- The temporal point do not have Z dimension
SELECT getZ(tgeogpoint 'Interp=Stepwise;[Point(1 2 3)@2000-01-01, Point(4 5 6)@2000-01-02,
  Point(7 8 9)@2000-01-03]');
-- "Interp=Stepwise;[3@2000-01-01, 6@2000-01-02, 9@2000-01-03]"
				</programlisting>
			</listitem>

			<listitem id="isSimple">
				<indexterm><primary><varname>isSimple</varname></primary></indexterm>
				<para>Devuelve verdadero si el punto temporal no se auto-intersecta espacialmente &Z_support;</para>
				<para><varname>isSimple(tpoint):boolean</varname></para>
				<para>Nótese que un punto temporal de conjunto de secuencias es simple si cada una de las secuencias que lo componen es simple.</para>
				<programlisting>
SELECT isSimple(tgeompoint '[Point(0 0)@2000-01-01, Point(1 1)@2000-01-02,
Point(0 0)@2000-01-03]');
-- false
SELECT isSimple(tgeompoint '[Point(0 0 0)@2000-01-01, Point(1 1 1)@2000-01-02,
Point(2 0 2)@2000-01-03, Point(0 0 0)@2000-01-04]');
-- true
SELECT isSimple(tgeompoint '{[Point(0 0 0)@2000-01-01, Point(1 1 1)@2000-01-02],
[Point(1 1 1)@2000-01-03, Point(0 0 0)@2000-01-04]}');
-- true
				</programlisting>
			</listitem>

			<listitem id="makeSimple">
				<indexterm><primary><varname>makeSimple</varname></primary></indexterm>
				<para>Devuelve una matriz de fragmentos del punto temporal que son simples &Z_support;</para>
				<para><varname>makeSimple(tpoint):tgeompoint[]</varname></para>
				<programlisting>
SELECT asText(makeSimple(tgeompoint '[Point(0 0)@2000-01-01, Point(1 1)@2000-01-02,
Point(0 0)@2000-01-03]'));
-- {"[POINT(0 0)@2000-01-01, POINT(1 1)@2000-01-02)",
   "[POINT(1 1)@2000-01-02, POINT(0 0)@2000-01-03]"}
SELECT asText(makeSimple(tgeompoint '[Point(0 0 0)@2000-01-01, Point(1 1 1)@2000-01-02,
Point(2 0 2)@2000-01-03, Point(0 0 0)@2000-01-04]'));
-- {"[POINT Z (0 0 0)@2000-01-01, POINT Z (1 1 1)@2000-01-02, POINT Z (2 0 2)@2000-01-03,
   POINT Z (0 0 0)@2000-01-04]"}
SELECT asText(makeSimple(tgeompoint '[Point(0 0)@2000-01-01, Point(1 1)@2000-01-02,
Point(0 1)@2000-01-03, Point(1 0)@2000-01-04]'));
-- {"[POINT(0 0)@2000-01-01, POINT(1 1)@2000-01-02, POINT(0 1)@2000-01-03)",
   "[POINT(0 1)@2000-01-03, POINT(1 0)@2000-01-04]"}
SELECT asText(makeSimple(tgeompoint '{[Point(0 0 0)@2000-01-01, Point(1 1 1)@2000-01-02],
[Point(1 1 1)@2000-01-03, Point(0 0 0)@2000-01-04]}'));
-- {"{[POINT Z (0 0 0)@2000-01-01, POINT Z (1 1 1)@2000-01-02],
   [POINT Z (1 1 1)@2000-01-03, POINT Z (0 0 0)@2000-01-04]}"}
				</programlisting>
			</listitem>

			<listitem id="length">
				<indexterm><primary><varname>length</varname></primary></indexterm>
				<para>Obtener la longitud atravesada por el punto temporal &Z_support; &geography_support;</para>
				<para><varname>length(tpoint):float</varname></para>
				<programlisting>
SELECT length(tgeompoint '[Point(0 0 0)@2000-01-01, Point(1 1 1)@2000-01-02]');
-- 1.73205080756888
SELECT length(tgeompoint '[Point(0 0 0)@2000-01-01, Point(1 1 1)@2000-01-02,
Point(0 0 0)@2000-01-03]');
-- 3.46410161513775
SELECT length(tgeompoint 'Interp=Stepwise;[Point(0 0 0)@2000-01-01, Point(1 1 1)@2000-01-02,
Point(0 0 0)@2000-01-03]');
-- 0
				</programlisting>
			</listitem>

			<listitem id="cumulativeLength">
				<indexterm><primary><varname>cumulativeLength</varname></primary></indexterm>
				<para>Obtener la longitud acumulada atravesada por el punto temporal &Z_support; &geography_support;</para>
				<para><varname>cumulativeLength(tpoint):tfloatseq</varname></para>
				<programlisting>
SELECT round(cumulativeLength(tgeompoint '{[Point(0 0)@2000-01-01, Point(1 1)@2000-01-02,
  Point(1 0)@2000-01-03], [Point(1 0)@2000-01-04, Point(0 0)@2000-01-05]}'), 6);
-- {[0@2000-01-01, 1.414214@2000-01-02, 2.414214@2000-01-03],
  [2.414214@2000-01-04, 3.414214@2000-01-05]}
SELECT cumulativeLength(tgeompoint 'Interp=Stepwise;[Point(0 0 0)@2000-01-01,
  Point(1 1 1)@2000-01-02, Point(0 0 0)@2000-01-03]');
-- Interp=Stepwise;[0@2000-01-01, 0@2000-01-03]
				</programlisting>
			</listitem>

			<listitem id="speed">
				<indexterm><primary><varname>speed</varname></primary></indexterm>
				<para>Obtener la velocidad del punto temporal en unidades por segundo &Z_support; &geography_support;</para>
				<para><varname>speed(tpoint):tfloats</varname></para>
				<para>El punto temporal debe tener interpolación linear</para>
				<programlisting>
SELECT speed(tgeompoint '{[Point(0 0)@2000-01-01, Point(1 1)@2000-01-02,
  Point(1 0)@2000-01-03], [Point(1 0)@2000-01-04, Point(0 0)@2000-01-05]}') * 3600 * 24;
-- "Interp=Stepwise;{[1.4142135623731@2000-01-01, 1@2000-01-02, 1@2000-01-03],
  [1@2000-01-04, 1@2000-01-05]}"
SELECT speed(tgeompoint 'Interp=Stepwise;[Point(0 0)@2000-01-01, Point(1 1)@2000-01-02,
  Point(1 0)@2000-01-03]');
-- ERROR:  The temporal value must have linear interpolation
				</programlisting>
			</listitem>

			<listitem id="twCentroid">
				<indexterm><primary><varname>twCentroid</varname></primary></indexterm>
				<para>Obtener el centroide ponderado en el tiempo &Z_support;</para>
				<para><varname>twCentroid(tgeompoint):point</varname></para>
				<programlisting>
SELECT ST_AsText(twCentroid(tgeompoint '{[Point(0 0 0)@2012-01-01,
  Point(0 1 1)@2012-01-02, Point(0 1 1)@2012-01-03, Point(0 0 0)@2012-01-04)}'));
-- "POINT Z (0 0.666666666666667 0.666666666666667)"
				</programlisting>
			</listitem>

			<listitem id="azimuth">
				<indexterm><primary><varname>azimuth</varname></primary></indexterm>
				<para>Obtener el acimut temporal &Z_support; &geography_support;</para>
				<para><varname>azimuth(tpoint):tfloat</varname></para>
				<programlisting>
SELECT degrees(azimuth(tgeompoint '[Point(0 0 0)@2012-01-01, Point(1 1 1)@2012-01-02,
  Point(1 1 1)@2012-01-03, Point(0 0 0)@2012-01-04)'));
-- "Interp=Stepwise;{[45@2012-01-01, 45@2012-01-02], [225@2012-01-03, 225@2012-01-04)}"
				</programlisting>
			</listitem>

			<listitem id="nearestApproachInstant">
				<indexterm><primary><varname>nearestApproachInstant</varname></primary></indexterm>
				<para>Obtener el instante del primer punto temporal en el que los dos argumentos están a la distancia más cercana &Z_support; &geography_support;</para>
				<para><varname>nearestApproachInstant({geo,tpoint},{geo,tpoint}):tpoint</varname></para>
				<para>La función sólo devuelve el primer instante que encuentre si hay más de uno. El instante resultante puede tener un límite exclusivo.</para>
				<programlisting>
SELECT asText(NearestApproachInstant(tgeompoint '(Point(1 1)@2000-01-01,
  Point(3 1)@2000-01-03]', geometry 'Linestring(1 3,2 2,3 3)'));
-- "POINT(2 1)@2000-01-02"
SELECT asText(NearestApproachInstant(tgeompoint 'Interp=Stepwise;(Point(1 1)@2000-01-01,
  Point(3 1)@2000-01-03]', geometry 'Linestring(1 3,2 2,3 3)'));
-- "POINT(1 1)@2000-01-01"
SELECT asText(NearestApproachInstant(tgeompoint '(Point(1 1)@2000-01-01,
  Point(2 2)@2000-01-03]', tgeompoint '(Point(1 1)@2000-01-01, Point(4 1)@2000-01-03]'));
-- "POINT(1 1)@2000-01-01"
SELECT asText(nearestApproachInstant(tgeompoint '[Point(0 0 0)@2012-01-01,
  Point(1 1 1)@2012-01-03, Point(0 0 0)@2012-01-05)', tgeompoint
  '[Point(2 0 0)@2012-01-02, Point(1 1 1)@2012-01-04, Point(2 2 2)@2012-01-06)'));
-- "POINT Z (0.75 0.75 0.75)@2012-01-03 12:00:00+00"
				</programlisting>
				<para>La función <varname>nearestApproachInstant</varname> generaliza the la función PostGIS <varname>ST_ClosestPointOfApproach</varname>. Primero, la última función requiere que ambos argumentos sean trayectorias. Segundo, la función <varname>nearestApproachInstant</varname> devuelve tanto el punto como la marca de tiempo del punto de aproximación más cercano, mientras que la función PostGIS sólo proporciona la marca de tiempo como se muestra a continuación.</para>
				<programlisting>
SELECT to_timestamp(ST_ClosestPointOfApproach(
tgeompoint '[Point(0 0 0)@2012-01-01, Point(1 1 1)@2012-01-03,
  Point(0 0 0)@2012-01-05)'::geometry,
tgeompoint '[Point(2 0 0)@2012-01-02, Point(1 1 1)@2012-01-04,
  Point(2 2 2)@2012-01-06)'::geometry));
-- "2012-01-03 12:00:00+00"
				</programlisting>
			</listitem>

			<listitem id="nearestApproachDistance">
				<indexterm><primary><varname>nearestApproachDistance</varname></primary></indexterm>
				<para>Obtener la distancia más pequeña que haya existido &Z_support; &geography_support;</para>
				<para><varname>nearestApproachDistance({geo,tpoint},{geo,tpoint}):float</varname></para>
				<programlisting>
SELECT NearestApproachDistance(tgeompoint '(Point(1 1)@2000-01-01,
  Point(3 1)@2000-01-03]', geometry 'Linestring(1 3,2 2,3 3)');
-- 1
SELECT NearestApproachDistance(tgeompoint 'Interp=Stepwise;(Point(1 1)@2000-01-01,
  Point(3 1)@2000-01-03]', geometry 'Linestring(1 3,2 2,3 3)');
-- 1.4142135623731
SELECT nearestApproachDistance(
tgeompoint '[Point(0 0 0)@2012-01-01, Point(1 1 1)@2012-01-03,
  Point(0 0 0)@2012-01-05)',
tgeompoint '[Point(2 0 0)@2012-01-02, Point(1 1 1)@2012-01-04,
  Point(2 2 2)@2012-01-06)');
-- "0.5"
				</programlisting>
				<para>La función <varname>nearestApproachDistance</varname> tiene un operador asociado <varname>|=|</varname> que se puede utilizar para realizar una búsqueda de vecino más cercano utilizando un índice GiST (see <xref linkend="operators_temporal_types" />). Esta función corresponde a la función <varname>ST_DistanceCPA</varname> proporcionada por PostGIS, aunque este última requiere que ambos argumentos sean una trayectoria.</para>
				<programlisting>
SELECT ST_DistanceCPA(
tgeompoint '[Point(0 0 0)@2012-01-01, Point(1 1 1)@2012-01-03,
  Point(0 0 0)@2012-01-05)'::geometry,
tgeompoint '[Point(2 0 0)@2012-01-02, Point(1 1 1)@2012-01-04,
  Point(2 2 2)@2012-01-06)'::geometry);
-- "0.5"
				</programlisting>
			</listitem>

			<listitem id="shortestLine">
				<indexterm><primary><varname>shortestLine</varname></primary></indexterm>
				<para>Obtener la línea que conecta el punto de aproximación más cercano &Z_support; &geography_support;</para>
				<para><varname>shortestLine({geo,tpoint},{geo,tpoint}):geo</varname></para>
				<para>La función sólo devolverá la primera línea que encuentre si hay más de una.</para>
				<programlisting>
SELECT ST_AsText(shortestLine(tgeompoint '(Point(1 1)@2000-01-01,
  Point(3 1)@2000-01-03]', geometry 'Linestring(1 3,2 2,3 3)'));
-- "LINESTRING(2 1,2 2)"
SELECT ST_AsText(shortestLine(tgeompoint 'Interp=Stepwise;(Point(1 1)@2000-01-01,
  Point(3 1)@2000-01-03]', geometry 'Linestring(1 3,2 2,3 3)'));
-- "LINESTRING(1 1,2 2)"
SELECT ST_AsText(shortestLine(
  tgeompoint '[Point(0 0 0)@2012-01-01, Point(1 1 1)@2012-01-03,
    Point(0 0 0)@2012-01-05)',
  tgeompoint '[Point(2 0 0)@2012-01-02, Point(1 1 1)@2012-01-04,
    Point(2 2 2)@2012-01-06)'));
-- "LINESTRING Z (0.75 0.75 0.75,1.25 0.75 0.75)"
				</programlisting>
				<para>La función <varname>shortestLine</varname> se puede utilizar para obtener el resultado proporcionado por la función PostGIS <varname>ST_CPAWithin</varname> cuando ambos argumentos son trayectorias como se muestra a continuación.</para>
				<programlisting>
SELECT ST_Length(shortestLine(
  tgeompoint '[Point(0 0 0)@2012-01-01, Point(1 1 1)@2012-01-03,
    Point(0 0 0)@2012-01-05)',
  tgeompoint '[Point(2 0 0)@2012-01-02, Point(1 1 1)@2012-01-04,
    Point(2 2 2)@2012-01-06)')) &lt;= 0.5;
-- true
SELECT ST_CPAWithin(
  tgeompoint '[Point(0 0 0)@2012-01-01, Point(1 1 1)@2012-01-03,
    Point(0 0 0)@2012-01-05)'::geometry,
  tgeompoint '[Point(2 0 0)@2012-01-02, Point(1 1 1)@2012-01-04,
    Point(2 2 2)@2012-01-06)'::geometry, 0.5);
-- true
				</programlisting>
			</listitem>

			<listitem id="simplify">
				<indexterm><primary><varname>simplify</varname></primary></indexterm>
				<para>Simplificar un punto temporal usando una generalización del algoritmo de Douglas-Peucker &Z_support;</para>
				<para><varname>simplify(tpoint,float):tpoint</varname></para>
				<para><varname>simplify(tpoint,float,float):tpoint</varname></para>
				<para>La primera versión elimina los puntos cuya distancia es menor que la distancia pasada como segundo argumento, que se especifica en las unidades del sistema de coordenadas. La segunda versión elimina los puntos cuya distancia es menor que la distancia pasada como segundo argumento siempre que la diferencia de velocidad entre el punto y el punto correspondiente en la versión simplificada sea menor que la velocidad pasada como tercer argumento, que se especifica en unidades por segundo. Observe que la simplificación se aplica sólo a secuencias temporales o conjuntos de secuencias con interpolación lineal. En todos los demás casos, se devuelve una copia del punto temporal dado.</para>

				<programlisting>-- Solo distancia especificada
SELECT ST_AsText(trajectory(simplify(tgeompoint '[Point(0 4)@2000-01-01,
Point(1 1)@2000-01-02, Point(2 3)@2000-01-03, Point(3 1)@2000-01-04,
Point(4 3)@2000-01-05, Point(5 0)@2000-01-06, Point(6 4)@2000-01-07]', 1.5)));
-- "LINESTRING(0 4,1 1,4 3,5 0,6 4)"
SELECT ST_AsText(trajectory(simplify(tgeompoint '[Point(0 4)@2000-01-01,
Point(1 1)@2000-01-02, Point(2 3)@2000-01-03, Point(3 1)@2000-01-04,
Point(4 3)@2000-01-05, Point(5 0)@2000-01-06, Point(6 4)@2000-01-07]', 2)));
-- "LINESTRING(0 4,5 0,6 4)"
SELECT ST_AsText(trajectory(simplify(tgeompoint '[Point(0 4)@2000-01-01,
Point(1 1)@2000-01-02, Point(2 3)@2000-01-03, Point(3 1)@2000-01-04,
Point(4 3)@2000-01-05, Point(5 0)@2000-01-06, Point(6 4)@2000-01-07]', 4)));
-- "LINESTRING(0 4,6 4)"

-- Solo diferencia de velocidad especificada
SELECT round(speed(tgeompoint '[Point(0 4)@2000-01-01, Point(1 1)@2000-01-02,
Point(2 3)@2000-01-03, Point(3 1)@2000-01-04, Point(4 3)@2000-01-05,
Point(5 0)@2000-01-06, Point(6 4)@2000-01-07]') * 1e5, 2);
-- "Interp=Stepwise;[3.66@2000-01-01, 2.59@2000-01-02, 3.66@2000-01-05,
4.77@2000-01-06, 4.77@2000-01-07]"

-- Se especifican tanto la distancia como la diferencia de velocidad
SELECT ST_AsText(trajectory(simplify(tgeompoint '[Point(0 4)@2000-01-01,
Point(1 1)@2000-01-02, Point(2 3)@2000-01-03, Point(3 1)@2000-01-04,
Point(4 3)@2000-01-05, Point(5 0)@2000-01-06, Point(6 4)@2000-01-07]', 4, 1 / 1e5)));
-- "LINESTRING(0 4,1 1,2 3,3 1,4 3,5 0,6 4)"
SELECT ST_AsText(trajectory(simplify(tgeompoint '[Point(0 4)@2000-01-01,
Point(1 1)@2000-01-02, Point(2 3)@2000-01-03, Point(3 1)@2000-01-04,
Point(4 3)@2000-01-05, Point(5 0)@2000-01-06, Point(6 4)@2000-01-07]', 4, 2 / 1e5)));
-- "LINESTRING(0 4,1 1,5 0,6 4)"
SELECT ST_AsText(trajectory(simplify(tgeompoint '[Point(0 4)@2000-01-01,
Point(1 1)@2000-01-02, Point(2 3)@2000-01-03, Point(3 1)@2000-01-04,
Point(4 3)@2000-01-05, Point(5 0)@2000-01-06, Point(6 4)@2000-01-07]', 4, 3 / 1e5)));
-- "LINESTRING(0 4,6 4)"
				</programlisting>
				<para>Un uso típico de la función <varname>simplify</varname> es reducir el tamaño de un conjunto de datos, en particular con fines de visualización.</para>
			</listitem>

			<listitem id="geoMeasure">
				<indexterm><primary><varname>geoMeasure</varname></primary></indexterm>
				<para>Construir una geometría/geografía con medida M a partir de un punto temporal y un número flotante temporal &Z_support; &geography_support;</para>
				<para><varname>geoMeasure(tpoint,tfloat,segmentize=false):geo</varname></para>
				<para>El último argumento <varname>segmentize</varname> establece si el valor resultado ya sea es un <varname>Linestring M</varname> o un <varname>MultiLinestring M</varname> donde cada componente es un segmento de dos puntos.</para>

				<programlisting>
SELECT st_astext(geoMeasure(tgeompoint '{Point(1 1 1)@2000-01-01,
Point(2 2 2)@2000-01-02}', '{5@2000-01-01, 5@2000-01-02}'));
-- "MULTIPOINT ZM (1 1 1 5,2 2 2 5)"
SELECT st_astext(geoMeasure(tgeogpoint '{[Point(1 1)@2000-01-01, Point(2 2)@2000-01-02],
[Point(1 1)@2000-01-03, Point(1 1)@2000-01-04]}',
'{[5@2000-01-01, 5@2000-01-02],[7@2000-01-03, 7@2000-01-04]}'));
-- "GEOMETRYCOLLECTION M (LINESTRING M (1 1 5,2 2 5),POINT M (1 1 7))"
SELECT st_astext(geoMeasure(tgeompoint '[Point(1 1)@2000-01-01,
Point(2 2)@2000-01-02, Point(1 1)@2000-01-03]', '[5@2000-01-01, 7@2000-01-02, 5@2000-01-03]', true));
-- "MULTILINESTRING M ((1 1 5,2 2 5),(2 2 7,1 1 7))"
				</programlisting>
				<para>Una visualización típica de los datos de movilidad es mostrar en un mapa la trayectoria del objeto móvil utilizando diferentes colores según la velocidad. <xref linkend="figspeed" /> muestra el resultado de la consulta a continuación usando una rampa de color en QGIS.</para>
				<programlisting>WITH Temp(t) AS (
SELECT tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-05,
  Point(2 0)@2012-01-08, Point(3 1)@2012-01-10, Point(4 0)@2012-01-11]'
)
SELECT ST_AsText(geoMeasure(t, round(speed(t) * 3600 * 24, 2), true))
FROM Temp;
-- "MULTILINESTRING M ((0 0 0.35,1 1 0.35),(1 1 0.47,2 0 0.47),(2 0 0.71,3 1 0.71),
(3 1 1.41,4 0 1.41))"
				</programlisting>
				<para>La siguiente expresión se usa en QGIS para lograr esto. La función <varname>scale_linear</varname> transforma el valor M de cada segmento componente al rango [0, 1]. Este valor luego se pasa a la función <varname>ramp_color</varname>.</para>
				<programlisting>ramp_color(
'RdYlBu',
scale_linear(
  m(start_point(geometry_n($geometry,@geometry_part_num))),
  0, 2, 0, 1)
)
				</programlisting>
				<figure id="figspeed" float="start"><title>Visualización de la velocidad de un objeto móvil usando una rampa de color en QGIS.</title>
					<mediaobject>
						<imageobject><imagedata scale='30' fileref='images/speed.png'/></imageobject>
					</mediaobject>
				</figure>
			</listitem>

		</itemizedlist>
	</sect1>

	<sect1>
		<title>Funciones de restricción</title>
		<para>Estas funciones restringen el valor temporal con respecto a una extensión de valores o de tiempo.</para>

		<itemizedlist>
			<listitem id="atValue">
				<indexterm><primary><varname>atValue</varname></primary></indexterm>
				<para>Restringir a un valor</para>
				<para><varname>atValue(ttype,base):ttype</varname></para>
				<programlisting>
SELECT atValue(tint '[1@2012-01-01, 1@2012-01-15)', 1);
-- "[1@2012-01-01, 1@2012-01-15)"
SELECT asText(atValue(tgeompoint '[Point(0 0 0)@2012-01-01, Point(2 2 2)@2012-01-03)',
'Point(1 1 1)'));
-- "{[POINT Z (1 1 1)@2012-01-02]}"
				</programlisting>
			</listitem>

			<listitem id="atValues">
				<indexterm><primary><varname>atValues</varname></primary></indexterm>
				<para>Restringir a una matriz de valores</para>
				<para><varname>atValues(ttype,base[]):ttype</varname></para>
				<programlisting>
SELECT atValues(tfloat '[1@2012-01-01, 4@2012-01-4)', ARRAY[1, 3, 5]);
-- "{[1@2012-01-01], [3@2012-01-03]}"
SELECT asText(atValues(tgeompoint '[Point(0 0)@2012-01-01, Point(2 2)@2012-01-03)',
ARRAY[geometry 'Point(0 0)', 'Point(1 1)']));
-- "{[POINT(0 0)@2012-01-01 00:00:00+00], [POINT(1 1)@2012-01-02 00:00:00+00]}"
				</programlisting>
			</listitem>

			<listitem id="atRange">
				<indexterm><primary><varname>atRange</varname></primary></indexterm>
				<para>Restringir a un rango de valores</para>
				<para><varname>atRange(tnumber,numrange):ttype</varname></para>
				<programlisting>
SELECT atRange(tfloat '[1@2012-01-01, 4@2012-01-4)', floatrange '[1,3]');
-- "[1@2012-01-01, 3@2012-01-03]"
				</programlisting>
			</listitem>

			<listitem id="atRanges">
				<indexterm><primary><varname>atRanges</varname></primary></indexterm>
				<para>Restringir a una matriz de rangos de valores</para>
				<para><varname>atRanges(tnumber,numrange[]):ttype</varname></para>
				<programlisting>
SELECT atRanges(tfloat '[1@2012-01-01, 5@2012-01-05)',
ARRAY[floatrange '[1,2]', '[3,4]']);
-- "{[1@2012-01-01, 2@2012-01-02],[3@2012-01-03, 4@2012-01-04]}"
				</programlisting>
			</listitem>

			<listitem id="atMin">
				<indexterm><primary><varname>atMin</varname></primary></indexterm>
				<para>Restringir al valor mínimo</para>
				<para><varname>atMin(torder):torder</varname></para>
				<para>La función devuelve nulo si el valor mínimo sólo ocurre en límites exclusivos.</para>
				<programlisting>
SELECT atMin(tint '{1@2012-01-01, 2@2012-01-03, 1@2012-01-05}');
-- "{1@2012-01-01, 1@2012-01-05}"
SELECT atMin(tint '(1@2012-01-01, 3@2012-01-03]');
-- "{(1@2012-01-01, 1@2012-01-03)}"
SELECT atMin(tfloat '(1@2012-01-01, 3@2012-01-03]');
-- NULL
SELECT atMin(ttext '{(AA@2012-01-01, AA@2012-01-03), (BB@2012-01-03, AA@2012-01-05]}');
-- "{(AA@2012-01-01, AA@2012-01-03), [AA@2012-01-05]}"
				</programlisting>
			</listitem>

			<listitem id="atMax">
				<indexterm><primary><varname>atMax</varname></primary></indexterm>
				<para>Restringir al valor máximo</para>
				<para><varname>atMax(torder):torder</varname></para>
				<para>La función devuelve nulo si el valor máximo sólo ocurre en límites exclusivos.</para>
				<programlisting>
SELECT atMax(tint '{1@2012-01-01, 2@2012-01-03, 3@2012-01-05}');
-- "{3@2012-01-05}"
SELECT atMax(tfloat '(1@2012-01-01, 3@2012-01-03)');
-- NULL
SELECT atMax(tfloat '{(2@2012-01-01, 1@2012-01-03), [2@2012-01-03, 2@2012-01-05)}');
-- "{[2@2012-01-03, 2@2012-01-05]}"
SELECT atMax(ttext '{(AA@2012-01-01, AA@2012-01-03), (BB@2012-01-03, AA@2012-01-05]}');
-- "{("BB"@2012-01-03, "BB"@2012-01-05)}"
				</programlisting>
			</listitem>

			<listitem id="atGeometry">
				<indexterm><primary><varname>atGeometry</varname></primary></indexterm>
				<para>Restringir a una geometría</para>
				<para><varname>atGeometry(tgeompoint,geometry):tgeompoint</varname></para>
				<para>Tenga en cuenta que está permitido mezclar geometrías 2D/3D, pero el cálculo sólo se realiza en 2D.</para>
				<programlisting>
SELECT asText(atGeometry(tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-04)',
  geometry 'Polygon((1 1,1 2,2 2,2 1,1 1))'));
-- "{"[POINT(1 1)@2012-01-02, POINT(2 2)@2012-01-03]"}"
SELECT astext(atGeometry(tgeompoint '[Point(0 0 0)@2000-01-01, Point(4 4 4)@2000-01-05]',
  geometry 'Polygon((1 1,1 2,2 2,2 1,1 1))'));
-- "{[POINT Z (1 1 1)@2000-01-02, POINT Z (2 2 2)@2000-01-03]}"
				</programlisting>
			</listitem>

			<listitem id="atTimestamp">
				<indexterm><primary><varname>atTimestamp</varname></primary></indexterm>
				<para>Restringir a una marca de tiempo</para>
				<para><varname>atTimestamp(ttype,timestamptz):ttypeinst</varname></para>
				<programlisting>
SELECT atTimestamp(tfloat '[1@2012-01-01, 5@2012-01-05)', '2012-01-02');
-- "2@2012-01-02"
				</programlisting>
			</listitem>

			<listitem id="atTimestampSet">
				<indexterm><primary><varname>atTimestampSet</varname></primary></indexterm>
				<para>Restringir a un conjunto de marcas de tiempo</para>
				<para><varname>atTimestampSet(ttype,timestampset):{ttypeinst,ttypei}</varname></para>
				<programlisting>
SELECT atTimestampSet(tint '[1@2012-01-01, 1@2012-01-15)',
timestampset '{2012-01-01, 2012-01-03}');
-- "{1@2012-01-01, 1@2012-01-03}"
				</programlisting>
			</listitem>

			<listitem id="atPeriod">
				<indexterm><primary><varname>atPeriod</varname></primary></indexterm>
				<para>Restringir a un período</para>
				<para><varname>atPeriod(ttype,period):ttype</varname></para>
				<programlisting>
SELECT atPeriod(tfloat '{[1@2012-01-01, 3@2012-01-03), [3@2012-01-04, 1@2012-01-06)}',
'[2012-01-02,2012-01-05)');
-- "{[2@2012-01-02, 3@2012-01-03), [3@2012-01-04, 2@2012-01-05)}"
				</programlisting>
			</listitem>

			<listitem id="atPeriodSet">
				<indexterm><primary><varname>atPeriodSet</varname></primary></indexterm>
				<para>Restringir a un conjunto de períodos</para>
				<para><varname>atPeriodSet(ttype,periodset):ttype</varname></para>
				<programlisting>
SELECT atPeriodSet(tint '[1@2012-01-01, 1@2012-01-15)',
periodset '{[2012-01-01, 2012-01-03), [2012-01-04, 2012-01-05)}');
-- "{[1@2012-01-01, 1@2012-01-03),[1@2012-01-04, 1@2012-01-05)}"
				</programlisting>
			</listitem>

			<listitem id="atTbox">
				<indexterm><primary><varname>atTbox</varname></primary></indexterm>
				<para>Restringir a un <varname>tbox</varname></para>
				<para><varname>atTbox(tnumber,tbox):tnumber</varname></para>
				<programlisting>
SELECT atTbox(tfloat '[0@2012-01-01, 3@2012-01-04)',
tbox 'TBOX((0, 2012-01-02), (2, 2012-01-04))');
-- "{[1@2012-01-02, 2@2012-01-03]}"
				</programlisting>
			</listitem>

			<listitem id="atStbox">
				<indexterm><primary><varname>atStbox</varname></primary></indexterm>
				<para>Restringir a un <varname>stbox</varname></para>
				<para><varname>atStbox(tgeompoint,stbox):tgeompoint</varname></para>
				<programlisting>
SELECT asText(atStbox(tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-04)',
stbox 'STBOX T((0, 0, 2012-01-02), (2, 2, 2012-01-04))'));
-- "{[POINT(1 1)@2012-01-02, POINT(2 2)@2012-01-03]}"
				</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1>
		<title>Funciones de diferencia</title>
		<para>Estas funciones restringen el valor temporal con respecto al complemento de una extensión de valores o de tiempo.</para>
		<itemizedlist>
			<listitem id="minusValue">
				<indexterm><primary><varname>minusValue</varname></primary></indexterm>
				<para>Diferencia con un valor</para>
				<para><varname>minusValue(ttype,base):ttype</varname></para>
				<programlisting>
SELECT minusValue(tint '[1@2012-01-01, 2@2012-01-02, 2@2012-01-03)', 1);
-- "{[2@2012-01-02, 2@2012-01-03)}"
SELECT asText(minusValue(tgeompoint '[Point(0 0 0)@2012-01-01, Point(2 2 2)@2012-01-03)',
'Point(1 1 1)'));
-- "{[POINT Z (0 0 0)@2012-01-01, POINT Z (1 1 1)@2012-01-02),
(POINT Z (1 1 1)@2012-01-02, POINT Z (2 2 2)@2012-01-03)}"
				</programlisting>
			</listitem>

			<listitem id="minusValues">
				<indexterm><primary><varname>minusValues</varname></primary></indexterm>
				<para>Diferencia con una matriz de valores</para>
				<para><varname>minusValues(ttype,base[]):ttype</varname></para>
				<programlisting>
SELECT minusValues(tfloat '[1@2012-01-01, 4@2012-01-4)', ARRAY[2, 3]);
-- "{[1@2012-01-01, 2@2012-01-02), (2@2012-01-02, 3@2012-01-03),
(3@2012-01-03, 4@2012-01-04)}"
SELECT asText(minusValues(tgeompoint '[Point(0 0 0)@2012-01-01, Point(3 3 3)@2012-01-04)',
ARRAY[geometry 'Point(1 1 1)', 'Point(2 2 2)']));
-- "{[POINT Z (0 0 0)@2012-01-01, POINT Z (1 1 1)@2012-01-02),
(POINT Z (1 1 1)@2012-01-02, POINT Z (2 2 2)@2012-01-03),
(POINT Z (2 2 2)@2012-01-03, POINT Z (3 3 3)@2012-01-04)}"
				</programlisting>
			</listitem>

			<listitem id="minusRange">
				<indexterm><primary><varname>minusRange</varname></primary></indexterm>
				<para>Diferencia con un rango de valores</para>
				<para><varname>minusRange(tnumber,numrange):ttype</varname></para>
				<programlisting>
SELECT minusRange(tfloat '[1@2012-01-01, 4@2012-01-4)', floatrange '[2,3]');
-- "{[1@2012-01-01, 2@2012-01-02), (3@2012-01-03, 4@2012-01-04)}"
				</programlisting>
			</listitem>

			<listitem id="minusRanges">
				<indexterm><primary><varname>minusRanges</varname></primary></indexterm>
				<para>Diferencia con una matriz de rangos de valores</para>
				<para><varname>minusRanges(tnumber,numrange[]):ttype</varname></para>
				<programlisting>
SELECT minusRanges(tfloat '[1@2012-01-01, 5@2012-01-05)',
ARRAY[floatrange '[1,2]', '[3,4]']);
-- "{(2@2012-01-02, 3@2012-01-03), (4@2012-01-04, 5@2012-01-05)}"
				</programlisting>
			</listitem>

			<listitem id="minusMin">
				<indexterm><primary><varname>minusMin</varname></primary></indexterm>
				<para>Diferencia con el valor mínimo</para>
				<para><varname>minusMin(torder):torder</varname></para>
				<programlisting>
SELECT minusMin(tint '{1@2012-01-01, 2@2012-01-03, 1@2012-01-05}');
-- "{2@2012-01-03}"
SELECT minusMin(tfloat '[1@2012-01-01, 3@2012-01-03]');
-- "{(1@2012-01-01, 3@2012-01-03]}"
SELECT minusMin(tfloat '(1@2012-01-01, 3@2012-01-03)');
-- "{(1@2012-01-01, 3@2012-01-03)}"
SELECT minusMin(tint '{[1@2012-01-01, 1@2012-01-03), (1@2012-01-03, 1@2012-01-05)}');
-- NULL
				</programlisting>
			</listitem>

			<listitem id="minusMax">
				<indexterm><primary><varname>minusMax</varname></primary></indexterm>
				<para>Diferencia con el valor máximo</para>
				<para><varname>minusMax(torder):torder</varname></para>
				<programlisting>
SELECT minusMax(tint '{1@2012-01-01, 2@2012-01-03, 3@2012-01-05}');
-- "{1@2012-01-01, 2@2012-01-03}"
SELECT minusMax(tfloat '[1@2012-01-01, 3@2012-01-03]');
-- "{[1@2012-01-01, 3@2012-01-03)}"
SELECT minusMax(tfloat '(1@2012-01-01, 3@2012-01-03)');
-- "{(1@2012-01-01, 3@2012-01-03)}"
SELECT minusMax(tfloat '{[2@2012-01-01, 1@2012-01-03), [2@2012-01-03, 2@2012-01-05)}');
-- "{(2@2012-01-01, 1@2012-01-03)}"
SELECT minusMax(tfloat '{[1@2012-01-01, 3@2012-01-03), (3@2012-01-03, 1@2012-01-05)}');
-- "{[1@2012-01-01, 3@2012-01-03), (3@2012-01-03, 1@2012-01-05)}"
				</programlisting>
			</listitem>

			<listitem id="minusGeometry">
				<indexterm><primary><varname>minusGeometry</varname></primary></indexterm>
				<para>Diferencia con una geometría</para>
				<para><varname>minusGeometry(tgeompoint,geometry):tgeompoint</varname></para>
				<para>Tenga en cuenta que está permitido mezclar geometrías 2D/3D, pero el cálculo sólo se realiza en 2D.</para>
				<programlisting>
SELECT asText(minusGeometry(tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-04)',
  geometry 'Polygon((1 1,1 2,2 2,2 1,1 1))'));
-- "{[POINT(0 0)@2012-01-01, POINT(1 1)@2012-01-02), (POINT(2 2)@2012-01-03,
  POINT(3 3)@2012-01-04)}"
SELECT astext(minusGeometry(tgeompoint '[Point(0 0 0)@2000-01-01,
  Point(4 4 4)@2000-01-05]', geometry 'Polygon((1 1,1 2,2 2,2 1,1 1))'));
-- "{[POINT Z (0 0 0)@2000-01-01, POINT Z (1 1 1)@2000-01-02),
  (POINT Z (2 2 2)@2000-01-03, POINT Z (4 4 4)@2000-01-05]}"
				</programlisting>
			</listitem>

			<listitem id="minusTimestamp">
				<indexterm><primary><varname>minusTimestamp</varname></primary></indexterm>
				<para>Diferencia con una marca de tiempo</para>
				<para><varname>minusTimestamp(ttype,timestamptz):ttype</varname></para>
				<programlisting>
SELECT minusTimestamp(tfloat '[1@2012-01-01, 5@2012-01-05)', '2012-01-02');
-- "{[1@2012-01-01, 2@2012-01-02), (2@2012-01-02, 5@2012-01-05)}"
				</programlisting>
			</listitem>

			<listitem id="minusTimestampSet">
				<indexterm><primary><varname>minusTimestampSet</varname></primary></indexterm>
				<para>Diferencia con un conjunto de marcas de tiempo</para>
				<para><varname>minusTimestampSet(ttype,timestampset):ttype</varname></para>
				<programlisting>
SELECT minusTimestampSet(tint '[1@2012-01-01, 1@2012-01-15)',
timestampset '{2012-01-02, 2012-01-03}');
-- "{[1@2012-01-01, 1@2012-01-02), (1@2012-01-02, 1@2012-01-03),
(1@2012-01-03, 1@2012-01-15)}"
				</programlisting>
			</listitem>

			<listitem id="minusPeriod">
				<indexterm><primary><varname>minusPeriod</varname></primary></indexterm>
				<para>Diferencia con un período</para>
				<para><varname>minusPeriod(ttype,period):ttype</varname></para>
				<programlisting>
SELECT minusPeriod(tfloat '{[1@2012-01-01, 3@2012-01-03), [3@2012-01-04, 1@2012-01-06)}',
'[2012-01-02,2012-01-05)');
-- "{[1@2012-01-01, 2@2012-01-02), [2@2012-01-05, 1@2012-01-06)}"
				</programlisting>
			</listitem>

			<listitem id="minusPeriodSet">
				<indexterm><primary><varname>minusPeriodSet</varname></primary></indexterm>
				<para>Diferencia con un conjunto de períodos</para>
				<para><varname>minusPeriodSet(ttype,periodset):ttype</varname></para>
				<programlisting>
SELECT minusPeriodSet(tint '[1@2012-01-01, 1@2012-01-15)',
periodset '{[2012-01-02, 2012-01-03), [2012-01-04, 2012-01-05)}');
-- "{[1@2012-01-01, 1@2012-01-02), [1@2012-01-03, 1@2012-01-04),
[1@2012-01-05, 1@2012-01-15)}"
				</programlisting>
			</listitem>

			<listitem id="minusTbox">
				<indexterm><primary><varname>minusTbox</varname></primary></indexterm>
				<para>Diferencia con un <varname>tbox</varname></para>
				<para><varname>minusTbox(tnumber,tbox):tnumber</varname></para>
				<programlisting>
SELECT minusTbox(tfloat '[0@2012-01-01, 3@2012-01-04)',
tbox 'TBOX((0, 2012-01-02), (2, 2012-01-04))');
-- "{[0@2012-01-01, 1@2012-01-02), (2@2012-01-03, 3@2012-01-04)}"
				</programlisting>
			</listitem>

			<listitem id="minusStbox">
				<indexterm><primary><varname>minusStbox</varname></primary></indexterm>
				<para>Diferencia con un <varname>stbox</varname></para>
				<para><varname>minusStbox(tgeompoint,stbox):tgeompoint</varname></para>
				<programlisting>
SELECT asText(minusStbox(tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-04)',
stbox 'STBOX T((0, 0, 2012-01-02), (2, 2, 2012-01-04))'));
-- "{[POINT(0 0)@2012-01-01, POINT(1 1)@2012-01-02),
(POINT(2 2)@2012-01-03, POINT(3 3)@2012-01-04)}"
				</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 id="operators_temporal_types">
		<title>Operadores de comparación</title>

		<para>Los operadores de comparación tradicionales (<varname>=</varname>, <varname>&lt;</varname>, etc.) requieren que los operandos izquierdo y derecho sean del mismo tipo base. Excepto la igualdad y la no igualdad, los otros operadores de comparación no son útiles en el mundo real pero permiten que los índices de árbol B se construyan sobre tipos temporales. Estos operadores comparan los períodos delimitadores (ver <xref linkend="time_comp_operators" />), después los cuadros delimitadores (ver <xref linkend="comparison_box_types" />) y si son iguales, entonces la comparación depende del subtipo. Para los valores de instante, primero comparan las marcas de tiempo y, si son iguales, comparan los valores. Para los valores de secuencia y conjunto de instantes, comparan los primeros N instantes, donde N es el mínimo del número de instantes que componen ambos valores. Finalmente, para los valores de conjuntos de secuencias, comparan los primeros N valores de secuencia, donde N es el mínimo del número de secuencias que componen ambos valores.</para>

		<para>Los operadores de igualdad y no igualdad consideran la representación equivalente para diferentes subtipos como se muestra a continuación.
				<programlisting>
SELECT tint '1@2001-01-01' = tint '{1@2001-01-01}';
-- true
SELECT tfloat '1.5@2001-01-01' = tfloat '[1.5@2001-01-01]';
-- true
SELECT ttext 'AAA@2001-01-01' = ttext '{[AAA@2001-01-01]}';
-- true
SELECT tgeompoint '{Point(1 1)@2001-01-01, Point(2 2)@2001-01-02}' =
tgeompoint '{[Point(1 1)@2001-01-01], [Point(2 2)@2001-01-02]}';
-- true
SELECT tgeogpoint '[Point(1 1 1)@2001-01-01, Point(2 2 2)@2001-01-02]' =
tgeogpoint '{[Point(1 1 1)@2001-01-01], [Point(2 2 2)@2001-01-02]}';
-- true
				</programlisting>
		</para>

		<itemizedlist>
			<listitem id="ttype_eq">
				<indexterm><primary><varname>=</varname></primary></indexterm>
				<para>¿Son iguales los valores temporales?</para>
				<para><varname>ttype = ttype:boolean</varname></para>
				<programlisting>
SELECT tint '[1@2012-01-01, 1@2012-01-04)' = tint '[2@2012-01-03, 2@2012-01-05)';
-- false
				</programlisting>
			</listitem>

			<listitem id="ttype_ne">
				<indexterm><primary><varname>&lt;&gt;</varname></primary></indexterm>
				<para>¿Son diferentes los valores temporales?</para>
				<para><varname>ttype &lt;&gt; ttype:boolean</varname></para>
				<programlisting>
SELECT tint '[1@2012-01-01, 1@2012-01-04)' &lt;&gt; tint '[2@2012-01-03, 2@2012-01-05)'
-- true
				</programlisting>
			</listitem>

			<listitem id="ttype_lt">
				<indexterm><primary><varname>&lt;</varname></primary></indexterm>
				<para>¿Es el primer valor temporal menor que el segundo?</para>
				<para><varname>ttype &lt; ttype:boolean</varname></para>
				<programlisting>
SELECT tint '[1@2012-01-01, 1@2012-01-04)' &lt; tint '[2@2012-01-03, 2@2012-01-05)'
-- true
				</programlisting>
			</listitem>

			<listitem id="ttype_gt">
				<indexterm><primary><varname>&gt;</varname></primary></indexterm>
				<para>¿Es el primer valor temporal mayor que el segundo?</para>
				<para><varname>ttype &gt; ttype:boolean</varname></para>
				<programlisting>
SELECT tint '[1@2012-01-01, 1@2012-01-04)' &gt; tint '[2@2012-01-03, 2@2012-01-05)'
-- false
				</programlisting>
			</listitem>

			<listitem id="ttype_le">
				<indexterm><primary><varname>&lt;=</varname></primary></indexterm>
				<para>¿Es el primer valor temporal menor o igual que el segundo?</para>
				<para><varname>ttype &lt;= ttype:boolean</varname></para>
				<programlisting>
SELECT tint '[1@2012-01-01, 1@2012-01-04)' &lt;= tint '[2@2012-01-03, 2@2012-01-05)'
-- true
				</programlisting>
			</listitem>

			<listitem id="ttype_ge">
				<indexterm><primary><varname>&gt;=</varname></primary></indexterm>
				<para>¿Es el primer valor temporal mayor o igual que el segundo?</para>
				<para><varname>ttype &gt;= ttype:boolean</varname></para>
				<programlisting>
SELECT tint '[1@2012-01-01, 1@2012-01-04)' &gt;= tint '[2@2012-01-03, 2@2012-01-05)'
-- false
				</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1>
		<title>Operadores de comparación alguna vez y siempre</title>
		<para>Una posible generalización de los operadores de comparación tradicionales (<varname>=</varname>, <varname>&lt;&gt;</varname>, <varname>&lt;</varname>, <varname>&lt;=</varname>, etc.) a tipos temporales consiste en determinar si la comparación es alguna vez o siempre verdadera. En este caso, el resultado es un valor booleano. MobilityDB proporciona operadores para probar si la comparación de un valor temporal y un valor del tipo base es alguna vez o siempre verdadera. Estos operadores se indican anteponiendo los operadores de comparación tradicionales con, respectivamente, <varname>?</varname> (alguna vez) y <varname>%</varname> (siempre). Algunos ejemplos son <varname>?=</varname>, <varname>%&lt;&gt;</varname> o <varname>?&lt;=</varname>. La igualdad y la no igualdad alguna vez/siempre  están disponibles para todos los tipos temporales, mientras que las desigualdades alguna vez/siempre sólo están disponibles para los tipos temporales cuyo tipo base tiene un orden total definido, es decir, <varname>tint</varname>, <varname>tfloat</varname> o <varname>ttext</varname>. Las comparaciones alguna vez y siempre son operadores inversos: por ejemplo,<varname>?=</varname> es el inverso de <varname>%&lt;&gt;</varname> y <varname>?&gt;</varname> es el inverso de <varname>%&lt;=</varname>.</para>
		<itemizedlist>
			<listitem id="ttype_eveq">
				<indexterm><primary><varname>?=</varname></primary></indexterm>
				<para>¿Es el valor temporal alguna vez igual al valor?</para>
				<para><varname>ttype ?= base:boolean</varname></para>
				<para>La función no tiene en cuenta si los límites son inclusivos o no.</para>
				<programlisting>
SELECT tfloat '[1@2012-01-01, 3@2012-01-04)' ?= 2;
-- true
SELECT tfloat '[1@2012-01-01, 3@2012-01-04)' ?= 3;
-- true
SELECT tgeompoint '[Point(0 0)@2012-01-01, Point(2 2)@2012-01-04)' ?=
geometry 'Point(1 1)';
-- true
				</programlisting>
			</listitem>

			<listitem id="ttype_evne">
				<indexterm><primary><varname>?&lt;&gt;</varname></primary></indexterm>
				<para>¿Es el valor temporal alguna vez diferente del valor?</para>
				<para><varname>ttype ?&lt;&gt; base:boolean</varname></para>
				<programlisting>
SELECT tfloat '[1@2012-01-01, 3@2012-01-04)' ?&lt;&gt; 2;
-- false
SELECT tfloat '[2@2012-01-01, 2@2012-01-04)' ?&lt;&gt; 2;
-- true
SELECT tgeompoint '[Point(1 1)@2012-01-01, Point(1 1)@2012-01-04)' ?&lt;&gt;
geometry 'Point(1 1)';
-- true
				</programlisting>
			</listitem>

			<listitem id="ttype_evlt">
				<indexterm><primary><varname>?&lt;</varname></primary></indexterm>
				<para>¿Es el valor temporal alguna vez menor que el valor?</para>
				<para><varname>tnumber ?&lt; number:boolean</varname></para>
				<programlisting>
SELECT tfloat '[1@2012-01-01, 4@2012-01-04)' ?&lt; 2;
-- "{[t@2012-01-01, f@2012-01-02, f@2012-01-04)}"
SELECT tint '[2@2012-01-01, 2@2012-01-05)' ?&lt; tfloat '[1@2012-01-03, 3@2012-01-05)';
-- "{[f@2012-01-03, f@2012-01-04], (t@2012-01-04, t@2012-01-05)}"
				</programlisting>
			</listitem>

			<listitem id="ttype_evgt">
				<indexterm><primary><varname>?&gt;</varname></primary></indexterm>
				<para>¿Es el valor temporal alguna vez mayor que el valor?</para>
				<para><varname>tnumber ?&gt; number:boolean</varname></para>
				<programlisting>
SELECT tint '[1@2012-01-03, 1@2012-01-05)' ?&gt; 1;
-- "[f@2012-01-03, f@2012-01-05)"
				</programlisting>
			</listitem>

			<listitem id="ttype_evle">
				<indexterm><primary><varname>?&lt;=</varname></primary></indexterm>
				<para>¿Es el valor temporal alguna vez menor o igual que el valor?</para>
				<para><varname>tnumber ?&lt;= number:boolean</varname></para>
				<programlisting>
SELECT tint '[1@2012-01-01, 1@2012-01-05)' ?&lt;= tfloat '{2@2012-01-03, 3@2012-01-04}';
-- "{t@2012-01-03, t@2012-01-04}"
				</programlisting>
			</listitem>

			<listitem id="ttype_evge">
				<indexterm><primary><varname>?&gt;=</varname></primary></indexterm>
				<para>¿Es el valor temporal alguna vez mayor o igual que el valor?</para>
				<para><varname>tnumber ?&gt;= number:boolean</varname></para>
				<programlisting>
SELECT 'AAA'::text ?&gt; ttext '{[AAA@2012-01-01, AAA@2012-01-03),
[BBB@2012-01-04, BBB@2012-01-05)}';
-- "{[f@2012-01-01, f@2012-01-03), [t@2012-01-04, t@2012-01-05)}"
				</programlisting>
			</listitem>

			<listitem id="ttype_aleq">
				<indexterm><primary><varname>%=</varname></primary></indexterm>
				<para>¿Es el valor temporal siempre igual que el valor?</para>
				<para><varname>ttype %= base:boolean</varname></para>
				<para>La función no tiene en cuenta si los límites son inclusivos o no.</para>
				<programlisting>
SELECT tfloat '[1@2012-01-01, 3@2012-01-04)' %= 2;
-- true
SELECT tfloat '[1@2012-01-01, 3@2012-01-04)' %= 3;
-- true
SELECT tgeompoint '[Point(0 0)@2012-01-01, Point(2 2)@2012-01-04)' %=
geometry 'Point(1 1)';
-- true
				</programlisting>
			</listitem>

			<listitem id="ttype_alne">
				<indexterm><primary><varname>%&lt;&gt;</varname></primary></indexterm>
				<para>¿Es el valor temporal siempre diferente que el valor?</para>
				<para><varname>ttype %&lt;&gt; base:boolean</varname></para>
				<programlisting>
SELECT tfloat '[1@2012-01-01, 3@2012-01-04)' %&lt;&gt; 2;
-- false
SELECT tfloat '[2@2012-01-01, 2@2012-01-04)' %&lt;&gt; 2;
-- true
SELECT tgeompoint '[Point(1 1)@2012-01-01, Point(1 1)@2012-01-04)' %&lt;&gt;
geometry 'Point(1 1)';
-- true
				</programlisting>
			</listitem>

			<listitem id="ttype_allt">
				<indexterm><primary><varname>%&lt;</varname></primary></indexterm>
				<para>¿Es el valor temporal siempre menor que el valor?</para>
				<para><varname>tnumber %&lt; number:boolean</varname></para>
				<programlisting>
SELECT tfloat '[1@2012-01-01, 4@2012-01-04)' %&lt; 2;
-- "{[t@2012-01-01, f@2012-01-02, f@2012-01-04)}"
SELECT tint '[2@2012-01-01, 2@2012-01-05)' %&lt; tfloat '[1@2012-01-03, 3@2012-01-05)';
-- "{[f@2012-01-03, f@2012-01-04], (t@2012-01-04, t@2012-01-05)}"
				</programlisting>
			</listitem>

			<listitem id="ttype_algt">
				<indexterm><primary><varname>%&gt;</varname></primary></indexterm>
				<para>¿Es el valor temporal siempre mayor que el valor?</para>
				<para><varname>tnumber %&gt; number:boolean</varname></para>
				<programlisting>
SELECT tint '[1@2012-01-03, 1@2012-01-05)' %&gt; 1;
-- "[f@2012-01-03, f@2012-01-05)"
				</programlisting>
			</listitem>

			<listitem id="ttype_alle">
				<indexterm><primary><varname>%&lt;=</varname></primary></indexterm>
				<para>¿Es el valor temporal siempre menor o igual que el valor?</para>
				<para><varname>tnumber %&lt;= number:boolean</varname></para>
				<programlisting>
SELECT tint '[1@2012-01-01, 1@2012-01-05)' %&lt;= tfloat '{2@2012-01-03, 3@2012-01-04}';
-- "{t@2012-01-03, t@2012-01-04}"
				</programlisting>
			</listitem>

			<listitem id="ttype_alge">
				<indexterm><primary><varname>%&gt;=</varname></primary></indexterm>
				<para>¿Es el valor temporal siempre mayor o igual que el valor?</para>
				<para><varname>tnumber %&gt;= number:boolean</varname></para>
				<programlisting>
SELECT 'AAA'::text %&gt; ttext '{[AAA@2012-01-01, AAA@2012-01-03),
[BBB@2012-01-04, BBB@2012-01-05)}';
-- "{[f@2012-01-01, f@2012-01-03), [t@2012-01-04, t@2012-01-05)}"
				</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1>
		<title>Operadores de comparación temporal</title>
		<para>Otra posible generalización de los operadores de comparación tradicionales (<varname>=</varname>, <varname>&lt;&gt;</varname>, <varname>&lt;</varname>, <varname>&lt;=</varname>, etc.) a tipos temporales consiste en determinar si la comparación es verdadera o falsa en cada instante. En este caso, el resultado es un booleano temporal. Los operadores de comparación temporal se indican anteponiendo los operadores de comparación tradicionales con <varname>#</varname>. Algunos ejemplos son <varname>#=</varname> o <varname>#&lt;=</varname>. La igualdad y no igualdad temporal están disponibles para todos los tipos temporales, mientras que las desigualdades temporales sólo están disponibles para los tipos temporales cuyo tipo base tiene un orden total definido, es decir, <varname>tint</varname>, <varname>tfloat</varname> o <varname>ttext</varname>.</para>

		<itemizedlist>
			<listitem id="ttype_teq">
				<indexterm><primary><varname>#=</varname></primary></indexterm>
				<para>Igual temporal</para>
				<para><varname>{base,ttype} #= {base,ttype}:tbool</varname></para>
				<programlisting>
SELECT tfloat '[1@2012-01-01, 2@2012-01-04)' #= 3;
-- "{[f@2012-01-01, f@2012-01-04)}"
SELECT tfloat '[1@2012-01-01, 4@2012-01-04)' #= tint '[1@2012-01-01, 1@2012-01-04)';
-- "{[t@2012-01-01], (f@2012-01-01, f@2012-01-04)}"
SELECT tfloat '[1@2012-01-01, 4@2012-01-04)' #= tfloat '[4@2012-01-02, 1@2012-01-05)';
-- "{[f@2012-01-02, t@2012-01-03], (f@2012-01-03, f@2012-01-04)}"
SELECT tgeompoint '[Point(0 0)@2012-01-01, Point(2 2)@2012-01-03)' #=
geometry 'Point(1 1)';
-- "{[f@2012-01-01, t@2012-01-02], (f@2012-01-02, f@2012-01-03)}"
SELECT tgeompoint '[Point(0 0)@2012-01-01, Point(2 2)@2012-01-03)' #=
tgeompoint '[Point(0 2)@2012-01-01, Point(2 0)@2012-01-03)';
-- "{[f@2012-01-01], (t@2012-01-01, t@2012-01-03)}"
				</programlisting>
			</listitem>

			<listitem id="ttype_tne">
				<indexterm><primary><varname>#&lt;&gt;</varname></primary></indexterm>
				<para>Diferente temporal</para>
				<para><varname>{base,ttype} #&lt;&gt; {base,ttype}:tbool</varname></para>
				<programlisting>
SELECT tfloat '[1@2012-01-01, 4@2012-01-04)' #&lt;&gt; 2;
-- "{[t@2012-01-01, f@2012-01-02], (t@2012-01-02, 2012-01-04)}"
SELECT tfloat '[1@2012-01-01, 4@2012-01-04)' #&lt;&gt; tint '[2@2012-01-02, 2@2012-01-05)';
-- "{[f@2012-01-02], (t@2012-01-02, t@2012-01-04)}"
				</programlisting>
			</listitem>

			<listitem id="ttype_tlt">
				<indexterm><primary><varname>#&lt;</varname></primary></indexterm>
				<para>Menor que temporal</para>
				<para><varname>{base,torder} #&lt; {base,torder}:tbool</varname></para>
				<programlisting>
SELECT tfloat '[1@2012-01-01, 4@2012-01-04)' #&lt; 2;
-- "{[t@2012-01-01, f@2012-01-02, f@2012-01-04)}"
SELECT tint '[2@2012-01-01, 2@2012-01-05)' #&lt; tfloat '[1@2012-01-03, 3@2012-01-05)';
-- "{[f@2012-01-03, f@2012-01-04], (t@2012-01-04, t@2012-01-05)}"
				</programlisting>
			</listitem>

			<listitem id="ttype_tgt">
				<indexterm><primary><varname>#&gt;</varname></primary></indexterm>
				<para>Mayor que temporal</para>
				<para><varname>{base,torder} #&gt; {base,torder}:tbool</varname></para>
				<programlisting>
SELECT 1 #&gt; tint '[1@2012-01-03, 1@2012-01-05)';
-- "[f@2012-01-03, f@2012-01-05)"
				</programlisting>
			</listitem>

			<listitem id="ttype_tle">
				<indexterm><primary><varname>#&lt;=</varname></primary></indexterm>
				<para>Menor o igual que temporal</para>
				<para><varname>{base,torder} #&lt;= {base,torder}:tbool</varname></para>
				<programlisting>
SELECT tint '[1@2012-01-01, 1@2012-01-05)' #&lt;= tfloat '{2@2012-01-03, 3@2012-01-04}';
-- "{t@2012-01-03, t@2012-01-04}"
				</programlisting>
			</listitem>

			<listitem id="ttype_tge">
				<indexterm><primary><varname>#&gt;=</varname></primary></indexterm>
				<para>Mayor o igual que temporal</para>
				<para><varname>{base,torder} #&gt;= {base,torder}:tbool</varname></para>
				<programlisting>
SELECT 'AAA'::text #&gt; ttext '{[AAA@2012-01-01, AAA@2012-01-03),
[BBB@2012-01-04, BBB@2012-01-05)}';
-- "{[f@2012-01-01, f@2012-01-03), [t@2012-01-04, t@2012-01-05)}"
				</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1>
		<title>Funciones y operadores matemáticos</title>

		<itemizedlist>
			<listitem id="tnumber_add">
				<indexterm><primary><varname>+</varname></primary></indexterm>
				<para>Adición temporal</para>
				<para><varname>{number,tnumber} + {number,tnumber}:tnumber</varname></para>
				<programlisting>
SELECT tint '[2@2012-01-01, 2@2012-01-04)' + 1.5;
-- "[3.5@2012-01-01, 3.5@2012-01-04)"
SELECT tint '[2@2012-01-01, 2@2012-01-04)' + tfloat '[1@2012-01-01, 4@2012-01-04)';
-- "[3@2012-01-01, 6@2012-01-04)"
SELECT tfloat '[1@2012-01-01, 4@2012-01-04)' +
tfloat '{[1@2012-01-01, 2@2012-01-02), [1@2012-01-02, 2@2012-01-04)}';
-- "{[2@2012-01-01, 4@2012-01-04), [3@2012-01-02, 6@2012-01-04)}"
				</programlisting>
			</listitem>

			<listitem id="tnumber_sub">
				<indexterm><primary><varname>-</varname></primary></indexterm>
				<para>Resta temporal</para>
				<para><varname>{number,tnumber} - {number,tnumber}:tnumber</varname></para>
				<programlisting>
SELECT tint '[1@2012-01-01, 1@2012-01-04)' - tint '[2@2012-01-03, 2@2012-01-05)';
-- "[-1@2012-01-03, -1@2012-01-04)"
SELECT tfloat '[3@2012-01-01, 6@2012-01-04)' - tint '[2@2012-01-01, 2@2012-01-04)';
-- "[1@2012-01-01, 4@2012-01-04)"
				</programlisting>
			</listitem>

			<listitem id="tnumber_mult">
				<indexterm><primary><varname>*</varname></primary></indexterm>
				<para>Multiplicación temporal</para>
				<para><varname>{number,tnumber} * {number,tnumber}:tnumber</varname></para>
				<programlisting>
SELECT tfloat '[1@2012-01-01, 4@2012-01-04)' * 2;
-- "[2@2012-01-01, 8@2012-01-04)"
SELECT tfloat '[1@2012-01-01, 4@2012-01-04)' * tint '[2@2012-01-01, 2@2012-01-04)';
-- "[2@2012-01-01, 8@2012-01-04)"
SELECT tfloat '[1@2012-01-01, 3@2012-01-03)' * '[3@2012-01-01, 1@2012-01-03)'
-- "{[3@2012-01-01, 4@2012-01-02, 3@2012-01-03)}"
				</programlisting>
			</listitem>

			<listitem id="tnumber_div">
				<indexterm><primary><varname>/</varname></primary></indexterm>
				<para>División temporal</para>
				<para><varname>{number,tnumber} / {number,tnumber}:tnumber</varname></para>
				<para>La función genera un error si el denominador es alguna vez igual a cero durante el intervalo de tiempo común de los argumentos.</para>
				<programlisting>
SELECT 2 / tfloat '[1@2012-01-01, 3@2012-01-04)';
-- "[2@2012-01-01, 1@2012-01-02 12:00:00+00, 0.666666666666667@2012-01-04)"
SELECT tfloat '[1@2012-01-01, 5@2012-01-05)' / '[5@2012-01-01, 1@2012-01-05)'
-- "{[0.2@2012-01-01, 1@2012-01-03,2012-01-03, 5@2012-01-03,2012-01-05)}"
select 2 / tfloat '[-1@2000-01-01, 1@2000-01-02]'
-- ERROR:  Division by zero
select tfloat '[-1@2000-01-04, 1@2000-01-05]' / tfloat '[-1@2000-01-01, 1@2000-01-05]'
-- "[-2@2000-01-04, 1@2000-01-05]"
				</programlisting>
			</listitem>

			<listitem id="round">
				<indexterm><primary><varname>round</varname></primary></indexterm>
				<para>Redondear los valores a un número de posiciones decimales</para>
				<para><varname>round(tfloat,integer):tfloat</varname></para>
				<programlisting>
SELECT round(tfloat '[0.785398163397448@2000-01-01, 2.35619449019234@2000-01-02]', 2);
-- "[0.79@2000-01-01, 2.36@2000-01-02]"
				</programlisting>
			</listitem>

			<listitem id="degrees">
				<indexterm><primary><varname>degrees</varname></primary></indexterm>
				<para>Convertir de radianes a grados</para>
				<para><varname>degrees(tfloat):tfloat</varname></para>
				<programlisting>
SELECT degrees(tfloat '[0.785398163397448@2000-01-01, 2.35619449019234@2000-01-02]');
-- "[45@2000-01-01, 135@2000-01-02]"
				</programlisting>
			</listitem>

			<listitem id="derivative">
				<indexterm><primary><varname>derivative</varname></primary></indexterm>
				<para>Obtener la derivada sobre el tiempo del número flotante temporal en unidades por segundo</para>
				<para><varname>derivative(tfloat):tfloat</varname></para>
				<para>El número flotante temporal debe tener interpolación linear</para>
				<programlisting>
SELECT derivative(tfloat '{[0@2000-01-01, 10@2000-01-02, 5@2000-01-03],
  [1@2000-01-04, 0@2000-01-05]}') * 3600 * 24;
--  Interp=Stepwise;{[-10@2000-01-01, 5@2000-01-02, 5@2000-01-03],
  [1@2000-01-04, 1@2000-01-05]}
SELECT derivative(tfloat 'Interp=Stepwise;[0@2000-01-01, 10@2000-01-02, 5@2000-01-03]');
-- ERROR:  The temporal value must have linear interpolation
				</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1>
		<title>Operadores booleanos</title>
		<itemizedlist>
			<listitem id="tbool_and">
				<indexterm><primary><varname>&amp;</varname></primary></indexterm>
				<para>Y temporal</para>
				<para><varname>{boolean,tbool} &amp; {boolean,tbool}:tbool</varname></para>
				<programlisting>
SELECT tbool '[true@2012-01-03, true@2012-01-05)' &amp;
tbool '[false@2012-01-03, false@2012-01-05)';
-- "[f@2012-01-03, f@2012-01-05)"
SELECT tbool '[true@2012-01-03, true@2012-01-05)' &amp;
tbool '{[false@2012-01-03, false@2012-01-04),
[true@2012-01-04, true@2012-01-05)}';
-- "{[f@2012-01-03, t@2012-01-04, t@2012-01-05)}"
				</programlisting>
			</listitem>

			<listitem id="tbool_or">
				<indexterm><primary><varname>|</varname></primary></indexterm>
				<para>O temporal</para>
				<para><varname>{boolean,tbool} | {boolean,tbool}:tbool</varname></para>
				<programlisting>
SELECT tbool '[true@2012-01-03, true@2012-01-05)' |
tbool '[false@2012-01-03, false@2012-01-05)';
-- "[t@2012-01-03, t@2012-01-05)"
				</programlisting>
			</listitem>

			<listitem id="tbool_not">
				<indexterm><primary><varname>~</varname></primary></indexterm>
				<para>No temporal</para>
				<para><varname>~tbool:tbool</varname></para>
				<programlisting>
SELECT ~tbool '[true@2012-01-03, true@2012-01-05)';
-- "[f@2012-01-03, f@2012-01-05)"
				</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1>
		<title>Funciones y operadores de texto</title>

		<itemizedlist>
			<listitem id="ttext_concat">
				<indexterm><primary><varname>||</varname></primary></indexterm>
				<para>Concatenación de texto temporal</para>
				<para><varname>{text,ttext} || {text,ttext}:ttext</varname></para>
				<programlisting>
SELECT ttext '[AA@2012-01-01, AA@2012-01-04)' || text 'B';
-- "["AAB"@2012-01-01, "AAB"@2012-01-04)"
SELECT ttext '[AA@2012-01-01, AA@2012-01-04)' || ttext '[BB@2012-01-02, BB@2012-01-05)';
-- "["AABB"@2012-01-02, "AABB"@2012-01-04)"
SELECT ttext '[A@2012-01-01, B@2012-01-03, C@2012-01-04]' ||
ttext '{[D@2012-01-01, D@2012-01-02), [E@2012-01-02, E@2012-01-04)}';
-- "{["DA"@2012-01-01, "EA"@2012-01-02, "EB"@2012-01-03, "EB"@2012-01-04)}"
				</programlisting>
			</listitem>

			<listitem id="ttext_upper">
				<indexterm><primary><varname>upper</varname></primary></indexterm>
				<para>Transformar a mayúsculas</para>
				<para><varname>upper(ttext):ttext</varname></para>
				<programlisting>
SELECT upper(ttext '[AA@2000-01-01, bb@2000-01-02]');
-- "["AA"@2000-01-01, "BB"@2000-01-02]"
				</programlisting>
			</listitem>

			<listitem id="ttext_lower">
				<indexterm><primary><varname>lower</varname></primary></indexterm>
				<para>Transformar a minúsculas</para>
				<para><varname>lower(ttext):ttext</varname></para>
				<programlisting>
SELECT lower(ttext '[AA@2000-01-01, bb@2000-01-02]');
-- "["aa"@2000-01-01, "bb"@2000-01-02]"
				</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1>
		<title>Operadores de cuadro delimitador</title>
		<para>Estos operadores prueban si los cuadros delimitadores de sus argumentos satisfacen el predicado y dan como resultado un valor booleano. Como se indica en <xref linkend="temporal_types" />, el cuadro delimitador asociado a un tipo temporal depende del tipo base: es el tipo <varname>period</varname> para los tipos <varname>tbool</varname> y <varname>ttext</varname>, el tipo <varname>tbox</varname> para los tipos <varname>tint</varname> y <varname>tfloat</varname> y el tipo <varname>stbox</varname> para los tipos <varname>tgeompoint</varname> y <varname>tgeogpoint</varname>. Además, como se dijo en <xref linkend="casting_box_types" />, muchos tipos PostgreSQL, PostGIS o MobilityDB se pueden convertir a los tipos <varname>tbox</varname> y <varname>stbox</varname>. Por ejemplo, los tipos numéricos y los rangos se pueden convertir al tipo <varname>tbox</varname>, los tipos <varname>geometry</varname> y <varname>geography</varname> se pueden convertir al tipo <varname>stbox</varname> y los tipos de tiempo y los tipos temporales se pueden convertir a los tipos <varname>tbox</varname> y <varname>stbox</varname>.</para>


		<para>Un primer conjunto de operadores considera las relaciones topológicas entre los cuadros delimitadores. Hay cinco operadores topológicos: superposicion (<varname>&amp;&amp;</varname>), contiene (<varname>@&gt;</varname>), está contenido (<varname>&lt;@</varname>), mismo (<varname>~=</varname>) y adyacente (<varname>-|-</varname>). Los argumentos de estos operadores pueden ser un tipo base, una cuadro delimitador o un tipo temporal y los operadores verifican la relación topológica teniendo en cuenta el valor y/o la dimensión temporal según el tipo de los argumentos.</para>

		<para>Otro conjunto de operadores considera la posición relativa de los cuadros delimitadores. Los operadores <varname>&lt;&lt;</varname>, <varname>&gt;&gt;</varname>, <varname>&amp;&lt;</varname> y <varname>&amp;&gt;</varname> consideran la dimensión de valor para los tipos <varname>tint</varname> y <varname>tfloat</varname> y las coordenadas X para los tipos <varname>tgeompoint</varname> y <varname>tgeogpoint</varname>, los operadores <varname>&lt;&lt;|</varname>, <varname>|&gt;&gt;</varname>, <varname>&amp;&lt;|</varname> y <varname>|&amp;&gt;</varname> consideran las coordenadas Y para los tipos <varname>tgeompoint</varname> y <varname>tgeogpoint</varname>, los operadores <varname>&lt;&lt;/</varname>, <varname>/&gt;&gt;</varname>, <varname>&amp;&lt;/</varname> y <varname>/&amp;&gt;</varname> consideran las coordenadas Z para los tipos <varname>tgeompoint</varname> y <varname>tgeogpoint</varname> y los operadores <varname>&lt;&lt;#</varname>, <varname>#&gt;&gt;</varname>, <varname>#&amp;&lt;</varname> y <varname>#&amp;&gt;</varname> consideran la dimensión tiempo para todos los tipos temporales.</para>

		<para>Finalmente, cabe destacar que los operadores de cuadro delimitador permiten mezclar geometrías 2D/3D pero en ese caso, el cálculo sólo se realiza en 2D.</para>

		<para>Refiérase a <xref linkend="box_topo_operators" /> y <xref linkend="box_relpos_operators" /> para los operadores de cuadro delimitador.</para>
	</sect1>

	<sect1>
		<title>Operadores de distancia</title>
		<para>Hay dos operadores de distancia. El primero, denotado <varname>|=|</varname>, calcula la distancia entre un punto temporal y una geometría o entre dos puntos temporales en su punto de aproximación más cercano, que es un número flotante. Esto es lo mismo que la función <varname>nearestApproachDistance</varname> discutida antes, pero como operador se puede utilizar para realizar una búsqueda de vecino más cercano utilizando un índice GiST (ver <xref linkend="indexing_temporal_types" />).</para>

		<para>Por otro lado, el operador de distancia temporal, denotado <varname>&lt;-&gt;</varname>, calcula la distancia en cada instante de la intersección de las extensiones temporales de sus argumentos y da como resultado un número flotante temporal. Calcular la distancia temporal es útil en muchas aplicaciones de movilidad. Por ejemplo, un grupo en movimiento (también conocido como convoy o bandada) se define como un conjunto de objetos que se mueven cerca unos de otros durante un intervalo de tiempo prolongado. Esto requiere calcular la distancia temporal entre dos objetos en movimiento.</para>

		<para>El operador de distancia temporal acepta una geometría/geografía restringida a un punto o un punto temporal como argumentos. Observe que los tipos temporales sólo consideran la interpolación lineal entre valores, mientras que la distancia es una raíz de una función cuadrática. Por lo tanto, el operador de distancia temporal proporciona una aproximación lineal del valor de distancia real para los puntos de secuencia temporal. En este caso, los argumentos se sincronizan en la dimensión de tiempo y para cada uno de los segmentos de línea que componen los argumentos, se calcula la distancia espacial entre el punto inicial, el punto final y el punto de aproximación más cercano, como se muestra en los ejemplos a continuación.</para>

		<itemizedlist>
			<listitem id="smallest_distance">
				<indexterm><primary><varname>|=|</varname></primary></indexterm>
				<para>Obtener la distancia más pequeña que haya existido &Z_support; &geography_support;</para>
				<para><varname>{geometry,tgeompoint} |=| {geometry,tgeompoint}:float</varname></para>
				<programlisting>
SELECT tgeompoint '[Point(0 0)@2012-01-02, Point(1 1)@2012-01-04, Point(0 0)@2012-01-06)'
|=| geometry 'Linestring(2 2,2 1,3 1)';
-- "1"
SELECT tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03, Point(0 0)@2012-01-05)'
|=| tgeompoint '[Point(2 0)@2012-01-02, Point(1 1)@2012-01-04, Point(2 2)@2012-01-06)';
-- "0.5"
				</programlisting>
			</listitem>

			<listitem id="distance">
				<indexterm><primary><varname>&lt;-&gt;</varname></primary></indexterm>
				<para>Obtener la distancia temporal &Z_support; &geography_support;</para>
				<para><varname>{point,tpoint} &lt;-&gt; {point,tpoint}:tfloat</varname></para>
				<programlisting>
SELECT tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)' &lt;-&gt;
geometry 'Point(0 1)';
-- "[1@2012-01-01, 0.707106781186548@2012-01-02, 1@2012-01-03)"
SELECT tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)' &lt;-&gt;
tgeompoint '[Point(0 1)@2012-01-01, Point(1 0)@2012-01-03)';
-- "[1@2012-01-01, 0@2012-01-02, 1@2012-01-03)"
SELECT tgeompoint '[Point(0 1)@2012-01-01, Point(0 0)@2012-01-03)' &lt;-&gt;
tgeompoint '[Point(0 0)@2012-01-01, Point(1 0)@2012-01-03)';
-- "[1@2012-01-01, 0.707106781186548@2012-01-02, 1@2012-01-03)"
SELECT tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-02)' &lt;-&gt;
tgeompoint '[Point(0 1)@2012-01-01, Point(1 2)@2012-01-02)';
-- "[1@2012-01-01,1@2012-01-02)"
				</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 id="topological_relationships_temporal_points">
		<title>Relaciones topológicas para puntos temporales</title>

		<para>Las relaciones topológicas como <varname>ST_Intersects</varname> y <varname>ST_Relate</varname> pueden ser generalizadas a los puntos temporales. Los argumentos de estas funciones generalizadas son un punto temporal o un tipo base (es decir, un <varname>geometry</varname> o <varname>geography</varname>), pero estas funciones no permiten un tipo base en ambos argumentos. Además, ambos argumentos deben ser del mismo tipo base, es decir, estas funciones no permiten tener un punto de geometría temporal (o una geometría) y un punto de geografía temporal (o una geografía) como argumentos.</para>

		<para>Hay dos versiones de las relaciones topológicas temporales:</para>
		<itemizedlist>
			<listitem>
				<para>La primera versión aplica la función topológica tradicional a la unión de todos los valores tomados por el punto temporal (que es un <varname>geometry</varname> o <varname>geography</varname>) y resulta en un <varname>boolean</varname> o un <varname>text</varname>. Ejemplos son las funciones <varname>intersects</varname> y <varname>relate</varname>.</para>
			</listitem>

			<listitem>
				<para>La segunda versión se define con la semántica temporal, es decir, la función topológica tradicional se calcula en cada instante y da como resultado un <varname>tbool</varname> o un <varname>ttext</varname>. Ejemplos son las funciones <varname>tintersects</varname> y  <varname>trelate</varname>.</para>
			</listitem>
		</itemizedlist>

		<para>Todas las relaciones espaciales en las dos versiones están definidas para puntos de geometría temporal, mientras que sólo cuatro de ellas están definidas para puntos de geografía temporal, a saber, <varname>covers</varname>, <varname>coveredby</varname>, <varname>intersects</varname> y <varname>dwithin</varname> y las correspondientes versiones temporales.</para>

		<para>La semántica de la primera versión de las relaciones varía según la relación y el tipo de argumentos. Por ejemplo, la siguiente consulta
			<programlisting>
SELECT intersects(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',
  tgeompoint '[Point(0 1)@2012-01-01, Point(1 1)@2012-01-03)');
			</programlisting>
			comprueba si el punto temporal se cruzó alguna vez con la geometría, ya que la consulta es conceptualmente equivalente a la siguiente
			<programlisting>
SELECT ST_Intersects(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',
  geometry 'Linestring(0 1,1 1)');
			</programlisting>
			donde la segunda geometría se obtiene aplicando la función <varname>trajectory</varname> al punto temporal. Por otro lado, la consulta
			<programlisting>
SELECT contains(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',
  tgeompoint '[Point(0 1)@2012-01-01, Point(1 1)@2012-01-03)');
			</programlisting>
			comprueba si la geometría siempre contiene el punto temporal. Finalmente, la siguiente consulta
			<programlisting>
SELECT intersects(tgeompoint '[Point(0 1)@2012-01-01, Point(1 0)@2012-01-03)',
  tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)');
			</programlisting>
			prueba si los puntos temporales pueden cruzarse, ya que la consulta anterior es conceptualmente equivalente a la siguiente
			<programlisting>
SELECT ST_Intersects('Linestring(0 1,1 0)', 'Linestring(0 0,1 1)');
			</programlisting>
		</para>

		<para>Las primeras versiones de las relaciones se utilizan normalmente en combinación con un índice espacio-temporal al calcular las relaciones temporales. Por ejemplo, la siguiente consulta
			<programlisting>
SELECT T.TripId, R.RegionId, tintersects(T.Trip, R.Geom)
FROM Trips T, Regions R
WHERE intersects(T.Trip, R.Geom)
			</programlisting>
			que verifica si un viaje <varname>T</varname> (que es un punto temporal) se cruza con una región <varname>R</varname> (que es una geometría) beneficiará de un índice espacio-temporal en la columna <varname>T.Trip</varname> dado que la función <varname>intersects</varname> realiza automáticamente la comparación del cuadro delimitador <varname>T.Trip &amp;&amp; R.Geom</varname>. Esto se explica más adelante en este documento.</para>

		<para>Tres relaciones topológicas disponibles en PostGIS no se proporcionan en la versión temporal.
			<itemizedlist>
			<listitem>
				<para><varname>tcontainsproperly</varname> ya que siempre sería igual a <varname>tcontains</varname>: <varname>ST_Contains</varname> devuelve verdadero si y sólo si ningún punto de B se encuentra en el exterior de A y al menos un punto del interior de B se encuentra en el interior de A. <varname>ST_ContainsProperly</varname> devuelve verdadero si B cruza el interior de A pero no el límite (o exterior).</para>
			</listitem>

				<listitem>
					<para><varname>tcrosses</varname> ya que siempre devolvería falso: <varname>ST_Crosses</varname> devuelve verdadero si las geometrías tienen algunos puntos interiores en común, pero no todos.</para>
				</listitem>

				<listitem>
					<para><varname>toverlaps</varname> ya que siempre devolvería falso: <varname>ST_Overlaps</varname> devuelve verdadero si las geometrías comparten espacio, son de la misma dimensión, pero no están completamente contenidas entre sí.</para>
				</listitem>
			</itemizedlist>
			</para>

		<para>De manera similar, sólo unas pocas relaciones topológicas temporales son significativas cuando los dos argumentos son puntos temporales. Por lo tanto, las relaciones admitidas para dos puntos de geometría temporal son <varname>tdisjoint</varname>, <varname>tequals</varname>, <varname>tintersects</varname>, <varname>tdwithin</varname> y <varname>trelate</varname> (con 2 y 3 argumentos), mientras que sólo <varname>tintersects</varname> y <varname>tdwithin</varname> son disponibles con dos puntos geográficos temporales.</para>

		<para>Las funciones <varname>relate</varname> y <varname>trelate</varname> tienen dos formas con dos o tres argumentos. Las formas de dos argumentos consideran la relación espacial entre el interior, el límite y el exterior de los argumentos y devuelven un valor <varname>text</varname> o <varname>ttext</varname> que representa el patrón de matriz de intersección máxima. Este patrón se define mediante el modelo de 9 intersecciones dimensionalmente extendido o DE-9IM (consulte la documentación de PostGIS para obtener más detalles). Las formas de tres argumentos determinan si los dos primeros argumentos satisfacen el patrón de matriz de intersección dado como tercer argumento (un valor <varname>text</varname>) y devuelve un booleano o un booleano temporal.</para>

		<para>Finalmente, cabe destacar que las relaciónes topológicas permiten mezclar geometrías 2D/3D pero en ese caso, el cálculo sólo se realiza en 2D.</para>

		<sect2>
			<title>Relaciones espaciales posibles</title>
			<itemizedlist>
				<listitem id="contains">
					<indexterm><primary><varname>contains</varname></primary></indexterm>
					<para>Puede contener</para>
					<para><varname>contains({geo,tgeompoint},{geo,tgeompoint}):boolean</varname></para>
					<programlisting>
SELECT contains(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',
tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)');
-- true
				</programlisting>
				</listitem>

				<listitem id="containsproperly">
					<indexterm><primary><varname>containsproperly</varname></primary></indexterm>
					<para>Puede contener estrictamente</para>
					<para><varname>containsproperly({geo,tgeompoint},{geo,tgeompoint}):boolean</varname></para>
					<programlisting>
SELECT containsproperly(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',
tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)');
-- false
				</programlisting>
				</listitem>

				<listitem id="covers">
					<indexterm><primary><varname>covers</varname></primary></indexterm>
					<para>Puede cubrir</para>
					<para><varname>covers({geo,tpoint},{geo,tpoint}):boolean</varname></para>
					<programlisting>
SELECT covers(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',
tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)');
-- true
				</programlisting>
				</listitem>

				<listitem id="coveredby">
					<indexterm><primary><varname>coveredby</varname></primary></indexterm>
					<para>Puede estar cubierto por</para>
					<para><varname>coveredby({geo,tpoint},{geo,tpoint}):boolean</varname></para>
						<programlisting>
SELECT coveredby(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',
tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)');
-- false
					</programlisting>
				</listitem>

				<listitem id="crosses">
					<indexterm><primary><varname>crosses</varname></primary></indexterm>
					<para>Puede cruzar</para>
					<para><varname>crosses({geo,tgeompoint},{geo,tgeompoint}):boolean</varname></para>
						<programlisting>
SELECT crosses(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',
tgeompoint '[Point(0 0)@2012-01-01, Point(2 2)@2012-01-03)');
-- true
				</programlisting>
				</listitem>

				<listitem id="disjoint">
					<indexterm><primary><varname>disjoint</varname></primary></indexterm>
					<para>Puede ser disjunto</para>
					<para><varname>disjoint({geo,tgeompoint},{geo,tgeompoint}):boolean</varname></para>
						<programlisting>
SELECT disjoint(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',
tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)');
-- false
				</programlisting>
				</listitem>

				<listitem id="equals">
					<indexterm><primary><varname>equals</varname></primary></indexterm>
					<para>Puede ser igual</para>
					<para><varname>equals({geo,tgeompoint},{geo,tgeompoint}):boolean</varname></para>
					<programlisting>
SELECT equals(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',
tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)');
-- false
					</programlisting>
				</listitem>

				<listitem id="intersects">
					<indexterm><primary><varname>intersects</varname></primary></indexterm>
					<para>Puede cruzarse &Z_support;</para>
					<para><varname>intersects({geo,tpoint},{geo,tpoint}):boolean</varname></para>
					<programlisting>
SELECT intersects(geometry 'Polygon((0 0 0,0 1 0,1 1 0,1 0 0,0 0 0))',
tgeompoint '[Point(0 0 1)@2012-01-01, Point(1 1 1)@2012-01-03)');
-- false
SELECT intersects(geometry 'Polygon((0 0 0,0 1 1,1 1 1,1 0 0,0 0 0))',
tgeompoint '[Point(0 0 1)@2012-01-01, Point(1 1 1)@2012-01-03)');
-- true
					</programlisting>
				</listitem>

				<listitem id="overlaps">
					<indexterm><primary><varname>overlaps</varname></primary></indexterm>
					<para>Puede superponerse</para>
					<para><varname>overlaps({geo,tgeompoint},{geo,tgeompoint}):boolean</varname></para>
					<programlisting>
SELECT overlaps(geometry 'Linestring(1 1,3 3)',
tgeompoint '[Point(0 0)@2012-01-01, Point(2 2)@2012-01-03)');
-- true
				</programlisting>
				</listitem>

				<listitem id="touches">
					<indexterm><primary><varname>touches</varname></primary></indexterm>
					<para>Puede tocar</para>
					<para><varname>touches({geo,tgeompoint},{geo,tgeompoint}):boolean</varname></para>
					<programlisting>
SELECT touches(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',
tgeompoint '[Point(0 0)@2012-01-01, Point(0 1)@2012-01-03)');
-- true
				</programlisting>
				</listitem>

				<listitem id="within">
					<indexterm><primary><varname>within</varname></primary></indexterm>
					<para>Puede estar dentro</para>
					<para><varname>within({geo,tgeompoint},{geo,tgeompoint}):boolean</varname></para>
					<programlisting>
SELECT within(geometry 'LineString(1 1,2 2)',
tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-03)');
-- true
				</programlisting>
				</listitem>

				<listitem id="dwithin">
					<indexterm><primary><varname>dwithin</varname></primary></indexterm>
					<para>Puede estar a distancia de &Z_support;</para>
					<para><varname>dwithin({geo,tpoint},{geo,tpoint},float):boolean</varname></para>
					<programlisting>
SELECT dwithin(geometry 'Polygon((0 0 0,0 1 1,1 1 1,1 0 0,0 0 0))',
  tgeompoint 'Point(0 2 1)@2000-01-01,Point(2 2 1)@2000-01-02', 1)
-- true
SELECT dwithin(geometry 'Polygon((0 0 0,0 1 1,1 1 1,1 0 0,0 0 0))',
  tgeompoint 'Point(0 2 2)@2000-01-01,Point(2 2 2)@2000-01-02', 1)
-- false
				</programlisting>
				</listitem>

				<listitem id="relate">
					<indexterm><primary><varname>relate</varname></primary></indexterm>
					<para>Puede estar relacionado</para>
					<para><varname>relate({geo,tgeompoint},{geo,tgeompoint}):text</varname></para>
					<para><varname>relate({geo,tgeompoint},{geo,tgeompoint},text):boolean</varname></para>
					<programlisting>
SELECT relate(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',
tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)');
-- "1F2F01FF2"
SELECT relate(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',
tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)','1F2F01FF2');
-- true
				</programlisting>
				</listitem>
			</itemizedlist>
		</sect2>

		<sect2>
			<title>Relaciones espaciales temporales</title>
			<itemizedlist>
				<listitem id="tcontains">
					<indexterm><primary><varname>tcontains</varname></primary></indexterm>
					<para>Contiene temporal</para>
					<para><varname>tcontains({geo,tgeompoint},{geo,tgeompoint}):tbool</varname></para>
					<programlisting>
SELECT tcontains(geometry 'Polygon((1 1,1 2,2 2,2 1,1 1))',
tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-04)');
-- "{[f@2012-01-01, f@2012-01-02], (t@2012-01-02, f@2012-01-03, f@2012-01-04)}"
				</programlisting>
				</listitem>

				<listitem id="tcovers">
					<indexterm><primary><varname>tcovers</varname></primary></indexterm>
					<para>Cubrir temporal &geography_support;</para>
					<para><varname>tcovers({geo,tpoint},{geo,tpoint}):tbool</varname></para>
					<programlisting>
SELECT tcovers(geometry 'Polygon((1 1,1 2,2 2,2 1,1 1))',
tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-04)');
-- "{[f@2012-01-01, t@2012-01-02, t@2012-01-03], (f@2012-01-03, f@2012-01-04]}"
				</programlisting>
				</listitem>

				<listitem id="tcoveredby">
					<indexterm><primary><varname>tcoveredby</varname></primary></indexterm>
					<para>Cubierto por temporal &geography_support;</para>
					<para><varname>tcoveredby({geo,tpoint},{geo,tpoint}):tbool</varname></para>
					<programlisting>
SELECT tcoveredby(geometry 'Point(1 1)',
tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-04)');
-- "{[f@2012-01-01, t@2012-01-02], (f@2012-01-02, f@2012-01-04)}"
				</programlisting>
				</listitem>

				<listitem id="tdisjoint">
					<indexterm><primary><varname>tdisjoint</varname></primary></indexterm>
					<para>Disjunto temporal &Z_support; &geography_support;</para>
					<para><varname>tdisjoint({geo,tgeompoint},{geo,tgeompoint}):tbool</varname></para>
					<programlisting>
SELECT tdisjoint(geometry 'Polygon((1 1,1 2,2 2,2 1,1 1))',
tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-04)');
-- "{[t@2012-01-01, f@2012-01-02, f@2012-01-03], (t@2012-01-03, t@2012-01-04]}"
SELECT tdisjoint(tgeompoint '[Point(0 3)@2012-01-01, Point(3 0)@2012-01-05)',
tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-05)');
-- "{[t@2012-01-01, f@2012-01-03], (t@2012-01-03, t@2012-01-05)}"
				</programlisting>
				</listitem>

				<listitem id="tequals">
					<indexterm><primary><varname>tequals</varname></primary></indexterm>
					<para>Igual temporal &Z_support; &geography_support;</para>
					<para><varname>tequals({point,tgeompoint},{point,tgeompoint}):tbool</varname></para>
					<programlisting>
SELECT tequals(geometry 'Point(1 1)',
tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-04)');
-- "{[f@2012-01-01, t@2012-01-02], (f@2012-01-02, f@2012-01-04]}"
SELECT tequals(tgeompoint '[Point(0 3)@2012-01-01, Point(3 0)@2012-01-05)',
tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-05)');
-- "{[f@2012-01-01, t@2012-01-03], (f@2012-01-03, f@2012-01-05)}"
				</programlisting>
				</listitem>

				<listitem id="tintersects">
					<indexterm><primary><varname>tintersects</varname></primary></indexterm>
					<para>Intersección temporal &Z_support; &geography_support;</para>
					<para><varname>tintersects({geo,tpoint},{geo,tpoint}):tbool</varname></para>
					<programlisting>
SELECT tintersects(geometry 'MultiPoint(1 1,2 2)',
tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-04)');
-- "{[f@2012-01-01, t@2012-01-02], (f@2012-01-02, t@2012-01-03],
(f@2012-01-03, f@2012-01-04]}"
SELECT tintersects(tgeompoint '[Point(0 3)@2012-01-01, Point(3 0)@2012-01-05)',
tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-05)');
-- "{[f@2012-01-01, t@2012-01-03], (f@2012-01-03, f@2012-01-05)}"
				</programlisting>
				</listitem>

				<listitem id="ttouches">
					<indexterm><primary><varname>ttouches</varname></primary></indexterm>
					<para>Toca temporal</para>
					<para><varname>ttouches({geo,tgeompoint},{geo,tgeompoint}):tbool</varname></para>
					<programlisting>
SELECT ttouches(geometry 'Polygon((1 0,1 2,2 2,2 0,1 0))',
tgeompoint '[Point(0 0)@2012-01-01, Point(3 0)@2012-01-04)');
-- "{[f@2012-01-01, t@2012-01-02, t@2012-01-03], (f@2012-01-03, f@2012-01-04]}"
				</programlisting>
				</listitem>

				<listitem id="twithin">
					<indexterm><primary><varname>twithin</varname></primary></indexterm>
					<para>Dentro temporal</para>
					<para><varname>twithin({geo,tgeompoint},{geo,tgeompoint}):tbool</varname></para>
					<programlisting>
SELECT twithin(geometry 'Point(1 1)',
tgeompoint '[Point(0 0)@2012-01-01, Point(2 2)@2012-01-03)');
-- "{[f@2012-01-01, t@2012-01-02], (f@2012-01-02, f@2012-01-03]}"
				</programlisting>
				</listitem>

				<listitem id="tdwithin">
					<indexterm><primary><varname>tdwithin</varname></primary></indexterm>
					<para>Estar a distancia de temporal &Z_support; &geography_support;</para>
					<para><varname>tdwithin({geo,tpoint},{geo,tpoint},float):tbool</varname></para>
					<programlisting>
SELECT tdwithin(geometry 'Polygon((1 1,1 2,2 2,2 1,1 1))',
tgeompoint '[Point(0 0)@2012-01-01, Point(3 0)@2012-01-04)', 1);
-- "{[f@2012-01-01, t@2012-01-02, t@2012-01-03], (f@2012-01-03, f@2012-01-04)}"
SELECT tdwithin(tgeompoint '[Point(1 0)@2000-01-01, Point(1 4)@2000-01-05]',
tgeompoint 'Interp=Stepwise;[Point(1 2)@2000-01-01, Point(1 3)@2000-01-05]', 1);
-- "{[f@2000-01-01, t@2000-01-02, t@2000-01-04], (f@2000-01-04, t@2000-01-05]}"
				</programlisting>
				</listitem>

				<listitem id="trelate">
					<indexterm><primary><varname>trelate</varname></primary></indexterm>
					<para>Relacionar temporal</para>
					<para><varname>trelate({geo,tgeompoint},{geo,tgeompoint},text):tbool</varname></para>
					<para><varname>trelate({geo,tgeompoint},{geo,tgeompoint}):ttext</varname></para>
					<programlisting>
SELECT trelate(geometry 'Polygon((1 0,1 2,2 2,2 0,1 0))',
tgeompoint '[Point(0 0)@2012-01-01, Point(3 0)@2012-01-04)');
-- "{[FF2FF10F2@2012-01-01, FF20F1FF2@2012-01-02, FF20F1FF2@2012-01-03],
(FF2FF10F2@2012-01-03, FF2FF10F2@2012-01-04]}"
SELECT trelate(geometry 'Polygon((1 0,1 2,2 2,2 0,1 0))',
tgeompoint '[Point(0 0)@2012-01-01, Point(3 0)@2012-01-04)', 'FF20F1FF2');
-- "{[f@2012-01-01, t@2012-01-02, t@2012-01-03], (f@2012-01-03, f@2012-01-04]}"
2012-01-04)}"
				</programlisting>
				</listitem>
			</itemizedlist>
			</sect2>
	</sect1>

	<sect1>
		<title>Funciones agregadas</title>

		<para>Las funciones agregadas temporales generalizan las funciones agregadas tradicionales. Su semántica es que calculan el valor de la función en cada instante de la <emphasis>unión</emphasis> de las extensiones temporales de los valores a agregar. En contraste, recuerde que todas las otras funciones que manipulan tipos temporales calculan el valor de la función en cada instante de la <emphasis>intersección</emphasis> de las extensiones temporales de los argumentos.</para>

		<para>Las funciones agregadas temporales son las siguientes:</para>
		<itemizedlist>
			<listitem><para>Para todos los tipos temporales, la función <varname>tcount</varname> generaliza la función traditional <varname>count</varname>. El conteo temporal se puede utilizar para calcular en cada momento el número de objetos disponibles (por ejemplo, el número de coches en un área).</para></listitem>
			<listitem><para>Para todos los tipos temporales, la función <varname>extent</varname> devuelve un cuadro delimitador que engloba un conjunto de valores temporales. Dependiendo del tipo de base, el resultado de esta función puede ser un <varname>period</varname>, un <varname>tbox</varname> o un <varname>stbox</varname>.</para></listitem>
			<listitem><para>Para el tipo booleano temporal, las funciones <varname>tand</varname> y <varname>tor</varname> generalizan las funciones traditionales <varname>and</varname> y <varname>or</varname>.</para></listitem>
			<listitem><para>Para los tipos numéricos temporales hay dos tipos de funciones agregadas temporales. Las funciones <varname>tmin</varname>, <varname>tmax</varname>, <varname>tsum</varname> y <varname>tavg</varname> generalizan las funciones traditionales <varname>min</varname>, <varname>max</varname>, <varname>sum</varname> y <varname>avg</varname>. Además, las funciones <varname>wmin</varname>, <varname>wmax</varname>, <varname>wcount</varname>, <varname>wsum</varname> y <varname>wavg</varname> son versiones de ventana (o acumulativas) de las funciones tradicionales que, dado un intervalo de tiempo w, calculan el valor de la función en un instante t considerando los valores durante el intervalo [t-w, t]. Todas las funciones agregadas de ventana están disponibles para enteros temporales, mientras que para flotantes temporales sólo son significativos el mínimo y el máximo de ventana.</para></listitem>
			<listitem><para>Para el tipo texto temporal, las funciones <varname>tmin</varname> y <varname>tmax</varname> generalizan las funciones traditionales <varname>min</varname> y <varname>max</varname>.</para></listitem>
			<listitem><para>Finalmente, para puntos temporales, la función <varname>tcentroid</varname> generaliza la función <varname>ST_Centroid</varname> proporcionada por PostGIS. Por ejemplo, dado un conjunto de objetos que se mueven juntos (es decir, un convoy o una bandada), el centroide temporal producirá un punto temporal que representa en cada instante el centro geométrico (o el centro de masa) de todos los objetos en movimiento.</para></listitem>
		</itemizedlist>

		<para>En los ejemplos que siguen, suponemos que las tablas <varname>Department</varname> y <varname>Trip</varname> contienen las dos tuplas introducidas en <xref linkend="examples_temporal_types" />.</para>
		<itemizedlist>
			<listitem id="tcount">
				<indexterm><primary><varname>trelate</varname></primary></indexterm>
				<para>Conteo temporal</para>
				<para><varname>tcount(ttype):{tinti,tints}</varname></para>
				<programlisting>
SELECT tcount(NoEmps) FROM Department;
-- "{[1@2012-01-01, 2@2012-02-01, 1@2012-08-01, 1@2012-10-01)}"
				</programlisting>
			</listitem>

			<listitem id="extent">
				<indexterm><primary><varname>extent</varname></primary></indexterm>
				<para>Extensión del cuadro delimitador</para>
				<para><varname>extent(temp):{period,tbox,stbox}</varname></para>
				<programlisting>
SELECT extent(noEmps) FROM Department;
-- "TBOX((4,2012-01-01 00:00:00+01),(12,2012-10-01 00:00:00+02))"
SELECT extent(Trip) FROM Trips;
-- "STBOX T((0,0,2012-01-01 08:00:00+01),(3,3,2012-01-01 08:20:00+01))"
				</programlisting>
			</listitem>

			<listitem id="tand">
				<indexterm><primary><varname>tand</varname></primary></indexterm>
				<para>Y temporal</para>
				<para><varname>tand(tbool):tbool</varname></para>
				<programlisting>
SELECT tand(NoEmps #&gt; 6) FROM Department;
-- "{[t@2012-01-01, f@2012-04-01, f@2012-10-01)}"
				</programlisting>
			</listitem>

			<listitem id="tor">
				<indexterm><primary><varname>tor</varname></primary></indexterm>
				<para>O temporal</para>
				<para><varname>tor(tbool):tbool</varname></para>
				<programlisting>
SELECT tor(NoEmps #&gt; 6) FROM Department;
-- "{[t@2012-01-01, f@2012-08-01, f@2012-10-01)}"
				</programlisting>
			</listitem>

			<listitem id="tmin">
				<indexterm><primary><varname>tmin</varname></primary></indexterm>
				<para>Mínimo temporal</para>
				<para><varname>tmin(ttype):{ttypei,ttypes}</varname></para>
				<programlisting>
SELECT tmin(NoEmps) FROM Department;
-- "{[10@2012-01-01, 4@2012-02-01, 6@2012-06-01, 6@2012-10-01)}"
				</programlisting>
			</listitem>

			<listitem id="tmax">
				<indexterm><primary><varname>tmax</varname></primary></indexterm>
				<para>Máximo temporal</para>
				<para><varname>tmax(ttype):{ttypei,ttypes}</varname></para>
				<programlisting>
SELECT tmax(NoEmps) FROM Department;
-- "{[10@2012-01-01, 12@2012-04-01, 6@2012-08-01, 6@2012-10-01)}"
				</programlisting>
			</listitem>

			<listitem id="tsum">
				<indexterm><primary><varname>tsum</varname></primary></indexterm>
				<para>Suma temporal</para>
				<para><varname>tsum(tnumber):{tnumi,tnums}</varname></para>
				<programlisting>
SELECT tsum(NoEmps) FROM Department;
-- "{[10@2012-01-01, 14@2012-02-01, 16@2012-04-01, 18@2012-06-01, 6@2012-08-01,
6@2012-10-01)}"
				</programlisting>
			</listitem>

			<listitem id="tavg">
				<indexterm><primary><varname>tavg</varname></primary></indexterm>
				<para>Promedio temporal</para>
				<para><varname>tavg(tnumber):{tfloati,tfloats}</varname></para>
				<programlisting>
SELECT tavg(NoEmps) FROM Department;
-- "{[10@2012-01-01, 10@2012-02-01), [7@2012-02-01, 7@2012-04-01),
[8@2012-04-01, 8@2012-06-01), [9@2012-06-01, 9@2012-08-01),
[6@2012-08-01, 6@2012-10-01)"
				</programlisting>
			</listitem>

			<listitem id="wmin">
				<indexterm><primary><varname>wmin</varname></primary></indexterm>
				<para>Mínimo de ventana</para>
				<para><varname>wmin(tnumber,interval):{tnumi,tnums}</varname></para>
				<programlisting>
SELECT wmin(NoEmps, interval '2 days') FROM Department;
-- "{[10@2012-01-01, 4@2012-04-01, 6@2012-06-03, 6@2012-10-03)}"
				</programlisting>
			</listitem>

			<listitem id="wmax">
				<indexterm><primary><varname>wmax</varname></primary></indexterm>
				<para>Máximo de ventana</para>
				<para><varname>wmax(tnumber,interval):{tnumi,tnums}</varname></para>
				<programlisting>
SELECT wmax(NoEmps, interval '2 days') FROM Department;
-- "{[10@2012-01-01, 12@2012-04-01, 6@2012-08-03, 6@2012-10-03)}"
				</programlisting>
			</listitem>

			<listitem id="wcount">
				<indexterm><primary><varname>wcount</varname></primary></indexterm>
				<para>Conteo de ventana</para>
				<para><varname>wcount(tnumber,interval):{tinti,tints}</varname></para>
				<programlisting>
SELECT wcount(NoEmps, interval '2 days') FROM Department;
-- "{[1@2012-01-01, 2@2012-02-01, 3@2012-04-01, 2@2012-04-03, 3@2012-06-01, 2@2012-06-03,
1@2012-08-03, 1@2012-10-03)}"
				</programlisting>
			</listitem>

			<listitem id="wsum">
				<indexterm><primary><varname>wsum</varname></primary></indexterm>
				<para>Suma de ventana</para>
				<para><varname>wsum(tint,interval):{tinti,tints}</varname></para>
				<programlisting>
SELECT wsum(NoEmps, interval '2 days') FROM Department;
-- "{[10@2012-01-01, 14@2012-02-01, 26@2012-04-01, 16@2012-04-03, 22@2012-06-01,
18@2012-06-03, 6@2012-08-03, 6@2012-10-03)}"
				</programlisting>
			</listitem>

			<listitem id="wavg">
				<indexterm><primary><varname>wavg</varname></primary></indexterm>
				<para>Promedio de ventana</para>
				<para><varname>wavg(tint,interval):{tfloati,tfloats}</varname></para>
				<programlisting>
SELECT wavg(NoEmps, interval '2 days') FROM Department;
-- "{[10@2012-01-01, 10@2012-02-01), [7@2012-02-01, 7@2012-04-01),
[8.66666666666667@2012-04-01, 8.66666666666667@2012-04-03),
[8@2012-04-03, 8@2012-06-01),
[7.33333333333333@2012-06-01, 7.33333333333333@2012-06-03),
[9@2012-06-03, 9@2012-08-03), [6@2012-08-03, 6@2012-10-03)}"
				</programlisting>
			</listitem>

			<listitem id="tcentroid">
				<indexterm><primary><varname>tcentroid</varname></primary></indexterm>
				<para>Centroide temporal</para>
				<para><varname>tcentroid(tgeompoint):tgeompoint</varname></para>
				<programlisting>
SELECT tcentroid(Trip) FROM Trips;
-- "{[POINT(0 0)@2012-01-01 08:00:00+00, POINT(1 0)@2012-01-01 08:05:00+00),
[POINT(0.5 0)@2012-01-01 08:05:00+00, POINT(1.5 0.5)@2012-01-01 08:10:00+00,
POINT(2 1.5)@2012-01-01 08:15:00+00),
[POINT(2 2)@2012-01-01 08:15:00+00, POINT(3 3)@2012-01-01 08:20:00+00)}"
				</programlisting>
			</listitem>

		</itemizedlist>
	</sect1>

	<sect1>
		<title>Funciones de utilidad</title>
		<itemizedlist>
			<listitem id="mobilitydb_version">
				<indexterm><primary><varname>mobilitydb_version</varname></primary></indexterm>
				<para>Versión de la extensión MobilityDB</para>
				<para><varname>mobilitydb_version():text</varname></para>
				<programlisting>
SELECT mobilitydb_version();
-- "MobilityDB 1.0"
				</programlisting>
			</listitem>

			<listitem id="mobilitydb_full_version">
				<indexterm><primary><varname>mobilitydb_full_version</varname></primary></indexterm>
				<para>Versión de la extensión MobilityDB y de sus dependencias</para>
				<para><varname>mobilitydb_full_version():text</varname></para>
				<programlisting>
SELECT mobilitydb_full_version();
-- "MobilityDB 1.0 PostgreSQL 12.3 PostGIS 2.5"
				</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 id="indexing_temporal_types">
		<title>Indexación de tipos temporales</title>
		<para>Se pueden crear índices GiST y SP-GiST para columnas de tabla de tipos temporales. El índice GiST implementa un árbol R para tipos alfanuméricos temporales y para tipos de puntos temporales. El índice SP-GiST implementa un árbol cuádruple para tipos alfanuméricos temporales y un árbol óctuple para tipos de puntos temporales. Ejemplos de creación de índices son los siguientes:
				<programlisting>CREATE INDEX Department_NoEmps_Gist_Idx ON Department USING Gist(NoEmps);
CREATE INDEX Trips_Trip_SPGist_Idx ON Trips USING SPGist(Trip);
				</programlisting>
		</para>

		<para>Los índices GiST y SP-GiST almacenan el cuadro delimitador para los tipos temporales. Como se explica en <xref linkend="temporal_types" />, estos son <itemizedlist>
				<listitem>
					<para>el tipo <varname>period</varname> para los tipos <varname>tbool</varname> y <varname>ttext</varname>,</para>
				</listitem>

				<listitem>
					<para>el tipo <varname>tbox</varname> par los tipos <varname>tint</varname> y <varname>tfloat</varname>,</para>
				</listitem>

				<listitem>
					<para>el tipo <varname>stbox</varname> para los tipos <varname>tgeompoint</varname> y <varname>tgeogpoint</varname>.</para>
				</listitem>
			</itemizedlist>
		</para>

		<para>Un índice GiST o SP-GiST puede acelerar las consultas que involucran a los siguientes operadores (consulte <xref linkend="operators_temporal_types" /> para obtener más información): <itemizedlist>
				<listitem>
					<para><varname>&lt;&lt;</varname>, <varname>&amp;&lt;</varname>, <varname>&amp;&gt;</varname>, <varname>&gt;&gt;</varname>, que sólo consideran la dimensión de valores en tipos alfanuméricos temporales,</para>
				</listitem>

				<listitem>
					<para><varname>&lt;&lt;</varname>, <varname>&amp;&lt;</varname>, <varname>&amp;&gt;</varname>, <varname>&gt;&gt;</varname>, <varname>&lt;&lt;|</varname>, <varname>&amp;&lt;|</varname>, <varname>|&amp;&gt;</varname>, <varname>|&gt;&gt;</varname>, <varname>&amp;&lt;/</varname>, <varname>&lt;&lt;/</varname>, <varname>/&gt;&gt;</varname> y <varname>/&amp;&gt;</varname>, que sólo consideran la dimensión espacial en tipos de puntos temporales,</para>
				</listitem>

				<listitem>
					<para><varname>&amp;&lt;#</varname>, <varname>&lt;&lt;#</varname>, <varname>#&gt;&gt;</varname>, <varname>#&amp;&gt;</varname>, que sólo consideran la dimensión temporal para todos los tipos temporales,</para>
				</listitem>

				<listitem>
					<para><varname>&amp;&amp;</varname>, <varname>@&gt;</varname>, <varname>&lt;@</varname> y <varname>~=</varname>, que consideran tantas dimensiones como compartan la columna indexada y el argumento de consulta. Estos operadores trabajan en cuadros delimitadores (es decir, <varname>period</varname>, <varname>tbox</varname> o <varname>stbox</varname>), no los valores completos.</para>
				</listitem>
			</itemizedlist>
		</para>

		<para>Además, un índice GiST puede acelerar las consultas de vecinos más cercanos que involucran el operador <varname>|=|</varname>.</para>

		<para>Por ejemplo, dado el índice definido anteriormente en la tabla <varname>Department</varname> y una consulta que implica una condición con el operador <varname>&amp;&amp;</varname> (superposición), si el argumento derecho es un flotante temporal, entonces se consideran tanto el valor como las dimensiones de tiempo para filtrar las tuplas de la relación, mientras que si el argumento derecho es un valor flotante, un rango flotante o un tipo de tiempo, entonces el valor o la dimensión de tiempo se utilizará para filtrar las tuplas de la relación. Además, se puede construir un cuadro delimitador a partir de un valor/rango y/o una marca de tiempo/período, que se puede usar para filtrar las tuplas de la relación. Ejemplos de consultas que utilizan el índice en la tabla <varname>Department</varname> definida anteriormente se dan a continuación.
				<programlisting>
SELECT * FROM Department WHERE NoEmps &amp;&amp; 5;
SELECT * FROM Department WHERE NoEmps &amp;&amp; intrange '[1, 5)';
SELECT * FROM Department WHERE NoEmps &amp;&amp; timestamptz '2012-04-01';
SELECT * FROM Department WHERE NoEmps &amp;&amp; period '[2012-04-01, 2012-05-01)';
SELECT * FROM Department WHERE NoEmps &amp;&amp;
tbox(intrange '[1, 5)', period '[2012-04-01, 2012-05-01)');
SELECT * FROM Department WHERE NoEmps &amp;&amp;
tfloat '{[1@2012-01-01, 1@2012-02-01), [5@2012-04-01, 5@2012-05-01)}';
				</programlisting>
		</para>

		<para>Del mismo modo, los ejemplos de consultas que utilizan el índice en la tabla <varname>Trips</varname> definida anteriormente se dan a continuación.
				<programlisting>
SELECT * FROM Trips WHERE Trip &amp;&amp; geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))';
SELECT * FROM Trips WHERE Trip &amp;&amp; timestamptz '2001-01-01';
SELECT * FROM Trips WHERE Trip &amp;&amp; period '[2001-01-01, 2001-01-05)';
SELECT * FROM Trips WHERE Trip &amp;&amp;
stbox(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))', period '[2001-01-01, 2001-01-05]');
SELECT * FROM Trips WHERE Trip &amp;&amp;
tgeompoint '{[Point(0 0)@2001-01-01, Point(1 1)@2001-01-02, Point(1 1)@2001-01-05)}';
				</programlisting>
		</para>

		<para>Finalmente, se pueden crear índices de árbol B para columnas de tabla de todos los tipos temporales. Para este tipo de índice, la única operación útil es la igualdad. Hay un orden de clasificación de árbol B definido para valores de tipos temporales, con los correspondientes operadores <varname>&lt;</varname>, <varname>&lt;=</varname>, <varname>&gt;</varname> y <varname>&gt;=</varname>, pero el orden es bastante arbitrario y no suele ser útil en el mundo real. El soporte de árbol B para tipos temporales está destinado principalmente a permitir la clasificación interna en las consultas, en lugar de la creación de índices reales.</para>

		<para>Para acelerar varias de las funciones en <xref linkend="manipulating_temporal_types" />, se puede agregar en la cláusula <varname>WHERE</varname> de las consultas una comparación de cuadro delimitador que hace uso de los índices disponibles. Por ejemplo, este sería típicamente el caso de las funciones que proyectan los tipos temporales a las dimensiones de valor/espacio y/o tiempo. Esto filtrará las tuplas con un índice como se muestra en la siguiente consulta.
				<programlisting>
SELECT atPeriod(T.Trip, period(2001-01-01, 2001-01-02))
FROM Trips T
-- Filtro de índice con cuadro delimitador
WHERE T.Trip &amp;&amp; period(2001-01-01, 2001-01-02)
			</programlisting>
		</para>

		<para>En el caso de los puntos temporales, todas las relaciones espaciales con la semántica posible (ver <xref linkend="topological_relationships_temporal_points" />), exceptuadas <varname>disjoint</varname> y <varname>relate</varname>, incluyen automáticamente una comparación de cuadro delimitador que hará uso de cualquier índice que esté disponible en los puntos temporales. Por esta razón, la primera versión de las relaciones se usa típicamente para filtrar las tuplas con la ayuda de un índice al calcular las relaciones temporales como se muestra en la siguiente consulta.
				<programlisting>
SELECT tintersects(T.Trip, R.Geom)
FROM Trips T, Regions R
-- Filtro de índice con cuadro delimitador
WHERE intersects(T.Trip, R.Geom);
			</programlisting>
		</para>
	</sect1>

	<sect1 id="statistics_temporal_types">
		<title>Estadísticas y selectividad para tipos temporales</title>
		<sect2>
			<title>Colecta de estadísticas</title>
			<para>El planificador de PostgreSQL se basa en información estadística sobre el contenido de las tablas para generar el plan de ejecución más eficiente para las consultas. Estas estadísticas incluyen una lista de algunos de los valores más comunes en cada columna y un histograma que muestra la distribución aproximada de datos en cada columna. Para tablas grandes, se toma una muestra aleatoria del contenido de la tabla, en lugar de examinar cada fila. Esto permite analizar tablas grandes en poco tiempo. La información estadística es recopilada por el comando <varname>ANALYZE</varname> y es almacenada en la tabla de catálogo <varname>pg_statistic</varname>. Dado que diferentes tipos de estadísticas pueden ser apropiados para diferentes tipos de datos, la tabla sólo almacena estadísticas muy generales (como el número de valores nulos) en columnas dedicadas. Todo lo demás se almacena en cinco &ldquo;slots&rdquo;, que son pares de columnas de matriz que almacenan las estadísticas de una columna de un tipo arbitrario.</para>

			<para>Las estadísticas recopiladas para tipos de tiempo y tipos temporales se basan en las recopiladas por PostgreSQL para tipos escalares y tipos de rango. Para tipos escalares, como <varname>float</varname>, se recopilan las siguientes estadísticas: <orderedlist numeration="arabic">
					<listitem>
						<para>fracción de valores nulos,</para>
					</listitem>
					<listitem>
						<para>ancho promedio, en bytes, de valores no nulos,</para>
					</listitem>
					<listitem>
						<para>número de diferentes valores no nulos,</para>
					</listitem>
					<listitem>
						<para>matriz de los valores más comunes y matriz de sus frecuencias,</para>
					</listitem>
					<listitem>
						<para>histograma de valores, donde se excluyen los valores más comunes,</para>
					</listitem>
					<listitem>
						<para>correlación entre el orden de filas físico y lógico.</para>
					</listitem>
				</orderedlist>
			</para>

			<para>Para los tipos de rango, como <varname>tstzrange</varname>, se recopilan tres histogramas adicionales: <orderedlist continuation="continues" numeration="arabic">
					<listitem>
						<para>histograma de longitud de rangos no vacíos,</para>
					</listitem>
					<listitem>
						<para>histogramas de límites superior e inferior.</para>
					</listitem>
				</orderedlist>
			</para>

			<para>Para geometrías, además de (1)&#x2013;(3), se recopilan las siguientes estadísticas: <orderedlist continuation="continues" numeration="arabic">
						<listitem>
							<para>número de dimensiones de los valores, cuadro delimitador N-dimensional, número de filas en la tabla, número de filas en la muestra, número de valores no nulos,</para>
						</listitem>
						<listitem>
							<para>Histograma N-dimensional que divide el cuadro delimitador en varias celdas y mantiene la proporción de valores que se cruzan con cada celda.</para>
						</listitem>
					</orderedlist>
			</para>

			<para>Las estadísticas recopiladas para columnas de los nuevos tipos de tiempo <varname>timestampset</varname>, <varname>period</varname> y <varname>periodset</varname> replican las recopiladas por PostgreSQL para <varname>tstzrange</varname>. Esto es claro para el tipo <varname>period</varname>, que es equivalente a <varname>tszrange</varname>, excepto que los períodos no pueden estar vacíos. Para los tipos <varname>timestampset</varname> y <varname>periodset</varname>, un valor se convierte en su cuadro delimitador que es un <varname>period</varname> y luego se recopilan las estadísticas del tipo <varname>period</varname>.</para>

			<para>Las estadísticas recopiladas para columnas de los tipos temporales dependen del subtipo temporal y del tipo base. Además de las estadísticas (1)&#x2013;(3) que se recopilan para todos los tipos temporales, las estadísticas se recopilan para la dimensiónes de tiempo y de valor de forma independiente. Más precisamente, se recopilan las siguientes estadísticas para la dimensión de tiempo:
				<itemizedlist>
					<listitem>
						<para>Para columnas de subtipo instante, las estadísticas (4)&#x2013;(6) se recopilan para las marcas de tiempo.</para>
					</listitem>

					<listitem>
						<para>Para columnas de otro subtipo, las estadísticas (7)&#x2013;(8) se recopilan para los períodos delimitadores.</para>
					</listitem>
				</itemizedlist>
			</para>

			<para>Las siguientes estadísticas se recopilan para la dimensión de valores: <itemizedlist>
					<listitem>
						<para>Para columnas de tipos temporales con interpolación escalonada (es decir, <varname>tbool</varname>, <varname>ttext</varname> o <varname>tint</varname>): <itemizedlist>
								<listitem>
									<para>Para el subtipo instante, las estadísticas (4)&#x2013;(6) se recopilan para los valores.</para>
								</listitem>

								<listitem>
									<para>Para todas los demás subtipos, las estadísticas (7)&#x2013;(8) se recopilan para los valores.</para>
								</listitem>
							</itemizedlist>
						</para>
					</listitem>

					<listitem>
						<para>Para columnas de tipos temporales flotantes (es decir, <varname>tfloat</varname>): <itemizedlist>
								<listitem>
									<para>Para valores instantáneos, las estadísticas (4)&#x2013;(6) se recopilan para los valores.</para>
								</listitem>
								<listitem>
									<para>Para todas los demás subtipos, las estadísticas (7)&#x2013;(8) se recopilan por los rangos delimitadores de valores.</para>
								</listitem>
							</itemizedlist>
						</para>
					</listitem>

					<listitem>
						<para>Para columnas de tipos de puntos temporales (es decir, <varname>tgeompoint</varname> y <varname>tgeogpoint</varname>) las estadísticas (9)&#x2013;(10) se compilan para los puntos.</para>
					</listitem>
				</itemizedlist>
			</para>
		</sect2>

		<sect2>
			<title>Estimación de la selectividad de los operadores</title>
			<para>Los operadores booleanos en PostgreSQL se pueden asociar con dos funciones de selectividad, que calculan la probabilidad de que un valor de un tipo dado coincida con un criterio dado. Estas funciones de selectividad se basan en las estadísticas recopiladas. Hay dos tipos de funciones de selectividad. Las funciones de selectividad de <emphasis>restricción</emphasis> intentan estimar el porcentaje de filas en una tabla que satisfacen una condición en la cláusula <varname>WHERE</varname> de la forma <varname>column OP constant</varname>. Por otro lado, las funciones de selectividad de <emphasis>unión</emphasis> intentan estimar el porcentaje de filas en una tabla que satisfacen una condición en la cláusula <varname>WHERE</varname> de la forma <varname>table1.column1 OP table2.column2</varname>.</para>

			<para>MobilityDB define 23 clases de operadores booleanos (como<varname>=</varname>, <varname>&lt;</varname>, <varname>&amp;&amp;</varname>, <varname>&lt;&lt;</varname>, etc.), cada uno de los cuales puede tener como argumentos izquierdo o derecho un tipo PostgreSQL (como <varname>integer</varname>, <varname>timestamptz</varname>, etc.) o un nuevo tipo MobilityDB (como <varname>period</varname>, <varname>tintseq</varname>, etc.). Como consecuencia, existe un número muy elevado de operadores con diferentes argumentos a considerar para las funciones de selectividad. El enfoque adoptado fue agrupar estas combinaciones en clases correspondientes a las dimensiones de valor o de tiempo. Las clases corresponden al tipo de estadísticas recopiladas como se explica en la sección anterior.</para>

			<para>Actualmente, sólo están implementadas las funciones de selectividad de restricción para tipos temporales, mientras que las funciones de selectividad de unión dan un valor de selectividad predeterminado según el operador. Está previsto implementar las funciones de selectividad de unión en el futuro.</para>
		</sect2>
	</sect1>
</chapter>
