# SOME DESCRIPTIVE TITLE.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Esteban Zimanyi <estebanzimanyi@gmail.com>, 2020
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: https://bugs.kde.org\n"
"POT-Creation-Date: 2020-10-16 07:26+0000\n"
"PO-Revision-Date: 2020-10-16 07:31+0000\n"
"Last-Translator: Esteban Zimanyi <estebanzimanyi@gmail.com>, 2020\n"
"Language-Team: Spanish (https://www.transifex.com/mobilitydb/teams/114013/es/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: es\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#. Tag: title
#: manipulating_temporal_types.xml:3
#, no-c-format
msgid "Manipulating Temporal Types"
msgstr "Manipulación de tipos temporales"

#. Tag: para
#: manipulating_temporal_types.xml:4
#, no-c-format
msgid ""
"We present next the functions and operators for temporal types. These "
"functions and operators are polymorphic, that is, their arguments may be of "
"several types, and the result type may depend on the type of the arguments. "
"To express this, we use the following notation:"
msgstr ""
"A continuación presentamos las funciones y operadores para tipos temporales."
" Estas funciones y operadores son polimórficos, es decir, sus argumentos "
"pueden ser de varios tipos y el tipo de resultado puede depender del tipo de"
" los argumentos. Para expresar esto, usamos la siguiente notación:"

#. Tag: para
#: manipulating_temporal_types.xml:8
#, no-c-format
msgid "<varname>ttype</varname> represents any temporal type,"
msgstr "<varname>ttype</varname> representa cualquier tipo temporal,"

#. Tag: para
#: manipulating_temporal_types.xml:12
#, no-c-format
msgid ""
"<varname>time</varname> represents any time type, that is, "
"<varname>timestamptz</varname>, <varname>period</varname>, "
"<varname>timestampset</varname>, or <varname>periodset</varname>,"
msgstr ""
"<varname>time</varname> representa cualquier tipo de tiempo, es decir, "
"<varname>timestamptz</varname>, <varname>period</varname>, "
"<varname>timestampset</varname>, o <varname>periodset</varname>,"

#. Tag: para
#: manipulating_temporal_types.xml:16
#, no-c-format
msgid ""
"<varname>tnumber</varname> represents any temporal number type, that is, "
"<varname>tint</varname> or <varname>tfloat</varname>,"
msgstr ""
"<varname>tnumber</varname> representa cualquier tipo de número temporal, es "
"decir, <varname>tint</varname> o <varname>tfloat</varname>,"

#. Tag: para
#: manipulating_temporal_types.xml:20
#, no-c-format
msgid ""
"<varname>torder</varname> represents any temporal type whose base type has a"
" total order defined, that is, <varname>tint</varname>, "
"<varname>tfloat</varname>, or <varname>ttext</varname>,"
msgstr ""
"<varname>torder</varname> representa cualquier tipo temporal cuyo tipo de "
"base tiene definido un orden total, es decir, <varname>tint</varname>, "
"<varname>tfloat</varname>, or <varname>ttext</varname>,"

#. Tag: para
#: manipulating_temporal_types.xml:24
#, no-c-format
msgid ""
"<varname>tpoint</varname> represents a temporal point type, that is, "
"<varname>tgeompoint</varname> or <varname>tgeogpoint</varname>,"
msgstr ""
"<varname>tpoint</varname> representa un tipo de punto temporal, es decir, "
"<varname>tgeompoint</varname> o <varname>tgeogpoint</varname>,"

#. Tag: para
#: manipulating_temporal_types.xml:28
#, no-c-format
msgid ""
"<varname>ttypeinst</varname> represents any temporal type with instant "
"duration,"
msgstr ""
"<varname>ttypeinst</varname> representa cualquier tipo temporal con duración"
" instantánea,"

#. Tag: para
#: manipulating_temporal_types.xml:32
#, no-c-format
msgid ""
"<varname>ttypei</varname> represents any temporal type with instant set "
"duration,"
msgstr ""
"<varname>ttypei</varname> representa cualquier tipo temporal con duración "
"conjunto de instantes,"

#. Tag: para
#: manipulating_temporal_types.xml:36
#, no-c-format
msgid ""
"<varname>ttypeseq</varname> represents any temporal type with sequence "
"duration,"
msgstr ""
"<varname>ttypeseq</varname> representa cualquier tipo temporal con duración "
"de secuencia,"

#. Tag: para
#: manipulating_temporal_types.xml:40
#, no-c-format
msgid ""
"<varname>tdiscseq</varname> represents any temporal type with sequence "
"duration and a discrete base type,"
msgstr ""
"<varname>tdiscseq</varname> representa cualquier tipo temporal con duración "
"de secuencia y con tipo de base discreto,"

#. Tag: para
#: manipulating_temporal_types.xml:44
#, no-c-format
msgid ""
"<varname>tcontseq</varname> represents any temporal type with sequence "
"duration and a continuous base type,"
msgstr ""
"<varname>tcontseq</varname> representa cualquier tipo temporal con duración "
"de secuencia y con tipo de base contínuo,"

#. Tag: para
#: manipulating_temporal_types.xml:48
#, no-c-format
msgid ""
"<varname>ttypes</varname> represents any temporal type with sequence set "
"duration,"
msgstr ""
"<varname>ttypes</varname> representa cualquier tipo temporal con duración de"
" conjunto de secuencias"

#. Tag: para
#: manipulating_temporal_types.xml:52
#, no-c-format
msgid ""
"<varname>base</varname> represents any base type of a temporal type, that "
"is, <varname>bool</varname>, <varname>int</varname>, "
"<varname>float</varname>, <varname>text</varname>, "
"<varname>geometry</varname>, or <varname>geography</varname>,"
msgstr ""
"<varname>base</varname> representa cualquier tipo de base de un tipo "
"temporal, es decir, <varname>bool</varname>, <varname>int</varname>, "
"<varname>float</varname>, <varname>text</varname>, "
"<varname>geometry</varname>, o <varname>geography</varname>,"

#. Tag: para
#: manipulating_temporal_types.xml:56
#, no-c-format
msgid ""
"<varname>number</varname> represents any number base type, that is, "
"<varname>int</varname> or <varname>float</varname>,"
msgstr ""
"<varname>number</varname> representa cualquier tipo de base numérico, es "
"decir, <varname>int</varname> o <varname>float</varname>,"

#. Tag: para
#: manipulating_temporal_types.xml:60
#, no-c-format
msgid ""
"<varname>numrange</varname> represents any number range of values, that is, "
"either <varname>intrange</varname> or <varname>floatrange</varname>,"
msgstr ""
"<varname>numrange</varname> representa cualquier rango numérico de valores, "
"es decir, <varname>intrange</varname> o <varname>floatrange</varname>,"

#. Tag: para
#: manipulating_temporal_types.xml:64
#, no-c-format
msgid ""
"<varname>geo</varname> represents either <varname>geometry</varname> or "
"<varname>geography</varname>,"
msgstr ""
"<varname>geo</varname> representa  <varname>geometry</varname> o "
"<varname>geography</varname>,"

#. Tag: para
#: manipulating_temporal_types.xml:68
#, no-c-format
msgid ""
"<varname>point</varname> represents a <varname>geometry</varname> or a "
"<varname>geography</varname> restricted to a point."
msgstr ""
"<varname>point</varname> representa un <varname>geometry</varname> o un "
"<varname>geography</varname> restringido a un punto."

#. Tag: para
#: manipulating_temporal_types.xml:72
#, no-c-format
msgid ""
"<varname>type[]</varname> represents an array of <varname>type</varname>."
msgstr ""
"<varname>type[]</varname> representa una matriz de <varname>type</varname>."

#. Tag: para
#: manipulating_temporal_types.xml:76
#, no-c-format
msgid ""
"A common way to generalize the traditional operations to the temporal types "
"is to apply the operation at each instant, which yields a temporal value as "
"result. In that case, the operation is only defined on the intersection of "
"the emporal extents of the operands; if the temporal extents are disjoint, "
"then the result is null. For example, the temporal comparison operators, "
"such as <varname>#&lt;</varname>, test whether the values taken by their "
"operands at each instant satisfy the condition and return a temporal "
"Boolean. Examples of the various generalizations of the operators are given "
"next."
msgstr ""
"Una forma común de generalizar las operaciones tradicionales a los tipos "
"temporales es aplicar la operación en cada instante, lo que da en un valor "
"temporal como resultado. En ese caso, la operación solo se define en la "
"intersección de las extensiones temporales de los operandos; si las "
"extensiones temporales son disjuntas, el resultado es nulo. Por ejemplo, los"
" operadores de comparación temporal, como <varname>#&lt;</varname>, "
"determinan si los valores tomados por sus operandos en cada instante "
"satisfacen la condición y devuelven un booleano temporal. A continuación se "
"dan ejemplos de las diversas generalizaciones de los operadores."

#. Tag: programlisting
#: manipulating_temporal_types.xml:77
#, no-c-format
msgid ""
"-- Temporal comparison\n"
"SELECT tint '[2@2001-01-01, 2@2001-01-03)' #&lt; tfloat '[1@2001-01-01, 3@2001-01-03)';\n"
"-- \"{[f@2001-01-01, f@2001-01-02], (t@2001-01-02, t@2001-01-03)}\"\n"
"SELECT tfloat '[1@2001-01-01, 3@2001-01-03)' #&lt; tfloat '[3@2001-01-03, 1@2001-01-05)';\n"
"-- NULL\n"
"-- Temporal addition\n"
"SELECT tint '[1@2001-01-01, 1@2001-01-03)' + tint '[2@2001-01-02, 2@2001-01-05)';\n"
"-- \"[3@2001-01-02, 3@2001-01-03)\"\n"
"-- Temporal intersects\n"
"SELECT tintersects(tgeompoint '[Point(0 1)@2001-01-01, Point(3 1)@2001-01-04)',\n"
"geometry 'Polygon((1 0,1 2,2 2,2 0,1 0))');\n"
"-- \"{[f@2001-01-01, t@2001-01-02, t@2001-01-03], (f@2001-01-03, f@2001-01-04]}\"\n"
"-- Temporal distance\n"
"SELECT tgeompoint '[Point(0 0)@2001-01-01 08:00:00, Point(0 1)@2001-01-03 08:10:00)' &lt;-&gt;\n"
"tgeompoint '[Point(0 0)@2001-01-02 08:05:00, Point(1 1)@2001-01-05 08:15:00)';\n"
"-- \"[0.5@2001-01-02 08:05:00+00, 0.745184033794557@2001-01-03 08:10:00+00)\""
msgstr ""
"-- Comparación temporal\n"
"SELECT tint '[2@2001-01-01, 2@2001-01-03)' #&lt; tfloat '[1@2001-01-01, 3@2001-01-03)';\n"
"-- \"{[f@2001-01-01, f@2001-01-02], (t@2001-01-02, t@2001-01-03)}\"\n"
"SELECT tfloat '[1@2001-01-01, 3@2001-01-03)' #&lt; tfloat '[3@2001-01-03, 1@2001-01-05)';\n"
"-- NULL\n"
"-- Adición temporal\n"
"SELECT tint '[1@2001-01-01, 1@2001-01-03)' + tint '[2@2001-01-02, 2@2001-01-05)';\n"
"-- \"[3@2001-01-02, 3@2001-01-03)\"\n"
"-- Intersección temporal\n"
"SELECT tintersects(tgeompoint '[Point(0 1)@2001-01-01, Point(3 1)@2001-01-04)',\n"
"geometry 'Polygon((1 0,1 2,2 2,2 0,1 0))');\n"
"-- \"{[f@2001-01-01, t@2001-01-02, t@2001-01-03], (f@2001-01-03, f@2001-01-04]}\"\n"
"-- Distancia temporal\n"
"SELECT tgeompoint '[Point(0 0)@2001-01-01 08:00:00, Point(0 1)@2001-01-03 08:10:00)' &lt;-&gt;\n"
"tgeompoint '[Point(0 0)@2001-01-02 08:05:00, Point(1 1)@2001-01-05 08:15:00)';\n"
"-- \"[0.5@2001-01-02 08:05:00+00, 0.745184033794557@2001-01-03 08:10:00+00)\""

#. Tag: para
#: manipulating_temporal_types.xml:80
#, no-c-format
msgid ""
"Another common requirement is to determine whether the operands ever or always satisfy a condition with respect to an operation. These can be obtained by applying the ever/always comparison operators. These operators are denoted by prefixing the traditional comparison operators with, respectively, <varname>?</varname> (ever) and <varname>%</varname> (always). Examples of ever and always comparison operators are given next. <programlisting>\n"
"-- Does the operands ever intersect?\n"
"SELECT tintersects(tgeompoint '[Point(0 1)@2001-01-01, Point(3 1)@2001-01-04)',\n"
"geometry 'Polygon((1 0,1 2,2 2,2 0,1 0))') ?= true;\n"
"-- true\n"
"-- Does the operands always intersect?\n"
"SELECT tintersects(tgeompoint '[Point(0 1)@2001-01-01, Point(3 1)@2001-01-04)',\n"
"geometry 'Polygon((0 0,0 2,4 2,4 0,0 0))') %= true;\n"
"-- true\n"
"-- Is the left operand ever less than the right one ?\n"
"SELECT (tfloat '[1@2001-01-01, 3@2001-01-03)' #&lt;\n"
"tfloat '[3@2001-01-01, 1@2001-01-03)') ?= true;\n"
"-- true\n"
"-- Is the left operand always less than the right one ?\n"
"SELECT (tfloat '[1@2001-01-01, 3@2001-01-03)' #&lt;\n"
"tfloat '[2@2001-01-01, 4@2001-01-03)') %= true;\n"
"-- true\n"
"                </programlisting> For efficiency reasons, some common operations with the ever or the always semantics are natively provided. For example, the <varname>intersects</varname> function determines whether there is an instant at which the two arguments spatially intersect."
msgstr ""
"Otro requisito común es determinar si los operandos satisfacen alguna vez o siempre una condición con respecto a una operación. Estos se pueden obtener aplicando los operadores de comparación alguna vez/ siempre. Estos operadores se indican anteponiendo los operadores de comparación tradicionales con, respectivamente, <varname>?</varname> (alguna vez) y <varname>%</varname> (siempre). A continuación se dan ejemplos de operadores de comparación alguna vez y siempre.<programlisting>\n"
"-- ¿Los operandos se cruzan alguna vez?\n"
"SELECT tintersects(tgeompoint '[Point(0 1)@2001-01-01, Point(3 1)@2001-01-04)',\n"
"geometry 'Polygon((1 0,1 2,2 2,2 0,1 0))') ?= true;\n"
"-- true\n"
"-- ¿Los operandos siempre se cruzan?\n"
"SELECT tintersects(tgeompoint '[Point(0 1)@2001-01-01, Point(3 1)@2001-01-04)',\n"
"geometry 'Polygon((0 0,0 2,4 2,4 0,0 0))') %= true;\n"
"-- true\n"
"-- ¿Es el operando izquierdo alguna vez menor que el derecho?\n"
"SELECT (tfloat '[1@2001-01-01, 3@2001-01-03)' #&lt;\n"
"tfloat '[3@2001-01-01, 1@2001-01-03)') ?= true;\n"
"-- true\n"
"-- ¿El operando izquierdo es siempre menor que el derecho?\n"
"SELECT (tfloat '[1@2001-01-01, 3@2001-01-03)' #&lt;\n"
"tfloat '[2@2001-01-01, 4@2001-01-03)') %= true;\n"
"-- true\n"
"                </programlisting> Por razones de eficiencia, algunas operaciones comunes con la semántica aguna vez o siempre se proporcionan de forma nativa. Por ejemplo, la función <varname>intersects</varname> determina si hay un instante en el que los dos argumentos se cruzan espacialmente."

#. Tag: para
#: manipulating_temporal_types.xml:84
#, no-c-format
msgid ""
"We describe next the functions and operators for temporal types. For "
"conciseness, in the examples we mostly use sequences composed of two "
"instants."
msgstr ""
"A continuación describimos las funciones y operadores para tipos temporales."
" Para mayor concisión, en los ejemplos usamos principalmente secuencias "
"compuestas por dos instantes."

#. Tag: title
#: manipulating_temporal_types.xml:87
#, no-c-format
msgid "Input/Output of Temporal Types"
msgstr "Entrada/salida de tipos temporales"

#. Tag: para
#: manipulating_temporal_types.xml:88
#, no-c-format
msgid ""
"A temporal instant value is a couple of the form <varname>v@t</varname>, "
"where <varname>v</varname> is a value of the base type and "
"<varname>t</varname> is a <varname>timestamptz</varname> value. A temporal "
"sequence value is a set of values <varname>v1@t1,...,vn@tn</varname> "
"delimited by a lower and an upper bounds that can be inclusive (represented "
"by &lsquo;<varname>[</varname>' and &lsquo;<varname>]</varname>') or "
"exclusive (represented by &lsquo;<varname>(</varname>' and "
"&lsquo;<varname>)</varname>'). Examples of input of temporal unit values are"
" as follows:"
msgstr ""
"Un valor instantáneo temporal es un par de la forma <varname>v@t</varname>, "
"donde <varname>v</varname> es un valor del tipo de base y "
"<varname>t</varname> es un valor de <varname>timestamptz</varname>. Un valor"
" de secuencia temporal es un conjunto de "
"valores<varname>v1@t1,...,vn@tn</varname> delimitado por un límite superior "
"e inferior que puede ser inclusivo (representado por "
"&lsquo;<varname>[</varname>' y &lsquo;<varname>]</varname>') o exclusivo "
"(representado por &lsquo;<varname>(</varname>' y "
"&lsquo;<varname>)</varname>'). Ejemplos de entrada de valores unitarios "
"temporales son los siguientes:"

#. Tag: programlisting
#: manipulating_temporal_types.xml:89
#, no-c-format
msgid ""
"SELECT tbool 'true@2001-01-01 08:00:00';\n"
"SELECT tint '1@2001-01-01 08:00:00';\n"
"SELECT tfloat '1.5@2001-01-01 08:00:00';\n"
"SELECT ttext 'AAA@2001-01-01 08:00:00';\n"
"SELECT tgeompoint 'Point(0 0)@2017-01-01 08:00:05';\n"
"SELECT tgeogpoint 'Point(0 0)@2017-01-01 08:00:05';\n"
"SELECT tbool '[true@2001-01-01 08:00:00, true@2001-01-03 08:00:00]';\n"
"SELECT tint '[1@2001-01-01 08:00:00, 1@2001-01-03 08:00:00]';\n"
"SELECT tfloat '[2.5@2001-01-01 08:00:00, 3@2001-01-03 08:00:00, 1@2001-01-04 08:00:00]';\n"
"SELECT tfloat '[1.5@2001-01-01 08:00:00]';  -- Instant sequence\n"
"SELECT ttext '[BBB@2001-01-01 08:00:00, BBB@2001-01-03 08:00:00]';\n"
"SELECT tgeompoint '[Point(0 0)@2017-01-01 08:00:00, Point(0 0)@2017-01-01 08:05:00)';\n"
"SELECT tgeogpoint '[Point(0 0)@2017-01-01 08:00:00, Point(0 1)@2017-01-01 08:05:00,\n"
"Point(0 0)@2017-01-01 08:10:00)';"
msgstr ""
"SELECT tbool 'true@2001-01-01 08:00:00';\n"
"SELECT tint '1@2001-01-01 08:00:00';\n"
"SELECT tfloat '1.5@2001-01-01 08:00:00';\n"
"SELECT ttext 'AAA@2001-01-01 08:00:00';\n"
"SELECT tgeompoint 'Point(0 0)@2017-01-01 08:00:05';\n"
"SELECT tgeogpoint 'Point(0 0)@2017-01-01 08:00:05';\n"
"SELECT tbool '[true@2001-01-01 08:00:00, true@2001-01-03 08:00:00]';\n"
"SELECT tint '[1@2001-01-01 08:00:00, 1@2001-01-03 08:00:00]';\n"
"SELECT tfloat '[2.5@2001-01-01 08:00:00, 3@2001-01-03 08:00:00, 1@2001-01-04 08:00:00]';\n"
"SELECT tfloat '[1.5@2001-01-01 08:00:00]';  -- Instant sequence\n"
"SELECT ttext '[BBB@2001-01-01 08:00:00, BBB@2001-01-03 08:00:00]';\n"
"SELECT tgeompoint '[Point(0 0)@2017-01-01 08:00:00, Point(0 0)@2017-01-01 08:05:00)';\n"
"SELECT tgeogpoint '[Point(0 0)@2017-01-01 08:00:00, Point(0 1)@2017-01-01 08:05:00,\n"
"Point(0 0)@2017-01-01 08:10:00)';"

#. Tag: para
#: manipulating_temporal_types.xml:92
#, no-c-format
msgid ""
"The temporal extent of a temporal instant value is a single instant while "
"the temporal extent of temporal sequence value is a period defined by the "
"first and last instants as well as the upper and lower bounds."
msgstr ""
"La extensión temporal de un valor instantáneo temporal es un solo instante, "
"mientras que la extensión temporal de un valor de secuencia temporal es un "
"período definido por el primer y último instantes, así como por los límites "
"superior e inferior."

#. Tag: para
#: manipulating_temporal_types.xml:94
#, no-c-format
msgid ""
"A temporal set value is a set <varname>{v1,...,vn}</varname> where every <varname>vi</varname> is a temporal unit value of the corresponding type. Examples of input of temporal set values are as follows: <programlisting>\n"
"SELECT tbool '{true@2001-01-01 08:00:00, false@2001-01-03 08:00:00}';\n"
"SELECT tint '{1@2001-01-01 08:00:00, 2@2001-01-03 08:00:00}';\n"
"SELECT tfloat '{1.0@2001-01-01 08:00:00, 2.0@2001-01-03 08:00:00}';\n"
"SELECT ttext '{AAA@2001-01-01 08:00:00, BBB@2001-01-03 08:00:00}';\n"
"SELECT tgeompoint '{Point(0 0)@2017-01-01 08:00:00, Point(0 1)@2017-01-02 08:05:00}';\n"
"SELECT tgeogpoint '{Point(0 0)@2017-01-01 08:00:00, Point(0 1)@2017-01-02 08:05:00}';\n"
"SELECT tbool '{[false@2001-01-01 08:00:00, false@2001-01-03 08:00:00),\n"
"[true@2001-01-03 08:00:00], (false@2001-01-04 08:00:00, false@2001-01-06 08:00:00]}';\n"
"SELECT tint '{[1@2001-01-01 08:00:00, 1@2001-01-03 08:00:00),\n"
"[2@2001-01-04 08:00:00, 3@2001-01-05 08:00:00, 3@2001-01-06 08:00:00]}';\n"
"SELECT tfloat '{[1@2001-01-01 08:00:00, 2@2001-01-03 08:00:00, 2@2001-01-04 08:00:00,\n"
"3@2001-01-06 08:00:00]}';\n"
"SELECT ttext '{[AAA@2001-01-01 08:00:00, BBB@2001-01-03 08:00:00, BBB@2001-01-04 08:00:00),\n"
"[CCC@2001-01-05 08:00:00, CCC@2001-01-06 08:00:00]}';\n"
"SELECT tgeompoint '{[Point(0 0)@2017-01-01 08:00:00, Point(0 1)@2017-01-01 08:05:00),\n"
"[Point(0 1)@2017-01-01 08:10:00, Point(1 1)@2017-01-01 08:15:00)}';\n"
"SELECT tgeogpoint '{[Point(0 0)@2017-01-01 08:00:00, Point(0 1)@2017-01-01 08:05:00),\n"
"[Point(0 1)@2017-01-01 08:10:00, Point(1 1)@2017-01-01 08:15:00)}';\n"
"                        </programlisting> The temporal extent of a temporal instant set value is a set of instants while the temporal extent of temporal sequence set value is a set of periods."
msgstr ""
"Un valor de conjunto temporal es un conjunto <varname>{v1,...,vn}</varname> donce cada <varname>vi</varname> es un valor unitario temporal del tipo correspondiente. Ejemplos de entrada de valores de conjuntos temporales son los siguientes: <programlisting>\n"
"SELECT tbool '{true@2001-01-01 08:00:00, false@2001-01-03 08:00:00}';\n"
"SELECT tint '{1@2001-01-01 08:00:00, 2@2001-01-03 08:00:00}';\n"
"SELECT tfloat '{1.0@2001-01-01 08:00:00, 2.0@2001-01-03 08:00:00}';\n"
"SELECT ttext '{AAA@2001-01-01 08:00:00, BBB@2001-01-03 08:00:00}';\n"
"SELECT tgeompoint '{Point(0 0)@2017-01-01 08:00:00, Point(0 1)@2017-01-02 08:05:00}';\n"
"SELECT tgeogpoint '{Point(0 0)@2017-01-01 08:00:00, Point(0 1)@2017-01-02 08:05:00}';\n"
"SELECT tbool '{[false@2001-01-01 08:00:00, false@2001-01-03 08:00:00),\n"
"[true@2001-01-03 08:00:00], (false@2001-01-04 08:00:00, false@2001-01-06 08:00:00]}';\n"
"SELECT tint '{[1@2001-01-01 08:00:00, 1@2001-01-03 08:00:00),\n"
"[2@2001-01-04 08:00:00, 3@2001-01-05 08:00:00, 3@2001-01-06 08:00:00]}';\n"
"SELECT tfloat '{[1@2001-01-01 08:00:00, 2@2001-01-03 08:00:00, 2@2001-01-04 08:00:00,\n"
"3@2001-01-06 08:00:00]}';\n"
"SELECT ttext '{[AAA@2001-01-01 08:00:00, BBB@2001-01-03 08:00:00, BBB@2001-01-04 08:00:00),\n"
"[CCC@2001-01-05 08:00:00, CCC@2001-01-06 08:00:00]}';\n"
"SELECT tgeompoint '{[Point(0 0)@2017-01-01 08:00:00, Point(0 1)@2017-01-01 08:05:00),\n"
"[Point(0 1)@2017-01-01 08:10:00, Point(1 1)@2017-01-01 08:15:00)}';\n"
"SELECT tgeogpoint '{[Point(0 0)@2017-01-01 08:00:00, Point(0 1)@2017-01-01 08:05:00),\n"
"[Point(0 1)@2017-01-01 08:10:00, Point(1 1)@2017-01-01 08:15:00)}';\n"
"                        </programlisting> La extensión temporal de un valor de conjunto instantáneo temporal es un conjunto de instantes, mientras que la extensión temporal de un valor de conjunto de secuencias temporales es un conjunto de períodos."

#. Tag: para
#: manipulating_temporal_types.xml:98
#, no-c-format
msgid ""
"Temporal values of sequence or sequence set duration whose base type is continuous may specify that the interpolation is stepwise. If this is not specified, it is supposed that the interpolation is linear by default. <programlisting>\n"
"-- Linear interpolation by default\n"
"SELECT tfloat '[2.5@2001-01-01, 3@2001-01-03, 1@2001-01-04]';\n"
"SELECT tgeompoint '{[Point(2.5 2.5)@2001-01-01, Point(3 3)@2001-01-03],\n"
"[Point(1 1)@2001-01-04, Point(1 1)@2001-01-04]}';\n"
"-- Stepwise interpolation\n"
"SELECT tfloat 'Interp=Stepwise;[2.5@2001-01-01, 3@2001-01-03, 1@2001-01-04]';\n"
"SELECT tgeompoint 'Interp=Stepwise;{[Point(2.5 2.5)@2001-01-01, Point(3 3)@2001-01-03],\n"
"[Point(1 1)@2001-01-04, Point(1 1)@2001-01-04]}';\n"
"                        </programlisting> For temporal values of sequence set duration all component sequences are supposed to be in the same interpolation, either stepwise or linear, as in the examples above."
msgstr ""
"Los valores temporales de duración secuencia o conjunto de secuencias cuyo tipo de base es continuo pueden especificar que la interpolación es escalonada. Si no se especifica, se supone que la interpolación es lineal por defecto. <programlisting>\n"
"-- Interpolación lineal por defecto\n"
"SELECT tfloat '[2.5@2001-01-01, 3@2001-01-03, 1@2001-01-04]';\n"
"SELECT tgeompoint '{[Point(2.5 2.5)@2001-01-01, Point(3 3)@2001-01-03],\n"
"[Point(1 1)@2001-01-04, Point(1 1)@2001-01-04]}';\n"
"-- Interpolación escalonada\n"
"SELECT tfloat 'Interp=Stepwise;[2.5@2001-01-01, 3@2001-01-03, 1@2001-01-04]';\n"
"SELECT tgeompoint 'Interp=Stepwise;{[Point(2.5 2.5)@2001-01-01, Point(3 3)@2001-01-03],\n"
"[Point(1 1)@2001-01-04, Point(1 1)@2001-01-04]}';\n"
"                        </programlisting> Para los valores temporales de duración conjunto de secuencias se supone que todas las secuencias componentes tienen la misma interpolación, ya sea por escalonada o lineal, como en los ejemplos anteriores."

#. Tag: para
#: manipulating_temporal_types.xml:103
#, no-c-format
msgid ""
"For temporal points, it is possible to specify the spatial reference identifier (SRID) using the Extended Well-Known text (EWKT) representation as follows: <programlisting>\n"
"SELECT tgeompoint 'SRID=5435;[Point(0 0)@2000-01-01,Point(0 1)@2000-01-02]'\n"
"                        </programlisting> All components geometries will then be of the given SRID. Furthermore, each component geometry can specify its SRID with the EWKT format as in the following example <programlisting>\n"
"SELECT tgeompoint '[SRID=5435;Point(0 0)@2000-01-01,SRID=5435;Point(0 1)@2000-01-02]'\n"
"                        </programlisting> An error is raised if the component geometries are not all in the same SRID or if the SRID of a component geometry is different from the one of the temporal point"
msgstr ""
"Para los puntos temporales, es posible especificar el identificador de referencia espacial (SRID) utilizando la representación de texto extendido conocido (EWKT) de la siguiente manera: <programlisting>\n"
"SELECT tgeompoint 'SRID=5435;[Point(0 0)@2000-01-01,Point(0 1)@2000-01-02]'\n"
"                        </programlisting> Todas las geometrías de los componentes serán entonces del SRID dado. Además, cada geometría de componente puede especificar su SRID con el formato EWKT como en el siguiente ejemplo<programlisting>\n"
"SELECT tgeompoint '[SRID=5435;Point(0 0)@2000-01-01,SRID=5435;Point(0 1)@2000-01-02]'\n"
"                        </programlisting> Se genera un error si las geometrías del componente no están todas en el mismo SRID o si el SRID de la geometría de un componente es diferente al del punto temporal."

#. Tag: programlisting
#: manipulating_temporal_types.xml:108
#, no-c-format
msgid ""
"SELECT tgeompoint '[SRID=5435;Point(0 0)@2000-01-01,SRID=4326;Point(0 1)@2000-01-02]';\n"
"ERROR: Geometry SRID (4326) does not match temporal type SRID (5435)\n"
"SELECT tgeompoint 'SRID=5435;[SRID=4326;Point(0 0)@2000-01-01,\n"
"SRID=4326;Point(0 1)@2000-01-02]'\n"
"ERROR: Geometry SRID (4326) does not match temporal type SRID (5435)"
msgstr ""
"SELECT tgeompoint '[SRID=5435;Point(0 0)@2000-01-01,SRID=4326;Point(0 1)@2000-01-02]';\n"
"ERROR: Geometry SRID (4326) does not match temporal type SRID (5435)\n"
"SELECT tgeompoint 'SRID=5435;[SRID=4326;Point(0 0)@2000-01-01,\n"
"SRID=4326;Point(0 1)@2000-01-02]'\n"
"ERROR: Geometry SRID (4326) does not match temporal type SRID (5435)"

#. Tag: title
#: manipulating_temporal_types.xml:113
#, no-c-format
msgid "Constructor Functions"
msgstr "Funciones de constructor"

#. Tag: para
#: manipulating_temporal_types.xml:115
#, no-c-format
msgid ""
"Each temporal type has constructor functions with the same name as the type "
"and with a suffix for the duration, where the suffix "
"&lsquo;<varname>inst</varname>&rsquo;, &lsquo;<varname>i</varname>&rsquo;, "
"&lsquo;<varname>seq</varname>&rsquo;, and &lsquo;<varname>s</varname>&rsquo;"
" correspond, respectively, to the durations instant, instant set, sequence, "
"and sequence set. Examples are <varname>tintseq</varname> or "
"<varname>tgeompoints</varname>. Using the constructor function is frequently"
" more convenient than writing a literal constant."
msgstr ""
"Cada tipo temporal tiene funciones constructoras con el mismo nombre que el "
"tipo y con un sufijo para la duración, donde el sufijo "
"&lsquo;<varname>inst</varname>&rsquo;, &lsquo;<varname>i</varname>&rsquo;, "
"&lsquo;<varname>seq</varname>&rsquo;, y &lsquo;<varname>s</varname>&rsquo; "
"corresponden, respectivamente, a las duraciones instante, conjunto de "
"instantes, secuencia, y conjunto de secuencias. Ejemplos son "
"<varname>tintseq</varname> o <varname>tgeompoints</varname>. El uso de la "
"función constructora suele ser más conveniente que escribir una constante "
"literal."

#. Tag: para
#: manipulating_temporal_types.xml:120
#, no-c-format
msgid ""
"A first set of constructor functions have two arguments, a base type and a "
"time type, where the latter is a <varname>timestamptz</varname>, a "
"<varname>timestampset</varname>, a <varname>period</varname>, or a "
"<varname>periodset</varname> value for constructing, respectively, a "
"temporal instant, instant set, sequence, or sequence set value. The "
"constructors for temporal sequence or sequence set values with continuous "
"base type have in addition an optional third argument which is a Boolean for"
" stating whether the resulting temporal value has linear interpolation or "
"not. By default this argument is true if it is not specified."
msgstr ""
"Un primer conjunto de funciones constructoras tiene dos argumentos, un tipo "
"base y un tipo de tiempo, donde el último es un valor "
"<varname>timestamptz</varname>, <varname>timestampset</varname>, "
"<varname>period</varname>, o <varname>periodset</varname> para construir, "
"respectivamente, un valor temporal de duración instante, conjunto de "
"instantantes, secuencia o conjunto de secuencias. Los constructores para "
"valores temporales de secuencia o de conjunto de secuencias con tipo base "
"continuo tienen además un tercer argumento opcional que es un booleano para "
"indicar si el valor temporal resultante tiene interpolación lineal o no. Por"
" defecto, este argumento es verdadero si no se especifica."

#. Tag: para
#: manipulating_temporal_types.xml:124
#, no-c-format
msgid ""
"Another set of constructor functions for temporal instant set values have a "
"single argument, which is an array of values of the corresponding instant "
"values."
msgstr ""
"Otro conjunto de funciones constructoras para valores temporales de conjunto"
" de instantes tiene un solo argumento, que es una matriz de valores de los "
"valores instantáneos correspondientes."

#. Tag: para
#: manipulating_temporal_types.xml:128
#, no-c-format
msgid ""
"Another set of constructor functions for temporal sequence values have one "
"argument for the array of values of the corresponding instant duration and "
"two optional Boolean arguments stating, respectively, whether the left and "
"right bounds are inclusive or exclusive. It the these arguments are not "
"specified they are assumed to be true by default. In addition, the "
"constructor functions for temporal sequence values with continuous base type"
" have an additional Boolean argument stating whether the interpolation is "
"linear or not. It this argument is not specified it is assumed to be true by"
" default."
msgstr ""
"Otro conjunto de funciones constructoras para valores temporal de secuencia "
"tiene un argumento para la matriz de valores de la duración instantánea "
"correspondiente y dos argumentos booleanos opcionales que indican, "
"respectivamente, si los límites izquierdo y derecho son inclusivos o "
"exclusivos. Si estos argumentos no se especifican, se supone que son "
"verdaderos por defecto. Además, las funciones de constructor para valores de"
" secuencia temporal con tipo base continuo tienen un argumento booleano "
"adicional que indica si la interpolación es lineal o no. Si este argumento "
"no se especifica, se asume que es verdadero por defecto."

#. Tag: para
#: manipulating_temporal_types.xml:132
#, no-c-format
msgid ""
"Another set of constructor functions for temporal sequence set values have a"
" single argument, which is an array of values of the corresponding sequence "
"values. For temporal sequence values with continuous base type, the "
"interpolation of the resulting temporal value depends on the interpolation "
"of the composing sequences. An error is raised if the sequences composing "
"the array have different interpolation."
msgstr ""
"Otro conjunto de funciones constructoras para valores de conjuntos de "
"secuencias temporales tiene un único argumento, que es una matriz de valores"
" de los valores de secuencia correspondientes. Para valores de secuencia "
"temporal con tipo de base continuo, la interpolación del valor temporal "
"resultante depende de la interpolación de las secuencias que la componen. Se"
" genera un error si las secuencias que componen la matriz tienen una "
"interpolación diferente."

#. Tag: para
#: manipulating_temporal_types.xml:136
#, no-c-format
msgid "We give next the constructor functions for the various durations."
msgstr ""
"A continuación, damos las funciones constructoras para las distintas "
"duraciones."

#. Tag: varname
#: manipulating_temporal_types.xml:140 manipulating_temporal_types.xml:236
#, no-c-format
msgid "ttypeinst"
msgstr "ttypeinst"

#. Tag: para
#: manipulating_temporal_types.xml:141
#, no-c-format
msgid "Constructor for temporal types of instant duration"
msgstr "Constructor para tipos temporales de duración instantánea"

#. Tag: varname
#: manipulating_temporal_types.xml:142
#, no-c-format
msgid "ttypeinst(base, timestamptz): ttypeinst"
msgstr "ttypeinst(base, timestamptz): ttypeinst"

#. Tag: programlisting
#: manipulating_temporal_types.xml:143
#, no-c-format
msgid ""
"SELECT tboolinst(true, '2001-01-01');\n"
"SELECT tfloatinst(1.5, '2001-01-01');\n"
"SELECT tgeompointinst('Point(0 0)', '2001-01-01');"
msgstr ""
"SELECT tboolinst(true, '2001-01-01');\n"
"SELECT tfloatinst(1.5, '2001-01-01');\n"
"SELECT tgeompointinst('Point(0 0)', '2001-01-01');"

#. Tag: varname
#: manipulating_temporal_types.xml:147 manipulating_temporal_types.xml:237
#, no-c-format
msgid "ttypei"
msgstr "ttypei"

#. Tag: para
#: manipulating_temporal_types.xml:148
#, no-c-format
msgid "Constructor for temporal types of instant set duration"
msgstr "Constructor para tipos temporales de duración conjunto de instantes"

#. Tag: varname
#: manipulating_temporal_types.xml:149
#, no-c-format
msgid "ttypei(base, timestampset): ttypei"
msgstr "ttypei(base, timestampset): ttypei"

#. Tag: varname
#: manipulating_temporal_types.xml:150
#, no-c-format
msgid "ttypei(ttypeinst[]]): ttypei"
msgstr "ttypei(ttypeinst[]]): ttypei"

#. Tag: programlisting
#: manipulating_temporal_types.xml:151
#, no-c-format
msgid ""
"SELECT tinti(2, '{2001-01-01, 2001-01-02, 2001-01-03}');\n"
"SELECT tgeompointi('Point(0 0)', '{2001-01-01, 2001-01-02}');\n"
"SELECT tbooli(ARRAY[tbool 'true@2001-01-01 08:00:00', 'false@2001-01-01 08:05:00']);\n"
"SELECT tinti(ARRAY[tint '1@2001-01-01 08:00:00', '2@2001-01-01 08:05:00']);\n"
"SELECT tfloati(ARRAY[tfloat '1.0@2001-01-01 08:00:00', '2.0@2001-01-01 08:05:00']);\n"
"SELECT ttexti(ARRAY[ttext 'AAA@2001-01-01 08:00:00', 'BBB@2001-01-01 08:05:00']);\n"
"SELECT tgeompointi(ARRAY[tgeompoint 'Point(0 0)@2001-01-01 08:00:00',\n"
"'Point(0 1)@2001-01-01 08:05:00', 'Point(1 1)@2001-01-01 08:10:00']);\n"
"SELECT tgeogpointi(ARRAY[tgeogpoint 'Point(1 1)@2001-01-01 08:00:00',\n"
"'Point(2 2)@2001-01-01 08:05:00']);"
msgstr ""
"SELECT tinti(2, '{2001-01-01, 2001-01-02, 2001-01-03}');\n"
"SELECT tgeompointi('Point(0 0)', '{2001-01-01, 2001-01-02}');\n"
"SELECT tbooli(ARRAY[tbool 'true@2001-01-01 08:00:00', 'false@2001-01-01 08:05:00']);\n"
"SELECT tinti(ARRAY[tint '1@2001-01-01 08:00:00', '2@2001-01-01 08:05:00']);\n"
"SELECT tfloati(ARRAY[tfloat '1.0@2001-01-01 08:00:00', '2.0@2001-01-01 08:05:00']);\n"
"SELECT ttexti(ARRAY[ttext 'AAA@2001-01-01 08:00:00', 'BBB@2001-01-01 08:05:00']);\n"
"SELECT tgeompointi(ARRAY[tgeompoint 'Point(0 0)@2001-01-01 08:00:00',\n"
"'Point(0 1)@2001-01-01 08:05:00', 'Point(1 1)@2001-01-01 08:10:00']);\n"
"SELECT tgeogpointi(ARRAY[tgeogpoint 'Point(1 1)@2001-01-01 08:00:00',\n"
"'Point(2 2)@2001-01-01 08:05:00']);"

#. Tag: varname
#: manipulating_temporal_types.xml:155 manipulating_temporal_types.xml:238
#, no-c-format
msgid "ttypeseq"
msgstr "ttypeseq"

#. Tag: para
#: manipulating_temporal_types.xml:156
#, no-c-format
msgid "Constructor for temporal types of sequence duration"
msgstr "Constructor para tipos temporales de duración secuencia"

#. Tag: varname
#: manipulating_temporal_types.xml:157
#, no-c-format
msgid "tdiscseq(base, period): tdiscseq"
msgstr "tdiscseq(base, period): tdiscseq"

#. Tag: varname
#: manipulating_temporal_types.xml:158
#, no-c-format
msgid "tdiscseq(ttypeinst[], left_inc = true, right_inc = true}): tdiscseq"
msgstr "tdiscseq(ttypeinst[], left_inc = true, right_inc = true}): tdiscseq"

#. Tag: varname
#: manipulating_temporal_types.xml:159
#, no-c-format
msgid "tcontseq(base, period, linear = true): tcontseq"
msgstr "tcontseq(base, period, linear = true): tcontseq"

#. Tag: varname
#: manipulating_temporal_types.xml:160
#, no-c-format
msgid ""
"tcontseq(ttypeinst[], left_inc = true, right_inc = true, linear = true}): "
"tcontseq"
msgstr ""
"tcontseq(ttypeinst[], left_inc = true, right_inc = true, linear = true}): "
"tcontseq"

#. Tag: programlisting
#: manipulating_temporal_types.xml:161
#, no-c-format
msgid ""
"SELECT tfloatseq(1.5, '[2001-01-01, 2001-01-02]');\n"
"SELECT tfloatseq(2.0, '[2001-01-01, 2001-01-02]', false);\n"
"SELECT tboolseq(ARRAY[tbool 'true@2001-01-01 08:00:00', 'true@2001-01-03 08:05:00'],\n"
"true, true);\n"
"SELECT tintseq(ARRAY[tintinst(2,'2001-01-01 08:00:00'),\n"
"tintinst(2,'2001-01-01 08:10:00')], true, false);\n"
"SELECT tfloatseq(ARRAY[tfloat '2.0@2001-01-01 08:00:00', '3@2001-01-03 08:05:00',\n"
"'1@2001-01-03 08:10:00'], true, false);\n"
"SELECT tfloatseq(ARRAY[tfloat '2.0@2001-01-01 08:00:00', '3@2001-01-03 08:05:00',\n"
"'1@2001-01-03 08:10:00'], true, true, false);\n"
"SELECT ttextseq(ARRAY[ttextinst('AAA', '2001-01-01 08:00:00'),\n"
"ttextinst('BBB', '2001-01-03 08:05:00'), ttextinst('BBB', '2001-01-03 08:10:00')]);\n"
"SELECT tgeompointseq(ARRAY[tgeompoint 'Point(0 0)@2001-01-01 08:00:00',\n"
"'Point(0 1)@2001-01-03 08:05:00', 'Point(1 1)@2001-01-03 08:10:00']);\n"
"SELECT tgeogpointseq(ARRAY[tgeogpoint 'Point(0 0)@2001-01-01 08:00:00',\n"
"'Point(0 0)@2001-01-03 08:05:00'], true, true, false);"
msgstr ""
"SELECT tfloatseq(1.5, '[2001-01-01, 2001-01-02]');\n"
"SELECT tfloatseq(2.0, '[2001-01-01, 2001-01-02]', false);\n"
"SELECT tboolseq(ARRAY[tbool 'true@2001-01-01 08:00:00', 'true@2001-01-03 08:05:00'],\n"
"true, true);\n"
"SELECT tintseq(ARRAY[tintinst(2,'2001-01-01 08:00:00'),\n"
"tintinst(2,'2001-01-01 08:10:00')], true, false);\n"
"SELECT tfloatseq(ARRAY[tfloat '2.0@2001-01-01 08:00:00', '3@2001-01-03 08:05:00',\n"
"'1@2001-01-03 08:10:00'], true, false);\n"
"SELECT tfloatseq(ARRAY[tfloat '2.0@2001-01-01 08:00:00', '3@2001-01-03 08:05:00',\n"
"'1@2001-01-03 08:10:00'], true, true, false);\n"
"SELECT ttextseq(ARRAY[ttextinst('AAA', '2001-01-01 08:00:00'),\n"
"ttextinst('BBB', '2001-01-03 08:05:00'), ttextinst('BBB', '2001-01-03 08:10:00')]);\n"
"SELECT tgeompointseq(ARRAY[tgeompoint 'Point(0 0)@2001-01-01 08:00:00',\n"
"'Point(0 1)@2001-01-03 08:05:00', 'Point(1 1)@2001-01-03 08:10:00']);\n"
"SELECT tgeogpointseq(ARRAY[tgeogpoint 'Point(0 0)@2001-01-01 08:00:00',\n"
"'Point(0 0)@2001-01-03 08:05:00'], true, true, false);"

#. Tag: varname
#: manipulating_temporal_types.xml:165 manipulating_temporal_types.xml:239
#, no-c-format
msgid "ttypes"
msgstr "ttypes"

#. Tag: para
#: manipulating_temporal_types.xml:166
#, no-c-format
msgid "Constructors for temporal types of sequence set duration"
msgstr "Constructor para tipos temporales de duración conjunto de secuencias"

#. Tag: varname
#: manipulating_temporal_types.xml:167
#, no-c-format
msgid "tdiscs(base, periodset): tdiscs"
msgstr "tdiscs(base, periodset): tdiscs"

#. Tag: varname
#: manipulating_temporal_types.xml:168
#, no-c-format
msgid "tconts(base, periodset, linear = true): tconts"
msgstr "tconts(base, periodset, linear = true): tconts"

#. Tag: varname
#: manipulating_temporal_types.xml:169
#, no-c-format
msgid "ttypes(ttypeseq[]): ttypes"
msgstr "ttypes(ttypeseq[]): ttypes"

#. Tag: programlisting
#: manipulating_temporal_types.xml:170
#, no-c-format
msgid ""
"SELECT ttexts('AAA', '{[2001-01-01, 2001-01-02], [2001-01-03, 2001-01-04]}');\n"
"SELECT tgeogpointseq('Point(1 1)', '[2001-01-01, 2001-01-02]', false);\n"
"SELECT tbools(ARRAY[tbool '[false@2001-01-01 08:00:00, false@2001-01-01 08:05:00)',\n"
"'[true@2001-01-01 08:05:00]','(false@2001-01-01 08:05:00, false@2001-01-01 08:10:00)']);\n"
"SELECT tints(ARRAY[tint '[1@2001-01-01 08:00:00, 2@2001-01-01 08:05:00,\n"
"2@2001-01-01 08:10:00, 2@2001-01-01 08:15:00)']);\n"
"SELECT tfloats(ARRAY[tfloat '[1.0@2001-01-01 08:00:00, 2.0@2001-01-01 08:05:00,\n"
"2.0@2001-01-01 08:10:00]', '[2.0@2001-01-01 08:15:00, 3.0@2001-01-01 08:20:00)']);\n"
"SELECT tfloats(ARRAY[tfloat 'Interp=Stepwise;[1.0@2001-01-01 08:00:00,\n"
"2.0@2001-01-01 08:05:00, 2.0@2001-01-01 08:10:00]',\n"
"'Interp=Stepwise;[3.0@2001-01-01 08:15:00, 3.0@2001-01-01 08:20:00)']);\n"
"SELECT ttexts(ARRAY[ttext '[AAA@2001-01-01 08:00:00, AAA@2001-01-01 08:05:00)',\n"
"'[BBB@2001-01-01 08:10:00, BBB@2001-01-01 08:15:00)']);\n"
"SELECT tgeompoints(ARRAY[tgeompoint '[Point(0 0)@2001-01-01 08:00:00,\n"
"Point(0 1)@2001-01-01 08:05:00, Point(0 1)@2001-01-01 08:10:00)',\n"
"'[Point(0 1)@2001-01-01 08:15:00, Point(0 0)@2001-01-01 08:20:00)']);\n"
"SELECT tgeogpoints(ARRAY[tgeogpoint\n"
"'Interp=Stepwise;[Point(0 0)@2001-01-01 08:00:00, Point(0 0)@2001-01-01 08:05:00)',\n"
"'Interp=Stepwise;[Point(1 1)@2001-01-01 08:10:00, Point(1 1)@2001-01-01 08:15:00)']);\n"
"SELECT tfloats(ARRAY[tfloat 'Interp=Stepwise;[1.0@2001-01-01 08:00:00,\n"
"2.0@2001-01-01 08:05:00, 2.0@2001-01-01 08:10:00]',\n"
"'[3.0@2001-01-01 08:15:00, 3.0@2001-01-01 08:20:00)']);\n"
"-- ERROR:  Input sequences must have the same interpolation"
msgstr ""
"SELECT ttexts('AAA', '{[2001-01-01, 2001-01-02], [2001-01-03, 2001-01-04]}');\n"
"SELECT tgeogpointseq('Point(1 1)', '[2001-01-01, 2001-01-02]', false);\n"
"SELECT tbools(ARRAY[tbool '[false@2001-01-01 08:00:00, false@2001-01-01 08:05:00)',\n"
"'[true@2001-01-01 08:05:00]','(false@2001-01-01 08:05:00, false@2001-01-01 08:10:00)']);\n"
"SELECT tints(ARRAY[tint '[1@2001-01-01 08:00:00, 2@2001-01-01 08:05:00,\n"
"2@2001-01-01 08:10:00, 2@2001-01-01 08:15:00)']);\n"
"SELECT tfloats(ARRAY[tfloat '[1.0@2001-01-01 08:00:00, 2.0@2001-01-01 08:05:00,\n"
"2.0@2001-01-01 08:10:00]', '[2.0@2001-01-01 08:15:00, 3.0@2001-01-01 08:20:00)']);\n"
"SELECT tfloats(ARRAY[tfloat 'Interp=Stepwise;[1.0@2001-01-01 08:00:00,\n"
"2.0@2001-01-01 08:05:00, 2.0@2001-01-01 08:10:00]',\n"
"'Interp=Stepwise;[3.0@2001-01-01 08:15:00, 3.0@2001-01-01 08:20:00)']);\n"
"SELECT ttexts(ARRAY[ttext '[AAA@2001-01-01 08:00:00, AAA@2001-01-01 08:05:00)',\n"
"'[BBB@2001-01-01 08:10:00, BBB@2001-01-01 08:15:00)']);\n"
"SELECT tgeompoints(ARRAY[tgeompoint '[Point(0 0)@2001-01-01 08:00:00,\n"
"Point(0 1)@2001-01-01 08:05:00, Point(0 1)@2001-01-01 08:10:00)',\n"
"'[Point(0 1)@2001-01-01 08:15:00, Point(0 0)@2001-01-01 08:20:00)']);\n"
"SELECT tgeogpoints(ARRAY[tgeogpoint\n"
"'Interp=Stepwise;[Point(0 0)@2001-01-01 08:00:00, Point(0 0)@2001-01-01 08:05:00)',\n"
"'Interp=Stepwise;[Point(1 1)@2001-01-01 08:10:00, Point(1 1)@2001-01-01 08:15:00)']);\n"
"SELECT tfloats(ARRAY[tfloat 'Interp=Stepwise;[1.0@2001-01-01 08:00:00,\n"
"2.0@2001-01-01 08:05:00, 2.0@2001-01-01 08:10:00]',\n"
"'[3.0@2001-01-01 08:15:00, 3.0@2001-01-01 08:20:00)']);\n"
"-- ERROR:  Input sequences must have the same interpolation"

#. Tag: title
#: manipulating_temporal_types.xml:176
#, no-c-format
msgid "Casting"
msgstr "Casting"

#. Tag: para
#: manipulating_temporal_types.xml:178
#, no-c-format
msgid ""
"A temporal value can be converted into a temporal value of a compatible "
"type. This can be done using the notation <varname>CAST(ttype1 AS "
"ttype2)</varname> or <varname>ttype1::ttype2</varname>."
msgstr ""
"Un valor temporal se puede convertir en un valor temporal de un tipo "
"compatible. Esto se puede hacer usando la notación <varname>CAST(ttype1 AS "
"ttype2)</varname> o <varname>ttype1::ttype2</varname>."

#. Tag: varname
#: manipulating_temporal_types.xml:181 manipulating_temporal_types.xml:188
#: manipulating_temporal_types.xml:195 manipulating_temporal_types.xml:202
#: manipulating_temporal_types.xml:214 manipulating_temporal_types.xml:222
#, no-c-format
msgid "<varname>::</varname>"
msgstr "<varname>::</varname>"

#. Tag: para
#: manipulating_temporal_types.xml:182
#, no-c-format
msgid "Cast a temporal integer to a temporal float"
msgstr "Convertir un entero temporal en un flotante temporal"

#. Tag: varname
#: manipulating_temporal_types.xml:183
#, no-c-format
msgid "tint::tfloat"
msgstr "tint::tfloat"

#. Tag: programlisting
#: manipulating_temporal_types.xml:184
#, no-c-format
msgid ""
"SELECT tint '[1@2001-01-01, 2@2001-01-03]'::tfloat;\n"
"-- \"[1@2001-01-01 00:00:00+00, 2@2001-01-03 00:00:00+00]\"\n"
"SELECT tint '[1@2000-01-01, 2@2000-01-03, 3@2000-01-05]'::tfloat;\n"
"-- \"Interp=Stepwise;[1@2000-01-01 00:00:00+01, 2@2000-01-03 00:00:00+01, 3@2000-01-05 00:00:00+01]\""
msgstr ""
"SELECT tint '[1@2001-01-01, 2@2001-01-03]'::tfloat;\n"
"-- \"[1@2001-01-01 00:00:00+00, 2@2001-01-03 00:00:00+00]\"\n"
"SELECT tint '[1@2000-01-01, 2@2000-01-03, 3@2000-01-05]'::tfloat;\n"
"-- \"Interp=Stepwise;[1@2000-01-01 00:00:00+01, 2@2000-01-03 00:00:00+01, 3@2000-01-05 00:00:00+01]\""

#. Tag: para
#: manipulating_temporal_types.xml:189
#, no-c-format
msgid "Cast a temporal float to a temporal integer"
msgstr "Convertir un flotante temporal en un entero temporal"

#. Tag: varname
#: manipulating_temporal_types.xml:190
#, no-c-format
msgid "tfloat::tint"
msgstr "tfloat::tint"

#. Tag: programlisting
#: manipulating_temporal_types.xml:191
#, no-c-format
msgid ""
"SELECT tfloat 'Interp=Stepwise;[1.5@2001-01-01, 2.5@2001-01-03]'::tint;\n"
"-- \"[1@2001-01-01 00:00:00+00, 2@2001-01-03 00:00:00+00]\"\n"
"SELECT tfloat '[1.5@2001-01-01, 2.5@2001-01-03]'::tint;\n"
"-- ERROR:  Cannot cast temporal float with linear interpolation to temporal integer"
msgstr ""
"SELECT tfloat 'Interp=Stepwise;[1.5@2001-01-01, 2.5@2001-01-03]'::tint;\n"
"-- \"[1@2001-01-01 00:00:00+00, 2@2001-01-03 00:00:00+00]\"\n"
"SELECT tfloat '[1.5@2001-01-01, 2.5@2001-01-03]'::tint;\n"
"-- ERROR:  Cannot cast temporal float with linear interpolation to temporal integer"

#. Tag: para
#: manipulating_temporal_types.xml:196
#, no-c-format
msgid "Cast a temporal geometry point to a temporal geography point"
msgstr "Convertir un punto geométrico temporal a un punto geográfico temporal"

#. Tag: varname
#: manipulating_temporal_types.xml:197
#, no-c-format
msgid "tgeompoint::tgeogpoint"
msgstr "tgeompoint::tgeogpoint"

#. Tag: programlisting
#: manipulating_temporal_types.xml:198
#, no-c-format
msgid ""
"SELECT asText((tgeogpoint 'Point(0 0)@2001-01-01')::tgeompoint);\n"
"-- \"{POINT(0 0)@2001-01-01}\""
msgstr ""
"SELECT asText((tgeogpoint 'Point(0 0)@2001-01-01')::tgeompoint);\n"
"-- \"{POINT(0 0)@2001-01-01}\""

#. Tag: para
#: manipulating_temporal_types.xml:203
#, no-c-format
msgid "Cast a temporal geography point to a temporal geometry point"
msgstr "Convertir un punto geográfico temporal a un punto geométrico temporal"

#. Tag: varname
#: manipulating_temporal_types.xml:204
#, no-c-format
msgid "tgeogpoint::tgeompoint"
msgstr "tgeogpoint::tgeompoint"

#. Tag: programlisting
#: manipulating_temporal_types.xml:205
#, no-c-format
msgid ""
"SELECT asText((tgeompoint '[Point(0 0)@2001-01-01, Point(0 1)@2001-01-02)')::tgeogpoint);\n"
"-- \"{[POINT(0 0)@2001-01-01, POINT(0 1)@2001-01-02)}\""
msgstr ""
"SELECT asText((tgeompoint '[Point(0 0)@2001-01-01, Point(0 1)@2001-01-02)')::tgeogpoint);\n"
"-- \"{[POINT(0 0)@2001-01-01, POINT(0 1)@2001-01-02)}\""

#. Tag: para
#: manipulating_temporal_types.xml:210
#, no-c-format
msgid ""
"A common way to store temporal points in PostGIS is to represent them as "
"geometries of type <varname>LINESTRING M</varname> and abuse the M dimension"
" to encode timestamps as seconds since 1970-01-01 00:00:00. These time-"
"enhanced geometries, called trajectories, can be validated with the function"
" <varname>ST_IsValidTrajectory</varname> to verify that the M value is "
"growing from each vertex to the next. Trajectories can be manipulated with "
"the functions <varname>ST_ClosestPointOfApproach</varname>, "
"<varname>ST_DistanceCPA</varname>, and <varname>ST_CPAWithin</varname>. "
"Temporal point values can be converted to/from PostGIS trajectories."
msgstr ""
"Una forma común de almacenar puntos temporales en PostGIS es representarlos "
"como geometrías de tipo <varname>LINESTRING M</varname> y utilizar la "
"dimensión M para codificar marcas de tiempo como segundos desde 1970-01-01 "
"00:00:00. Estas geometrías aumentadas con tiempo, llamadas trayectorias, se "
"pueden validar con la función <varname>ST_IsValidTrajectory</varname> para "
"verificar quel el valor M está creciendo de cada vértice al siguiente. Las "
"trayectorias se pueden manipular con las funciones "
"<varname>ST_ClosestPointOfApproach</varname>, "
"<varname>ST_DistanceCPA</varname>, y<varname>ST_CPAWithin</varname>. Los "
"valores de puntos temporales se pueden convertir a/desde trayectorias de "
"PostGIS."

#. Tag: para
#: manipulating_temporal_types.xml:215
#, no-c-format
msgid "Cast a temporal point to a PostGIS trajectory"
msgstr "Convertir un punto temporal a una trayectoria PostGIS"

#. Tag: varname
#: manipulating_temporal_types.xml:216
#, no-c-format
msgid "tgeompoint::geometry"
msgstr "tgeompoint::geometry"

#. Tag: varname
#: manipulating_temporal_types.xml:217
#, no-c-format
msgid "tgeogpoint::geography"
msgstr "tgeogpoint::geography"

#. Tag: programlisting
#: manipulating_temporal_types.xml:218
#, no-c-format
msgid ""
"SELECT ST_AsText((tgeompoint 'Point(0 0)@2001-01-01')::geometry);\n"
"-- \"POINT M (0 0 978307200)\"\n"
"SELECT ST_AsText((tgeompoint '{Point(0 0)@2001-01-01, Point(1 1)@2001-01-02,\n"
"Point(1 1)@2001-01-03}')::geometry);\n"
"-- \"MULTIPOINT M (0 0 978307200,1 1 978393600,1 1 978480000)\"\n"
"SELECT ST_AsText((tgeompoint '[Point(0 0)@2001-01-01, Point(1 1)@2001-01-02)')::geometry);\n"
"-- \"LINESTRING M (0 0 978307200,1 1 978393600)\"\n"
"SELECT ST_AsText((tgeompoint '{[Point(0 0)@2001-01-01, Point(1 1)@2001-01-02),\n"
"[Point(1 1)@2001-01-03, Point(1 1)@2001-01-04),\n"
"[Point(1 1)@2001-01-05, Point(0 0)@2001-01-06)}')::geometry);\n"
"-- \"MULTILINESTRING M ((0 0 978307200,1 1 978393600),(1 1 978480000,1 1 978566400),\n"
"(1 1 978652800,0 0 978739200))\"\n"
"SELECT ST_AsText((tgeompoint '{[Point(0 0)@2001-01-01, Point(1 1)@2001-01-02),\n"
"[Point(1 1)@2001-01-03],\n"
"[Point(1 1)@2001-01-05, Point(0 0)@2001-01-06)}')::geometry);\n"
"-- \"GEOMETRYCOLLECTION M (LINESTRING M (0 0 978307200,1 1 978393600),\n"
"POINT M (1 1 978480000),LINESTRING M (1 1 978652800,0 0 978739200))\""
msgstr ""
"SELECT ST_AsText((tgeompoint 'Point(0 0)@2001-01-01')::geometry);\n"
"-- \"POINT M (0 0 978307200)\"\n"
"SELECT ST_AsText((tgeompoint '{Point(0 0)@2001-01-01, Point(1 1)@2001-01-02,\n"
"Point(1 1)@2001-01-03}')::geometry);\n"
"-- \"MULTIPOINT M (0 0 978307200,1 1 978393600,1 1 978480000)\"\n"
"SELECT ST_AsText((tgeompoint '[Point(0 0)@2001-01-01, Point(1 1)@2001-01-02)')::geometry);\n"
"-- \"LINESTRING M (0 0 978307200,1 1 978393600)\"\n"
"SELECT ST_AsText((tgeompoint '{[Point(0 0)@2001-01-01, Point(1 1)@2001-01-02),\n"
"[Point(1 1)@2001-01-03, Point(1 1)@2001-01-04),\n"
"[Point(1 1)@2001-01-05, Point(0 0)@2001-01-06)}')::geometry);\n"
"-- \"MULTILINESTRING M ((0 0 978307200,1 1 978393600),(1 1 978480000,1 1 978566400),\n"
"(1 1 978652800,0 0 978739200))\"\n"
"SELECT ST_AsText((tgeompoint '{[Point(0 0)@2001-01-01, Point(1 1)@2001-01-02),\n"
"[Point(1 1)@2001-01-03],\n"
"[Point(1 1)@2001-01-05, Point(0 0)@2001-01-06)}')::geometry);\n"
"-- \"GEOMETRYCOLLECTION M (LINESTRING M (0 0 978307200,1 1 978393600),\n"
"POINT M (1 1 978480000),LINESTRING M (1 1 978652800,0 0 978739200))\""

#. Tag: para
#: manipulating_temporal_types.xml:223
#, no-c-format
msgid "Cast a PostGIS trajectory to a temporal point"
msgstr "Convertir una trayectoria PostGIS a un punto temporal"

#. Tag: varname
#: manipulating_temporal_types.xml:224
#, no-c-format
msgid "geometry::tgeompoint"
msgstr "geometry::tgeompoint"

#. Tag: varname
#: manipulating_temporal_types.xml:225
#, no-c-format
msgid "geography::tgeogpoint"
msgstr "geography::tgeogpoint"

#. Tag: programlisting
#: manipulating_temporal_types.xml:226
#, no-c-format
msgid ""
"SELECT asText(geometry 'LINESTRING M (0 0 978307200,0 1 978393600,\n"
"1 1 978480000)'::tgeompoint);\n"
"-- \"[POINT(0 0)@2001-01-01, POINT(0 1)@2001-01-02, POINT(1 1)@2001-01-03]\";\n"
"SELECT asText(geometry 'GEOMETRYCOLLECTION M (LINESTRING M (0 0 978307200,1 1 978393600),\n"
"POINT M (1 1 978480000),LINESTRING M (1 1 978652800,0 0 978739200))'::tgeompoint);\n"
"-- \"{[POINT(0 0)@2001-01-01, POINT(1 1)@2001-01-02], [POINT(1 1)@2001-01-03],\n"
"[POINT(1 1)@2001-01-05, POINT(0 0)@2001-01-06]}\""
msgstr ""
"SELECT asText(geometry 'LINESTRING M (0 0 978307200,0 1 978393600,\n"
"1 1 978480000)'::tgeompoint);\n"
"-- \"[POINT(0 0)@2001-01-01, POINT(0 1)@2001-01-02, POINT(1 1)@2001-01-03]\";\n"
"SELECT asText(geometry 'GEOMETRYCOLLECTION M (LINESTRING M (0 0 978307200,1 1 978393600),\n"
"POINT M (1 1 978480000),LINESTRING M (1 1 978652800,0 0 978739200))'::tgeompoint);\n"
"-- \"{[POINT(0 0)@2001-01-01, POINT(1 1)@2001-01-02], [POINT(1 1)@2001-01-03],\n"
"[POINT(1 1)@2001-01-05, POINT(0 0)@2001-01-06]}\""

#. Tag: title
#: manipulating_temporal_types.xml:232
#, no-c-format
msgid "Transformation Functions"
msgstr "Funciones de transformación"

#. Tag: para
#: manipulating_temporal_types.xml:233
#, no-c-format
msgid ""
"A temporal value can be transformed to another duration. An error is raised "
"if the durations are incompatible."
msgstr ""
"Un valor temporal se puede transformar en otra duración. Se genera un error "
"si las duraciones son incompatibles."

#. Tag: para
#: manipulating_temporal_types.xml:240
#, no-c-format
msgid "Transform a temporal value to another duration"
msgstr "Transformar un valor temporal en otra duración"

#. Tag: varname
#: manipulating_temporal_types.xml:241
#, no-c-format
msgid "ttypeinst(ttype): ttypeinst"
msgstr "ttypeinst(ttype): ttypeinst"

#. Tag: varname
#: manipulating_temporal_types.xml:242
#, no-c-format
msgid "ttypei(ttype): ttypei"
msgstr "ttypei(ttype): ttypei"

#. Tag: varname
#: manipulating_temporal_types.xml:243
#, no-c-format
msgid "ttypeseq(ttype): ttypeseq"
msgstr "ttypeseq(ttype): ttypeseq"

#. Tag: varname
#: manipulating_temporal_types.xml:244
#, no-c-format
msgid "ttypes(ttype): ttypes"
msgstr "ttypes(ttype): ttypes"

#. Tag: programlisting
#: manipulating_temporal_types.xml:245
#, no-c-format
msgid ""
"SELECT tboolinst(tbool '{[true@2001-01-01]}');\n"
"-- \"t@2001-01-01 00:00:00+00\"\n"
"SELECT tboolinst(tbool '{[true@2001-01-01, true@2001-01-02]}');\n"
"-- ERROR: Cannot transform input to a temporal instant\n"
"SELECT tbooli(tbool 'true@2001-01-01');\n"
"-- \"{t@2001-01-01}\"\n"
"SELECT tintseq(tint '1@2001-01-01');\n"
"-- \"[1@2001-01-01]\"\n"
"SELECT tfloats(tfloat '2.5@2001-01-01');\n"
"-- \"{[2.5@2001-01-01]}\"\n"
"SELECT tfloats(tfloat '{2.5@2001-01-01, 1.5@2001-01-02, 3.5@2001-01-02}');\n"
"-- \"{[2.5@2001-01-01],[1.5@2001-01-02],[3.5@2001-01-03]}\""
msgstr ""
"SELECT tboolinst(tbool '{[true@2001-01-01]}');\n"
"-- \"t@2001-01-01 00:00:00+00\"\n"
"SELECT tboolinst(tbool '{[true@2001-01-01, true@2001-01-02]}');\n"
"-- ERROR: Cannot transform input to a temporal instant\n"
"SELECT tbooli(tbool 'true@2001-01-01');\n"
"-- \"{t@2001-01-01}\"\n"
"SELECT tintseq(tint '1@2001-01-01');\n"
"-- \"[1@2001-01-01]\"\n"
"SELECT tfloats(tfloat '2.5@2001-01-01');\n"
"-- \"{[2.5@2001-01-01]}\"\n"
"SELECT tfloats(tfloat '{2.5@2001-01-01, 1.5@2001-01-02, 3.5@2001-01-02}');\n"
"-- \"{[2.5@2001-01-01],[1.5@2001-01-02],[3.5@2001-01-03]}\""

#. Tag: varname
#: manipulating_temporal_types.xml:249
#, no-c-format
msgid "toLinear"
msgstr "toLinear"

#. Tag: para
#: manipulating_temporal_types.xml:250
#, no-c-format
msgid ""
"Transform a temporal value with continuous base type from stepwise to linear"
" interpolation"
msgstr ""
"Transformar un valor temporal con tipo de base continuo de interpolación "
"escalonada a lineal"

#. Tag: varname
#: manipulating_temporal_types.xml:251
#, no-c-format
msgid "toLinear(ttype) : ttype"
msgstr "toLinear(ttype) : ttype"

#. Tag: programlisting
#: manipulating_temporal_types.xml:252
#, no-c-format
msgid ""
"SELECT toLinear(tfloat 'Interp=Stepwise;[1@2000-01-01, 2@2000-01-02,\n"
"1@2000-01-03, 2@2000-01-04]');\n"
"-- \"{[1@2000-01-01, 1@2000-01-02), [2@2000-01-02, 2@2000-01-03),\n"
"[1@2000-01-03, 1@2000-01-04), [2@2000-01-04]}\"\n"
"SELECT asText(toLinear(tgeompoint 'Interp=Stepwise;{[Point(1 1)@2000-01-01,\n"
"Point(2 2)@2000-01-02], [Point(3 3)@2000-01-05, Point(4 4)@2000-01-06]}'));\n"
"-- \"{[POINT(1 1)@2000-01-01, POINT(1 1)@2000-01-02), [POINT(2 2)@2000-01-02],\n"
"[POINT(3 3)@2000-01-05, POINT(3 3)@2000-01-06), [POINT(4 4)@2000-01-06]}\""
msgstr ""
"SELECT toLinear(tfloat 'Interp=Stepwise;[1@2000-01-01, 2@2000-01-02,\n"
"1@2000-01-03, 2@2000-01-04]');\n"
"-- \"{[1@2000-01-01, 1@2000-01-02), [2@2000-01-02, 2@2000-01-03),\n"
"[1@2000-01-03, 1@2000-01-04), [2@2000-01-04]}\"\n"
"SELECT asText(toLinear(tgeompoint 'Interp=Stepwise;{[Point(1 1)@2000-01-01,\n"
"Point(2 2)@2000-01-02], [Point(3 3)@2000-01-05, Point(4 4)@2000-01-06]}'));\n"
"-- \"{[POINT(1 1)@2000-01-01, POINT(1 1)@2000-01-02), [POINT(2 2)@2000-01-02],\n"
"[POINT(3 3)@2000-01-05, POINT(3 3)@2000-01-06), [POINT(4 4)@2000-01-06]}\""

#. Tag: varname
#: manipulating_temporal_types.xml:256
#, no-c-format
msgid "appendInstant"
msgstr "appendInstant"

#. Tag: para
#: manipulating_temporal_types.xml:257
#, no-c-format
msgid "Append a temporal instant to a temporal value"
msgstr "Anexar un instante temporal a un valor temporal"

#. Tag: varname
#: manipulating_temporal_types.xml:258
#, no-c-format
msgid "appendInstant(ttype, ttypeinst) : ttype"
msgstr "appendInstant(ttype, ttypeinst) : ttype"

#. Tag: programlisting
#: manipulating_temporal_types.xml:259
#, no-c-format
msgid ""
"SELECT appendInstant(tint '1@2000-01-01', tint '1@2000-01-02');\n"
"-- \"{1@2000-01-01, 1@2000-01-02}\"\n"
"SELECT appendInstant(tintseq(tint '1@2000-01-01'), tint '1@2000-01-02');\n"
"-- \"[1@2000-01-01, 1@2000-01-02]\"\n"
"SELECT asText(appendInstant(tgeompoint '{[Point(1 1 1)@2000-01-01,\n"
"Point(2 2 2)@2000-01-02], [Point(3 3 3)@2000-01-04, Point(3 3 3)@2000-01-05]}',\n"
"tgeompoint 'Point(1 1 1)@2000-01-06'));\n"
"-- \"{[POINT Z (1 1 1)@2000-01-01, POINT Z (2 2 2)@2000-01-02],\n"
"[POINT Z (3 3 3)@2000-01-04, POINT Z (3 3 3)@2000-01-05, POINT Z (1 1 1)@2000-01-06]}\""
msgstr ""
"SELECT appendInstant(tint '1@2000-01-01', tint '1@2000-01-02');\n"
"-- \"{1@2000-01-01, 1@2000-01-02}\"\n"
"SELECT appendInstant(tintseq(tint '1@2000-01-01'), tint '1@2000-01-02');\n"
"-- \"[1@2000-01-01, 1@2000-01-02]\"\n"
"SELECT asText(appendInstant(tgeompoint '{[Point(1 1 1)@2000-01-01,\n"
"Point(2 2 2)@2000-01-02], [Point(3 3 3)@2000-01-04, Point(3 3 3)@2000-01-05]}',\n"
"tgeompoint 'Point(1 1 1)@2000-01-06'));\n"
"-- \"{[POINT Z (1 1 1)@2000-01-01, POINT Z (2 2 2)@2000-01-02],\n"
"[POINT Z (3 3 3)@2000-01-04, POINT Z (3 3 3)@2000-01-05, POINT Z (1 1 1)@2000-01-06]}\""

#. Tag: varname
#: manipulating_temporal_types.xml:263
#, no-c-format
msgid "merge"
msgstr "merge"

#. Tag: para
#: manipulating_temporal_types.xml:264
#, no-c-format
msgid "Merge temporal values"
msgstr "Fusionar los valores temporales"

#. Tag: varname
#: manipulating_temporal_types.xml:265
#, no-c-format
msgid "merge(ttype, ttype) : ttype"
msgstr "merge(ttype, ttype) : ttype"

#. Tag: varname
#: manipulating_temporal_types.xml:266
#, no-c-format
msgid "merge(ttype[]) : ttype"
msgstr "merge(ttype[]) : ttype"

#. Tag: para
#: manipulating_temporal_types.xml:267
#, no-c-format
msgid ""
"The values may share a single timestamp, in that case the temporal values "
"are joined in the result if their value at the common timestamp is the same,"
" otherwise an error is raised."
msgstr ""
"Los valores pueden compartir una sola marca de tiempo, en ese caso, los "
"valores temporales se unen en el resultado si su valor en la marca de tiempo"
" común es el mismo; de lo contrario, se genera un error."

#. Tag: programlisting
#: manipulating_temporal_types.xml:268
#, no-c-format
msgid ""
"SELECT merge(tint '1@2000-01-01', tint '1@2000-01-02');\n"
"-- \"{1@2000-01-01, 1@2000-01-02}\"\n"
"SELECT merge(tint '[1@2000-01-01, 2@2000-01-02]', tint '[2@2000-01-02, 1@2000-01-03]');\n"
"-- \"[1@2000-01-01, 2@2000-01-02, 1@2000-01-03]\"\n"
"SELECT merge(tint '[1@2000-01-01, 2@2000-01-02]', tint '[3@2000-01-03, 1@2000-01-04]');\n"
"-- \"{[1@2000-01-01, 2@2000-01-02], [3@2000-01-03, 1@2000-01-04]}\"\n"
"SELECT merge(tint '[1@2000-01-01, 2@2000-01-02]', tint '[1@2000-01-02, 2@2000-01-03]');\n"
"-- ERROR:  Both arguments have different value at their overlapping timestamp\n"
"SELECT asText(merge(tgeompoint '{[Point(1 1 1)@2000-01-01,\n"
"Point(2 2 2)@2000-01-02], [Point(3 3 3)@2000-01-04, Point(3 3 3)@2000-01-05]}',\n"
"tgeompoint '{[Point(3 3 3)@2000-01-05, Point(1 1 1)@2000-01-06]}'));\n"
"-- \"{[POINT Z (1 1 1)@2000-01-01, POINT Z (2 2 2)@2000-01-02],\n"
"[POINT Z (3 3 3)@2000-01-04, POINT Z (3 3 3)@2000-01-05, POINT Z (1 1 1)@2000-01-06]}\"\n"
"\n"
"SELECT merge(ARRAY[tint '1@2000-01-01', '1@2000-01-02']);\n"
"-- \"{1@2000-01-01, 1@2000-01-02}\"\n"
"SELECT merge(ARRAY[tint '{1@2000-01-01, 2@2000-01-02}', '{2@2000-01-02, 3@2000-01-03}']);\n"
"-- \"{1@2000-01-01, 2@2000-01-02, 3@2000-01-03}\"\n"
"SELECT merge(ARRAY[tint '{1@2000-01-01, 2@2000-01-02}', '{3@2000-01-03, 4@2000-01-04}']);\n"
"-- \"{1@2000-01-01, 2@2000-01-02, 3@2000-01-03, 4@2000-01-04}\"\n"
"SELECT merge(ARRAY[tint '[1@2000-01-01, 2@2000-01-02]', '[2@2000-01-02, 1@2000-01-03]']);\n"
"-- \"[1@2000-01-01, 2@2000-01-02, 1@2000-01-03]\"\n"
"SELECT merge(ARRAY[tint '[1@2000-01-01, 2@2000-01-02]', '[3@2000-01-03, 4@2000-01-04]']);\n"
"-- \"{[1@2000-01-01, 2@2000-01-02], [3@2000-01-03, 4@2000-01-04]}\"\n"
"SELECT merge(ARRAY[tgeompoint '{[Point(1 1)@2000-01-01, Point(2 2)@2000-01-02],\n"
"[Point(3 3)@2000-01-03, Point(4 4)@2000-01-04]}', '{[Point(4 4)@2000-01-04,\n"
"Point(3 3)@2000-01-05], [Point(6 6)@2000-01-06, Point(7 7)@2000-01-07]}']);\n"
"-- \"{[Point(1 1)@2000-01-01, Point(2 2)@2000-01-02], [Point(3 3)@2000-01-03,\n"
"Point(4 4)@2000-01-04, Point(3 3)@2000-01-05],\n"
"[Point(6 6)@2000-01-06, Point(7 7)@2000-01-07]}\"\n"
"SELECT merge(ARRAY[tgeompoint '{[Point(1 1)@2000-01-01, Point(2 2)@2000-01-02]}',\n"
"'{[Point(2 2)@2000-01-02, Point(1 1)@2000-01-03]}']);\n"
"-- \"[Point(1 1)@2000-01-01, Point(2 2)@2000-01-02, Point(1 1)@2000-01-03]\""
msgstr ""
"SELECT merge(tint '1@2000-01-01', tint '1@2000-01-02');\n"
"-- \"{1@2000-01-01, 1@2000-01-02}\"\n"
"SELECT merge(tint '[1@2000-01-01, 2@2000-01-02]', tint '[2@2000-01-02, 1@2000-01-03]');\n"
"-- \"[1@2000-01-01, 2@2000-01-02, 1@2000-01-03]\"\n"
"SELECT merge(tint '[1@2000-01-01, 2@2000-01-02]', tint '[3@2000-01-03, 1@2000-01-04]');\n"
"-- \"{[1@2000-01-01, 2@2000-01-02], [3@2000-01-03, 1@2000-01-04]}\"\n"
"SELECT merge(tint '[1@2000-01-01, 2@2000-01-02]', tint '[1@2000-01-02, 2@2000-01-03]');\n"
"-- ERROR:  Both arguments have different value at their overlapping timestamp\n"
"SELECT asText(merge(tgeompoint '{[Point(1 1 1)@2000-01-01,\n"
"Point(2 2 2)@2000-01-02], [Point(3 3 3)@2000-01-04, Point(3 3 3)@2000-01-05]}',\n"
"tgeompoint '{[Point(3 3 3)@2000-01-05, Point(1 1 1)@2000-01-06]}'));\n"
"-- \"{[POINT Z (1 1 1)@2000-01-01, POINT Z (2 2 2)@2000-01-02],\n"
"[POINT Z (3 3 3)@2000-01-04, POINT Z (3 3 3)@2000-01-05, POINT Z (1 1 1)@2000-01-06]}\"\n"
"\n"
"SELECT merge(ARRAY[tint '1@2000-01-01', '1@2000-01-02']);\n"
"-- \"{1@2000-01-01, 1@2000-01-02}\"\n"
"SELECT merge(ARRAY[tint '{1@2000-01-01, 2@2000-01-02}', '{2@2000-01-02, 3@2000-01-03}']);\n"
"-- \"{1@2000-01-01, 2@2000-01-02, 3@2000-01-03}\"\n"
"SELECT merge(ARRAY[tint '{1@2000-01-01, 2@2000-01-02}', '{3@2000-01-03, 4@2000-01-04}']);\n"
"-- \"{1@2000-01-01, 2@2000-01-02, 3@2000-01-03, 4@2000-01-04}\"\n"
"SELECT merge(ARRAY[tint '[1@2000-01-01, 2@2000-01-02]', '[2@2000-01-02, 1@2000-01-03]']);\n"
"-- \"[1@2000-01-01, 2@2000-01-02, 1@2000-01-03]\"\n"
"SELECT merge(ARRAY[tint '[1@2000-01-01, 2@2000-01-02]', '[3@2000-01-03, 4@2000-01-04]']);\n"
"-- \"{[1@2000-01-01, 2@2000-01-02], [3@2000-01-03, 4@2000-01-04]}\"\n"
"SELECT merge(ARRAY[tgeompoint '{[Point(1 1)@2000-01-01, Point(2 2)@2000-01-02],\n"
"[Point(3 3)@2000-01-03, Point(4 4)@2000-01-04]}', '{[Point(4 4)@2000-01-04,\n"
"Point(3 3)@2000-01-05], [Point(6 6)@2000-01-06, Point(7 7)@2000-01-07]}']);\n"
"-- \"{[Point(1 1)@2000-01-01, Point(2 2)@2000-01-02], [Point(3 3)@2000-01-03,\n"
"Point(4 4)@2000-01-04, Point(3 3)@2000-01-05],\n"
"[Point(6 6)@2000-01-06, Point(7 7)@2000-01-07]}\"\n"
"SELECT merge(ARRAY[tgeompoint '{[Point(1 1)@2000-01-01, Point(2 2)@2000-01-02]}',\n"
"'{[Point(2 2)@2000-01-02, Point(1 1)@2000-01-03]}']);\n"
"-- \"[Point(1 1)@2000-01-01, Point(2 2)@2000-01-02, Point(1 1)@2000-01-03]\""

#. Tag: title
#: manipulating_temporal_types.xml:275
#, no-c-format
msgid "Accessor Functions"
msgstr "Funciones de accesor"

#. Tag: varname
#: manipulating_temporal_types.xml:279
#, no-c-format
msgid "memSize"
msgstr "memSize"

#. Tag: para
#: manipulating_temporal_types.xml:280
#, no-c-format
msgid "Get the memory size in bytes"
msgstr "Obtener el tamaño de la memoria en bytes"

#. Tag: varname
#: manipulating_temporal_types.xml:281
#, no-c-format
msgid "memSize(ttype): integer"
msgstr "memSize(ttype): integer"

#. Tag: programlisting
#: manipulating_temporal_types.xml:282
#, no-c-format
msgid ""
"SELECT memSize(tint '{1@2012-01-01, 2@2012-01-02, 3@2012-01-03}');\n"
"-- 280"
msgstr ""
"SELECT memSize(tint '{1@2012-01-01, 2@2012-01-02, 3@2012-01-03}');\n"
"-- 280"

#. Tag: varname
#: manipulating_temporal_types.xml:286
#, no-c-format
msgid "duration"
msgstr "duration"

#. Tag: para
#: manipulating_temporal_types.xml:287
#, no-c-format
msgid "Get the duration"
msgstr "Obtener la duración"

#. Tag: varname
#: manipulating_temporal_types.xml:288
#, no-c-format
msgid "duration(ttype): {'Instant', 'InstantSet', 'Sequence', 'SequenceSet'}"
msgstr "duration(ttype): {'Instant', 'InstantSet', 'Sequence', 'SequenceSet'}"

#. Tag: programlisting
#: manipulating_temporal_types.xml:289
#, no-c-format
msgid ""
"SELECT duration(tint '[1@2012-01-01, 2@2012-01-02, 3@2012-01-03]');\n"
"-- \"Sequence\""
msgstr ""
"SELECT duration(tint '[1@2012-01-01, 2@2012-01-02, 3@2012-01-03]');\n"
"-- \"Sequence\""

#. Tag: varname
#: manipulating_temporal_types.xml:293
#, no-c-format
msgid "interpolation"
msgstr "interpolation"

#. Tag: para
#: manipulating_temporal_types.xml:294
#, no-c-format
msgid "Get the interpolation"
msgstr "Obtener la interpolación"

#. Tag: varname
#: manipulating_temporal_types.xml:295
#, no-c-format
msgid "interpolation(ttype): {'Discrete', 'Stepwise', 'Linear'}"
msgstr "interpolation(ttype): {'Discrete', 'Stepwise', 'Linear'}"

#. Tag: programlisting
#: manipulating_temporal_types.xml:296
#, no-c-format
msgid ""
"SELECT interpolation(tfloat '{1@2012-01-01, 2@2012-01-02, 3@2012-01-03}');\n"
"-- \"Discrete\"\n"
"SELECT interpolation(tint '[1@2012-01-01, 2@2012-01-02, 3@2012-01-03]');\n"
"-- \"Stepwise\"\n"
"SELECT interpolation(tfloat '[1@2012-01-01, 2@2012-01-02, 3@2012-01-03]');\n"
"-- \"Linear\"\n"
"SELECT interpolation(tfloat 'Interp=Stepwise;[1@2012-01-01, 2@2012-01-02, 3@2012-01-03]');\n"
"-- \"Stepwise\"\n"
"SELECT interpolation(tgeompoint 'Interp=Stepwise;[Point(1 1)@2012-01-01, Point(2 2)@2012-01-02, Point(3 3)@2012-01-03]');\n"
"-- \"Stepwise\""
msgstr ""
"SELECT interpolation(tfloat '{1@2012-01-01, 2@2012-01-02, 3@2012-01-03}');\n"
"-- \"Discrete\"\n"
"SELECT interpolation(tint '[1@2012-01-01, 2@2012-01-02, 3@2012-01-03]');\n"
"-- \"Stepwise\"\n"
"SELECT interpolation(tfloat '[1@2012-01-01, 2@2012-01-02, 3@2012-01-03]');\n"
"-- \"Linear\"\n"
"SELECT interpolation(tfloat 'Interp=Stepwise;[1@2012-01-01, 2@2012-01-02, 3@2012-01-03]');\n"
"-- \"Stepwise\"\n"
"SELECT interpolation(tgeompoint 'Interp=Stepwise;[Point(1 1)@2012-01-01, Point(2 2)@2012-01-02, Point(3 3)@2012-01-03]');\n"
"-- \"Stepwise\""

#. Tag: varname
#: manipulating_temporal_types.xml:300
#, no-c-format
msgid "getValue"
msgstr "getValue"

#. Tag: para
#: manipulating_temporal_types.xml:301
#, no-c-format
msgid "Get the value"
msgstr "Obtener el valor"

#. Tag: varname
#: manipulating_temporal_types.xml:302
#, no-c-format
msgid "getValue(ttypeinst): base"
msgstr "getValue(ttypeinst): base"

#. Tag: programlisting
#: manipulating_temporal_types.xml:303
#, no-c-format
msgid ""
"SELECT getValue(tint '1@2012-01-01');\n"
"-- 1\n"
"SELECT ST_AsText(getValue(tgeompoint 'Point(0 0)@2012-01-01'));\n"
"-- \"POINT(0 0)\""
msgstr ""
"SELECT getValue(tint '1@2012-01-01');\n"
"-- 1\n"
"SELECT ST_AsText(getValue(tgeompoint 'Point(0 0)@2012-01-01'));\n"
"-- \"POINT(0 0)\""

#. Tag: varname
#: manipulating_temporal_types.xml:307
#, no-c-format
msgid "getValues"
msgstr "getValues"

#. Tag: para
#: manipulating_temporal_types.xml:308
#, no-c-format
msgid "Get the values"
msgstr "Obtener los valores"

#. Tag: varname
#: manipulating_temporal_types.xml:309
#, no-c-format
msgid "getValues(ttype): {base[], floatrange[], geo}"
msgstr "getValues(ttype): {base[], floatrange[], geo}"

#. Tag: programlisting
#: manipulating_temporal_types.xml:310
#, no-c-format
msgid ""
"SELECT getValues(tint '[1@2012-01-01, 2@2012-01-03]');\n"
"-- \"{1,2}\"\n"
"SELECT getValues(tfloat '[1@2012-01-01, 2@2012-01-03)');\n"
"-- \"{[1,2)}\"\n"
"SELECT getValues(tfloat '{[1@2012-01-01, 2@2012-01-03), [3@2012-01-03, 4@2012-01-05)}');\n"
"-- \"{[1,2),[3,4)}\"\n"
"SELECT getValues(tfloat 'Interp=Stepwise;{[1@2012-01-01, 2@2012-01-02],\n"
"[3@2012-01-03, 4@2012-01-05]}');\n"
"-- \"{\"[1,1]\",\"[2,2]\",\"[3,3]\",\"[4,4]\"}\"\n"
"SELECT ST_AsText(getValues(tgeompoint '{[Point(0 0)@2012-01-01, Point(0 1)@2012-01-02),\n"
"[Point(0 1)@2012-01-03, Point(1 1)@2012-01-04)}'));\n"
"-- \"LINESTRING(0 0,0 1,1 1)\"\n"
"SELECT ST_AsText(getValues(tgeompoint '{[Point(0 0)@2012-01-01, Point(0 1)@2012-01-02),\n"
"[Point(1 1)@2012-01-03, Point(2 2)@2012-01-04)}'));\n"
"-- \"MULTILINESTRING((0 0,0 1),(1 1,2 2)\"\n"
"SELECT ST_AsText(getValues(tgeompoint 'Interp=Stepwise;{[Point(0 0)@2012-01-01,\n"
"Point(0 1)@2012-01-02], [Point(0 1)@2012-01-03, Point(1 1)@2012-01-04]}'));\n"
"-- \"GEOMETRYCOLLECTION(MULTIPOINT(0 0,0 1),MULTIPOINT(0 1,1 1))\"\n"
"SELECT ST_AsText(getValues(tgeompoint '{Point(0 0)@2012-01-01, Point(0 1)@2012-01-02}'));\n"
"-- \"MULTIPOINT(0 0,0 1)\"\n"
"SELECT ST_AsText(getValues(tgeompoint '{[Point(0 0)@2012-01-01, Point(0 1)@2012-01-02),\n"
"[Point(1 1)@2012-01-03, Point(1 1)@2012-01-04),\n"
"[Point(2 1)@2012-01-05, Point(2 2)@2012-01-06)}'));\n"
"-- \"GEOMETRYCOLLECTION(POINT(1 1),LINESTRING(0 0,0 1),LINESTRING(2 1,2 2))\""
msgstr ""
"SELECT getValues(tint '[1@2012-01-01, 2@2012-01-03]');\n"
"-- \"{1,2}\"\n"
"SELECT getValues(tfloat '[1@2012-01-01, 2@2012-01-03)');\n"
"-- \"{[1,2)}\"\n"
"SELECT getValues(tfloat '{[1@2012-01-01, 2@2012-01-03), [3@2012-01-03, 4@2012-01-05)}');\n"
"-- \"{[1,2),[3,4)}\"\n"
"SELECT getValues(tfloat 'Interp=Stepwise;{[1@2012-01-01, 2@2012-01-02],\n"
"[3@2012-01-03, 4@2012-01-05]}');\n"
"-- \"{\"[1,1]\",\"[2,2]\",\"[3,3]\",\"[4,4]\"}\"\n"
"SELECT ST_AsText(getValues(tgeompoint '{[Point(0 0)@2012-01-01, Point(0 1)@2012-01-02),\n"
"[Point(0 1)@2012-01-03, Point(1 1)@2012-01-04)}'));\n"
"-- \"LINESTRING(0 0,0 1,1 1)\"\n"
"SELECT ST_AsText(getValues(tgeompoint '{[Point(0 0)@2012-01-01, Point(0 1)@2012-01-02),\n"
"[Point(1 1)@2012-01-03, Point(2 2)@2012-01-04)}'));\n"
"-- \"MULTILINESTRING((0 0,0 1),(1 1,2 2)\"\n"
"SELECT ST_AsText(getValues(tgeompoint 'Interp=Stepwise;{[Point(0 0)@2012-01-01,\n"
"Point(0 1)@2012-01-02], [Point(0 1)@2012-01-03, Point(1 1)@2012-01-04]}'));\n"
"-- \"GEOMETRYCOLLECTION(MULTIPOINT(0 0,0 1),MULTIPOINT(0 1,1 1))\"\n"
"SELECT ST_AsText(getValues(tgeompoint '{Point(0 0)@2012-01-01, Point(0 1)@2012-01-02}'));\n"
"-- \"MULTIPOINT(0 0,0 1)\"\n"
"SELECT ST_AsText(getValues(tgeompoint '{[Point(0 0)@2012-01-01, Point(0 1)@2012-01-02),\n"
"[Point(1 1)@2012-01-03, Point(1 1)@2012-01-04),\n"
"[Point(2 1)@2012-01-05, Point(2 2)@2012-01-06)}'));\n"
"-- \"GEOMETRYCOLLECTION(POINT(1 1),LINESTRING(0 0,0 1),LINESTRING(2 1,2 2))\""

#. Tag: varname
#: manipulating_temporal_types.xml:314
#, no-c-format
msgid "startValue"
msgstr "startValue"

#. Tag: para
#: manipulating_temporal_types.xml:315
#, no-c-format
msgid "Get the start value"
msgstr "Obtener el valor inicial"

#. Tag: varname
#: manipulating_temporal_types.xml:316
#, no-c-format
msgid "startValue(ttype): base"
msgstr "startValue(ttype): base"

#. Tag: para
#: manipulating_temporal_types.xml:317 manipulating_temporal_types.xml:325
#: manipulating_temporal_types.xml:333 manipulating_temporal_types.xml:341
#: manipulating_temporal_types.xml:349 manipulating_temporal_types.xml:399
#: manipulating_temporal_types.xml:407 manipulating_temporal_types.xml:435
#: manipulating_temporal_types.xml:444 manipulating_temporal_types.xml:1012
#: manipulating_temporal_types.xml:1055
#, no-c-format
msgid ""
"The function does not take into account whether the bounds are inclusive or "
"not."
msgstr "La función no tiene en cuenta si los límites son inclusivos o no."

#. Tag: programlisting
#: manipulating_temporal_types.xml:318
#, no-c-format
msgid ""
"SELECT startValue(tfloat '(1@2012-01-01, 2@2012-01-03)');\n"
"-- 1"
msgstr ""
"SELECT startValue(tfloat '(1@2012-01-01, 2@2012-01-03)');\n"
"-- 1"

#. Tag: varname
#: manipulating_temporal_types.xml:322
#, no-c-format
msgid "endValue"
msgstr "endValue"

#. Tag: para
#: manipulating_temporal_types.xml:323
#, no-c-format
msgid "Get the end value"
msgstr "Obtener el valor final"

#. Tag: varname
#: manipulating_temporal_types.xml:324
#, no-c-format
msgid "endValue(ttype): base"
msgstr "endValue(ttype): base"

#. Tag: programlisting
#: manipulating_temporal_types.xml:326
#, no-c-format
msgid ""
"SELECT endValue(tfloat '{[1@2012-01-01, 2@2012-01-03), [3@2012-01-03, 5@2012-01-05)}');\n"
"-- 5"
msgstr ""
"SELECT endValue(tfloat '{[1@2012-01-01, 2@2012-01-03), [3@2012-01-03, 5@2012-01-05)}');\n"
"-- 5"

#. Tag: varname
#: manipulating_temporal_types.xml:330
#, no-c-format
msgid "minValue"
msgstr "minValue"

#. Tag: para
#: manipulating_temporal_types.xml:331
#, no-c-format
msgid "Get the minimum value"
msgstr "Obtener el valor mínimo"

#. Tag: varname
#: manipulating_temporal_types.xml:332
#, no-c-format
msgid "minValue(torder): base"
msgstr "minValue(torder): base"

#. Tag: programlisting
#: manipulating_temporal_types.xml:334
#, no-c-format
msgid ""
"SELECT minValue(tfloat '{1@2012-01-01, 2@2012-01-03, 3@2012-01-05}');\n"
"-- 1"
msgstr ""
"SELECT minValue(tfloat '{1@2012-01-01, 2@2012-01-03, 3@2012-01-05}');\n"
"-- 1"

#. Tag: varname
#: manipulating_temporal_types.xml:338
#, no-c-format
msgid "maxValue"
msgstr "maxValue"

#. Tag: para
#: manipulating_temporal_types.xml:339
#, no-c-format
msgid "Get the maximum value"
msgstr "Obtener el valor máximo"

#. Tag: varname
#: manipulating_temporal_types.xml:340
#, no-c-format
msgid "maxValue(torder): base"
msgstr "maxValue(torder): base"

#. Tag: programlisting
#: manipulating_temporal_types.xml:342
#, no-c-format
msgid ""
"SELECT maxValue(tfloat '{[1@2012-01-01, 2@2012-01-03), [3@2012-01-03, 5@2012-01-05)}');\n"
"-- 5"
msgstr ""
"SELECT maxValue(tfloat '{[1@2012-01-01, 2@2012-01-03), [3@2012-01-03, 5@2012-01-05)}');\n"
"-- 5"

#. Tag: varname
#: manipulating_temporal_types.xml:346
#, no-c-format
msgid "valueRange"
msgstr "valueRange"

#. Tag: para
#: manipulating_temporal_types.xml:347
#, no-c-format
msgid "Get the value range"
msgstr "Obtener el rango de valores"

#. Tag: varname
#: manipulating_temporal_types.xml:348
#, no-c-format
msgid "valueRange(tnumber): numrange"
msgstr "valueRange(tnumber): numrange"

#. Tag: programlisting
#: manipulating_temporal_types.xml:350
#, no-c-format
msgid ""
"SELECT valueRange(tfloat '{[2@2012-01-01, 1@2012-01-03), [4@2012-01-03, 6@2012-01-05)}');\n"
"-- \"[1,6]\"\n"
"SELECT valueRange(tfloat '{1@2012-01-01, 2@2012-01-03, 3@2012-01-05}');\n"
"-- \"[1,3])\""
msgstr ""
"SELECT valueRange(tfloat '{[2@2012-01-01, 1@2012-01-03), [4@2012-01-03, 6@2012-01-05)}');\n"
"-- \"[1,6]\"\n"
"SELECT valueRange(tfloat '{1@2012-01-01, 2@2012-01-03, 3@2012-01-05}');\n"
"-- \"[1,3])\""

#. Tag: varname
#: manipulating_temporal_types.xml:354
#, no-c-format
msgid "valueAtTimestamp"
msgstr "valueAtTimestamp"

#. Tag: para
#: manipulating_temporal_types.xml:355
#, no-c-format
msgid "Get the value at a timestamp"
msgstr "Obtener el valor en una marca de tiempo"

#. Tag: varname
#: manipulating_temporal_types.xml:356
#, no-c-format
msgid "valueAtTimestamp(ttype, timestamptz): base"
msgstr "valueAtTimestamp(ttype, timestamptz): base"

#. Tag: programlisting
#: manipulating_temporal_types.xml:357
#, no-c-format
msgid ""
"SELECT valueAtTimestamp(tfloat '[1@2012-01-01, 4@2012-01-04)', '2012-01-02');\n"
"-- \"2\""
msgstr ""
"SELECT valueAtTimestamp(tfloat '[1@2012-01-01, 4@2012-01-04)', '2012-01-02');\n"
"-- \"2\""

#. Tag: varname
#: manipulating_temporal_types.xml:361
#, no-c-format
msgid "getTimestamp"
msgstr "getTimestamp"

#. Tag: para
#: manipulating_temporal_types.xml:362
#, no-c-format
msgid "Get the timestamp"
msgstr "Obtener la marca de tiempo"

#. Tag: varname
#: manipulating_temporal_types.xml:363
#, no-c-format
msgid "getTimestamp(ttypeinst): timestamptz"
msgstr "getTimestamp(ttypeinst): timestamptz"

#. Tag: programlisting
#: manipulating_temporal_types.xml:364
#, no-c-format
msgid ""
"SELECT getTimestamp(tint '1@2012-01-01');\n"
"-- \"2012-01-01\""
msgstr ""
"SELECT getTimestamp(tint '1@2012-01-01');\n"
"-- \"2012-01-01\""

#. Tag: varname
#: manipulating_temporal_types.xml:368
#, no-c-format
msgid "getTime"
msgstr "getTime"

#. Tag: para
#: manipulating_temporal_types.xml:369
#, no-c-format
msgid "Get the time"
msgstr "Obtener el tiempo"

#. Tag: varname
#: manipulating_temporal_types.xml:370
#, no-c-format
msgid "getTime(ttype): periodset"
msgstr "getTime(ttype): periodset"

#. Tag: programlisting
#: manipulating_temporal_types.xml:371
#, no-c-format
msgid ""
"SELECT getTime(tint '[1@2012-01-01, 1@2012-01-15)');\n"
"-- \"{[2012-01-01, 2012-01-15)}\""
msgstr ""
"SELECT getTime(tint '[1@2012-01-01, 1@2012-01-15)');\n"
"-- \"{[2012-01-01, 2012-01-15)}\""

#. Tag: varname
#: manipulating_temporal_types.xml:375
#, no-c-format
msgid "timespan"
msgstr "timespan"

#. Tag: para
#: manipulating_temporal_types.xml:376
#, no-c-format
msgid "Get the timespan"
msgstr "Obtener el intervalo de tiempo"

#. Tag: varname
#: manipulating_temporal_types.xml:377
#, no-c-format
msgid "timespan(ttype): interval"
msgstr "timespan(ttype): interval"

#. Tag: programlisting
#: manipulating_temporal_types.xml:378
#, no-c-format
msgid ""
"SELECT timespan(tfloat '{[1@2012-01-01, 2@2012-01-03), [2@2012-01-04, 2@2012-01-05)}');\n"
"-- \"3 days\""
msgstr ""
"SELECT timespan(tfloat '{[1@2012-01-01, 2@2012-01-03), [2@2012-01-04, 2@2012-01-05)}');\n"
"-- \"3 days\""

#. Tag: varname
#: manipulating_temporal_types.xml:382
#, no-c-format
msgid "period"
msgstr "period"

#. Tag: para
#: manipulating_temporal_types.xml:383
#, no-c-format
msgid ""
"Get the period on which the temporal value is defined ignoring the potential"
" time gaps"
msgstr ""
"Obtener el período en el que está definido el valor temporal ignorando las "
"posibles brechas de tiempo"

#. Tag: varname
#: manipulating_temporal_types.xml:384
#, no-c-format
msgid "period(ttype): period"
msgstr "period(ttype): period"

#. Tag: programlisting
#: manipulating_temporal_types.xml:385
#, no-c-format
msgid ""
"SELECT period(tint '{1@2012-01-01, 2@2012-01-03, 3@2012-01-05}');\n"
"-- \"[2012-01-01, 2012-01-05]\"\n"
"SELECT period(tfloat '{[1@2012-01-01, 1@2012-01-02), [2@2012-01-03, 3@2012-01-04)}');\n"
"-- \"[2012-01-01, 2012-01-04)\""
msgstr ""
"SELECT period(tint '{1@2012-01-01, 2@2012-01-03, 3@2012-01-05}');\n"
"-- \"[2012-01-01, 2012-01-05]\"\n"
"SELECT period(tfloat '{[1@2012-01-01, 1@2012-01-02), [2@2012-01-03, 3@2012-01-04)}');\n"
"-- \"[2012-01-01, 2012-01-04)\""

#. Tag: varname
#: manipulating_temporal_types.xml:389
#, no-c-format
msgid "numInstants"
msgstr "numInstants"

#. Tag: para
#: manipulating_temporal_types.xml:390
#, no-c-format
msgid "Get the number of different instants"
msgstr "Obtener el número de instantes diferentes"

#. Tag: varname
#: manipulating_temporal_types.xml:391
#, no-c-format
msgid "numInstants(ttype): int"
msgstr "numInstants(ttype): int"

#. Tag: programlisting
#: manipulating_temporal_types.xml:392
#, no-c-format
msgid ""
"SELECT numInstants(tfloat '{[1@2000-01-01, 2@2000-01-02), (2@2000-01-02, 3@2000-01-03)}');\n"
"-- 3"
msgstr ""
"SELECT numInstants(tfloat '{[1@2000-01-01, 2@2000-01-02), (2@2000-01-02, 3@2000-01-03)}');\n"
"-- 3"

#. Tag: varname
#: manipulating_temporal_types.xml:396
#, no-c-format
msgid "startInstant"
msgstr "startInstant"

#. Tag: para
#: manipulating_temporal_types.xml:397
#, no-c-format
msgid "Get the start instant"
msgstr "Obtener el instante inicial"

#. Tag: varname
#: manipulating_temporal_types.xml:398
#, no-c-format
msgid "startInstant(ttype): ttypeinst"
msgstr "startInstant(ttype): ttypeinst"

#. Tag: programlisting
#: manipulating_temporal_types.xml:400
#, no-c-format
msgid ""
"SELECT startInstant(tfloat '{[1@2000-01-01, 2@2000-01-02),\n"
"(2@2000-01-02, 3@2000-01-03)}');\n"
"-- \"1@2000-01-01\""
msgstr ""
"SELECT startInstant(tfloat '{[1@2000-01-01, 2@2000-01-02),\n"
"(2@2000-01-02, 3@2000-01-03)}');\n"
"-- \"1@2000-01-01\""

#. Tag: varname
#: manipulating_temporal_types.xml:404
#, no-c-format
msgid "endInstant"
msgstr "endInstant"

#. Tag: para
#: manipulating_temporal_types.xml:405
#, no-c-format
msgid "Get the end instant"
msgstr "Obtener el instante final"

#. Tag: varname
#: manipulating_temporal_types.xml:406
#, no-c-format
msgid "endInstant(ttype): ttypeinst"
msgstr "endInstant(ttype): ttypeinst"

#. Tag: programlisting
#: manipulating_temporal_types.xml:408
#, no-c-format
msgid ""
"SELECT endInstant(tfloat '{[1@2000-01-01, 2@2000-01-02), (2@2000-01-02, 3@2000-01-03)}');\n"
"-- \"3@2000-01-03\""
msgstr ""
"SELECT endInstant(tfloat '{[1@2000-01-01, 2@2000-01-02), (2@2000-01-02, 3@2000-01-03)}');\n"
"-- \"3@2000-01-03\""

#. Tag: varname
#: manipulating_temporal_types.xml:412
#, no-c-format
msgid "instantN"
msgstr "instantN"

#. Tag: para
#: manipulating_temporal_types.xml:413
#, no-c-format
msgid "Get the n-th different instant"
msgstr "Obtener el enésimo instante diferente"

#. Tag: varname
#: manipulating_temporal_types.xml:414
#, no-c-format
msgid "instantN(ttype, int): ttypeinst"
msgstr "instantN(ttype, int): ttypeinst"

#. Tag: programlisting
#: manipulating_temporal_types.xml:415
#, no-c-format
msgid ""
"SELECT instantN(tfloat '{[1@2000-01-01, 2@2000-01-02), (2@2000-01-02, 3@2000-01-03)}', 3);\n"
"-- \"3@2000-01-03\""
msgstr ""
"SELECT instantN(tfloat '{[1@2000-01-01, 2@2000-01-02), (2@2000-01-02, 3@2000-01-03)}', 3);\n"
"-- \"3@2000-01-03\""

#. Tag: varname
#: manipulating_temporal_types.xml:419
#, no-c-format
msgid "instants"
msgstr "instants"

#. Tag: para
#: manipulating_temporal_types.xml:420
#, no-c-format
msgid "Get the different instants"
msgstr "Obtener los instantes diferentes"

#. Tag: varname
#: manipulating_temporal_types.xml:421
#, no-c-format
msgid "instants(ttype): ttypeinst[]"
msgstr "instants(ttype): ttypeinst[]"

#. Tag: programlisting
#: manipulating_temporal_types.xml:422
#, no-c-format
msgid ""
"SELECT instants(tfloat '{[1@2000-01-01, 2@2000-01-02), (2@2000-01-02, 3@2000-01-03)}');\n"
"-- \"{\"1@2000-01-01\",\"2@2000-01-02\",\"3@2000-01-03\"}\""
msgstr ""
"SELECT instants(tfloat '{[1@2000-01-01, 2@2000-01-02), (2@2000-01-02, 3@2000-01-03)}');\n"
"-- \"{\"1@2000-01-01\",\"2@2000-01-02\",\"3@2000-01-03\"}\""

#. Tag: varname
#: manipulating_temporal_types.xml:426
#, no-c-format
msgid "numTimestamps"
msgstr "numTimestamps"

#. Tag: para
#: manipulating_temporal_types.xml:427
#, no-c-format
msgid "Get the number of different timestamps"
msgstr "Obtener el número de marcas de tiempo diferentes"

#. Tag: varname
#: manipulating_temporal_types.xml:428
#, no-c-format
msgid "numTimestamps(ttype): int"
msgstr "numTimestamps(ttype): int"

#. Tag: programlisting
#: manipulating_temporal_types.xml:429
#, no-c-format
msgid ""
"SELECT numTimestamps(tfloat '{[1@2012-01-01, 2@2012-01-03),\n"
"[3@2012-01-03, 5@2012-01-05)}');\n"
"-- 3"
msgstr ""
"SELECT numTimestamps(tfloat '{[1@2012-01-01, 2@2012-01-03),\n"
"[3@2012-01-03, 5@2012-01-05)}');\n"
"-- 3"

#. Tag: varname
#: manipulating_temporal_types.xml:433
#, no-c-format
msgid "startTimestamp"
msgstr "startTimestamp"

#. Tag: para
#: manipulating_temporal_types.xml:434
#, no-c-format
msgid "Get the start timestamp"
msgstr "Obtener la marca de tiempo inicial"

#. Tag: varname
#: manipulating_temporal_types.xml:436
#, no-c-format
msgid "startTimestamp(ttype): timestamptz"
msgstr "startTimestamp(ttype): timestamptz"

#. Tag: programlisting
#: manipulating_temporal_types.xml:437
#, no-c-format
msgid ""
"SELECT startTimestamp(tfloat '[1@2012-01-01, 2@2012-01-03)');\n"
"-- \"2012-01-01\""
msgstr ""
"SELECT startTimestamp(tfloat '[1@2012-01-01, 2@2012-01-03)');\n"
"-- \"2012-01-01\""

#. Tag: varname
#: manipulating_temporal_types.xml:441
#, no-c-format
msgid "endTimestamp"
msgstr "endTimestamp"

#. Tag: para
#: manipulating_temporal_types.xml:442
#, no-c-format
msgid "Get the end timestamp"
msgstr "Obtener la marca de tiempo final"

#. Tag: varname
#: manipulating_temporal_types.xml:443
#, no-c-format
msgid "endTimestamp(ttype): timestamptz"
msgstr "endTimestamp(ttype): timestamptz"

#. Tag: programlisting
#: manipulating_temporal_types.xml:445
#, no-c-format
msgid ""
"SELECT endTimestamp(tfloat '{[1@2012-01-01, 2@2012-01-03),\n"
"[3@2012-01-03, 5@2012-01-05)}');\n"
"-- \"2012-01-05\""
msgstr ""
"SELECT endTimestamp(tfloat '{[1@2012-01-01, 2@2012-01-03),\n"
"[3@2012-01-03, 5@2012-01-05)}');\n"
"-- \"2012-01-05\""

#. Tag: varname
#: manipulating_temporal_types.xml:449
#, no-c-format
msgid "timestampN"
msgstr "timestampN"

#. Tag: para
#: manipulating_temporal_types.xml:450
#, no-c-format
msgid "Get the n-th different timestamp"
msgstr ""
"Obtener la enésima marca de tiempo diferente\n"
"\n"
" "

#. Tag: varname
#: manipulating_temporal_types.xml:451
#, no-c-format
msgid "timestampN(ttype, int): timestamptz"
msgstr "timestampN(ttype, int): timestamptz"

#. Tag: programlisting
#: manipulating_temporal_types.xml:452
#, no-c-format
msgid ""
"SELECT timestampN(tfloat '{[1@2012-01-01, 2@2012-01-03),\n"
"[3@2012-01-03, 5@2012-01-05)}', 3);\n"
"-- \"2012-01-05\""
msgstr ""
"SELECT timestampN(tfloat '{[1@2012-01-01, 2@2012-01-03),\n"
"[3@2012-01-03, 5@2012-01-05)}', 3);\n"
"-- \"2012-01-05\""

#. Tag: varname
#: manipulating_temporal_types.xml:456
#, no-c-format
msgid "timestamps"
msgstr "timestamps"

#. Tag: para
#: manipulating_temporal_types.xml:457
#, no-c-format
msgid "Get the different timestamps"
msgstr "Obtner las marcas de tiempo diferentes"

#. Tag: varname
#: manipulating_temporal_types.xml:458
#, no-c-format
msgid "timestamps(ttype): timestamptz[]"
msgstr "timestamps(ttype): timestamptz[]"

#. Tag: programlisting
#: manipulating_temporal_types.xml:459
#, no-c-format
msgid ""
"SELECT timestamps(tfloat '{[1@2012-01-01, 2@2012-01-03), [3@2012-01-03, 5@2012-01-05)}');\n"
"-- \"{\"2012-01-01\", \"2012-01-03\", \"2012-01-05\"}\""
msgstr ""
"SELECT timestamps(tfloat '{[1@2012-01-01, 2@2012-01-03), [3@2012-01-03, 5@2012-01-05)}');\n"
"-- \"{\"2012-01-01\", \"2012-01-03\", \"2012-01-05\"}\""

#. Tag: varname
#: manipulating_temporal_types.xml:463
#, no-c-format
msgid "numSequences"
msgstr "numSequences"

#. Tag: para
#: manipulating_temporal_types.xml:464
#, no-c-format
msgid "Get the number of sequences"
msgstr "Obtener el número de secuencias"

#. Tag: varname
#: manipulating_temporal_types.xml:465
#, no-c-format
msgid "numSequences({ttypeseq,ttypes}): int"
msgstr "numSequences({ttypeseq,ttypes}): int"

#. Tag: programlisting
#: manipulating_temporal_types.xml:466
#, no-c-format
msgid ""
"SELECT numSequences(tfloat '{[1@2012-01-01, 2@2012-01-03),\n"
"[3@2012-01-03, 5@2012-01-05)}');\n"
"-- 2"
msgstr ""
"SELECT numSequences(tfloat '{[1@2012-01-01, 2@2012-01-03),\n"
"[3@2012-01-03, 5@2012-01-05)}');\n"
"-- 2"

#. Tag: varname
#: manipulating_temporal_types.xml:470
#, no-c-format
msgid "startSequence"
msgstr "startSequence"

#. Tag: para
#: manipulating_temporal_types.xml:471
#, no-c-format
msgid "Get the start sequence"
msgstr "Obtener la secuencia inicial"

#. Tag: varname
#: manipulating_temporal_types.xml:472
#, no-c-format
msgid "startSequence({ttypeseq,ttypes}): ttypeseq"
msgstr "startSequence({ttypeseq,ttypes}): ttypeseq"

#. Tag: programlisting
#: manipulating_temporal_types.xml:473
#, no-c-format
msgid ""
"SELECT startSequence(tfloat '{[1@2012-01-01, 2@2012-01-03),\n"
"[3@2012-01-03, 5@2012-01-05)}');\n"
"-- \"[1@2012-01-01, 2@2012-01-03)\""
msgstr ""
"SELECT startSequence(tfloat '{[1@2012-01-01, 2@2012-01-03),\n"
"[3@2012-01-03, 5@2012-01-05)}');\n"
"-- \"[1@2012-01-01, 2@2012-01-03)\""

#. Tag: varname
#: manipulating_temporal_types.xml:477
#, no-c-format
msgid "endSequence"
msgstr "endSequence"

#. Tag: para
#: manipulating_temporal_types.xml:478
#, no-c-format
msgid "Get the end sequence"
msgstr "Obtener la secuencia final"

#. Tag: varname
#: manipulating_temporal_types.xml:479
#, no-c-format
msgid "endSequence({ttypeseq,ttypes}): ttypeseq"
msgstr "endSequence({ttypeseq,ttypes}): ttypeseq"

#. Tag: programlisting
#: manipulating_temporal_types.xml:480
#, no-c-format
msgid ""
"SELECT endSequence(tfloat '{[1@2012-01-01, 2@2012-01-03), [3@2012-01-03, 5@2012-01-05)}');\n"
"-- \"[3@2012-01-03, 5@2012-01-05)\""
msgstr ""
"SELECT endSequence(tfloat '{[1@2012-01-01, 2@2012-01-03), [3@2012-01-03, 5@2012-01-05)}');\n"
"-- \"[3@2012-01-03, 5@2012-01-05)\""

#. Tag: varname
#: manipulating_temporal_types.xml:484
#, no-c-format
msgid "sequenceN"
msgstr "sequenceN"

#. Tag: para
#: manipulating_temporal_types.xml:485
#, no-c-format
msgid "Get the n-th sequence"
msgstr "Obtener la enésima secuencia"

#. Tag: varname
#: manipulating_temporal_types.xml:486
#, no-c-format
msgid "sequenceN({ttypeseq,ttypes}, int): ttypeseq"
msgstr "sequenceN({ttypeseq,ttypes}, int): ttypeseq"

#. Tag: programlisting
#: manipulating_temporal_types.xml:487
#, no-c-format
msgid ""
"SELECT sequenceN(tfloat '{[1@2012-01-01, 2@2012-01-03),\n"
"[3@2012-01-03, 5@2012-01-05)}', 2);\n"
"-- \"[3@2012-01-03, 5@2012-01-05)\""
msgstr ""
"SELECT sequenceN(tfloat '{[1@2012-01-01, 2@2012-01-03),\n"
"[3@2012-01-03, 5@2012-01-05)}', 2);\n"
"-- \"[3@2012-01-03, 5@2012-01-05)\""

#. Tag: varname
#: manipulating_temporal_types.xml:491
#, no-c-format
msgid "sequences"
msgstr "sequences"

#. Tag: para
#: manipulating_temporal_types.xml:492
#, no-c-format
msgid "Get the sequences"
msgstr "Obtener las secuencias"

#. Tag: varname
#: manipulating_temporal_types.xml:493
#, no-c-format
msgid "sequences({ttypeseq,ttypes}): ttypeseq[]"
msgstr "sequences({ttypeseq,ttypes}): ttypeseq[]"

#. Tag: programlisting
#: manipulating_temporal_types.xml:494
#, no-c-format
msgid ""
"SELECT sequences(tfloat '{[1@2012-01-01, 2@2012-01-03), [3@2012-01-03, 5@2012-01-05)}');\n"
"-- \"{\"[1@2012-01-01, 2@2012-01-03)\", \"[3@2012-01-03, 5@2012-01-05)\"}\""
msgstr ""
"SELECT sequences(tfloat '{[1@2012-01-01, 2@2012-01-03), [3@2012-01-03, 5@2012-01-05)}');\n"
"-- \"{\"[1@2012-01-01, 2@2012-01-03)\", \"[3@2012-01-03, 5@2012-01-05)\"}\""

#. Tag: varname
#: manipulating_temporal_types.xml:498
#, no-c-format
msgid "shift"
msgstr "shift"

#. Tag: para
#: manipulating_temporal_types.xml:499
#, no-c-format
msgid "Shift the timespan of the temporal value by an interval"
msgstr "Desplazar el intervalo de tiempo del valor temporal con un intervalo"

#. Tag: varname
#: manipulating_temporal_types.xml:500
#, no-c-format
msgid "shift(ttype, interval): ttype"
msgstr "shift(ttype, interval): ttype"

#. Tag: programlisting
#: manipulating_temporal_types.xml:501
#, no-c-format
msgid ""
"SELECT shift(tint '{1@2001-01-01, 2@2001-01-03, 1@2001-01-05}', '1 day');\n"
"-- \"{1@2001-01-02, 2@2001-01-04, 1@2001-01-06}\"\n"
"SELECT shift(tfloat '[1@2001-01-01, 2@2001-01-03]', '1 day');\n"
"-- \"[1@2001-01-02, 2@2001-01-04]\"\n"
"SELECT asText(shift(tgeompoint '{[Point(1 1)@2001-01-01, Point(2 2)@2001-01-03],\n"
"[Point(2 2)@2001-01-04, Point(1 1)@2001-01-05]}', '1 day'));\n"
"-- \"{[POINT(1 1)@2001-01-02, POINT(2 2)@2001-01-04],\n"
"[POINT(2 2)@2001-01-05, POINT(1 1)@2001-01-06]}\""
msgstr ""
"SELECT shift(tint '{1@2001-01-01, 2@2001-01-03, 1@2001-01-05}', '1 day');\n"
"-- \"{1@2001-01-02, 2@2001-01-04, 1@2001-01-06}\"\n"
"SELECT shift(tfloat '[1@2001-01-01, 2@2001-01-03]', '1 day');\n"
"-- \"[1@2001-01-02, 2@2001-01-04]\"\n"
"SELECT asText(shift(tgeompoint '{[Point(1 1)@2001-01-01, Point(2 2)@2001-01-03],\n"
"[Point(2 2)@2001-01-04, Point(1 1)@2001-01-05]}', '1 day'));\n"
"-- \"{[POINT(1 1)@2001-01-02, POINT(2 2)@2001-01-04],\n"
"[POINT(2 2)@2001-01-05, POINT(1 1)@2001-01-06]}\""

#. Tag: varname
#: manipulating_temporal_types.xml:505
#, no-c-format
msgid "tscale"
msgstr "tscale"

#. Tag: para
#: manipulating_temporal_types.xml:506
#, no-c-format
msgid ""
"Scale the time span of the temporal value to an interval. If the time span "
"of the temporal value is zero (for example, for a temporal instant), the "
"result is the temporal value. The given interval must be strictly greater "
"than zero."
msgstr ""
"Escalear el intervalo de tiempo del valor temporal a un intervalo. Si el "
"intervalo de tiempo del valor temporal es cero (por ejemplo, para un "
"instante temporal), el resultado es el valor temporal. El intervalo dado "
"debe ser estrictamente mayor que cero."

#. Tag: varname
#: manipulating_temporal_types.xml:507
#, no-c-format
msgid "tscale(ttype, interval): ttype"
msgstr "tscale(ttype, interval): ttype"

#. Tag: programlisting
#: manipulating_temporal_types.xml:508
#, no-c-format
msgid ""
"SELECT tscale(tint '1@2001-01-01', '1 day');\n"
"-- \"1@2001-01-01\"\n"
"SELECT tscale(tint '{1@2001-01-01, 2@2001-01-03, 1@2001-01-05}', '1 day');\n"
"-- \"{1@2001-01-01 00:00:00+01, 2@2001-01-01 12:00:00+01, 1@2001-01-02 00:00:00+01}\"\n"
"SELECT tscale(tfloat '[1@2001-01-01, 2@2001-01-03]', '1 day');\n"
"-- \"[1@2001-01-01, 2@2001-01-02]\"\n"
"SELECT asText(tscale(tgeompoint '{[Point(1 1)@2001-01-01, Point(2 2)@2001-01-02,\n"
"Point(1 1)@2001-01-03], [Point(2 2)@2001-01-04, Point(1 1)@2001-01-05]}', '1 day'));\n"
"-- \"{[POINT(1 1)@2001-01-01 00:00:00+01, POINT(2 2)@2001-01-01 06:00:00+01,\n"
"POINT(1 1)@2001-01-01 12:00:00+01], [POINT(2 2) @2001-01-01 18:00:00+01,\n"
"POINT(1 1)@2001-01-02 00:00:00+01]}\"\n"
"SELECT tscale(tint '1@2001-01-01', '-1 day');\n"
"-- ERROR:  The duration must be a positive interval: -1 days"
msgstr ""
"SELECT tscale(tint '1@2001-01-01', '1 day');\n"
"-- \"1@2001-01-01\"\n"
"SELECT tscale(tint '{1@2001-01-01, 2@2001-01-03, 1@2001-01-05}', '1 day');\n"
"-- \"{1@2001-01-01 00:00:00+01, 2@2001-01-01 12:00:00+01, 1@2001-01-02 00:00:00+01}\"\n"
"SELECT tscale(tfloat '[1@2001-01-01, 2@2001-01-03]', '1 day');\n"
"-- \"[1@2001-01-01, 2@2001-01-02]\"\n"
"SELECT asText(tscale(tgeompoint '{[Point(1 1)@2001-01-01, Point(2 2)@2001-01-02,\n"
"Point(1 1)@2001-01-03], [Point(2 2)@2001-01-04, Point(1 1)@2001-01-05]}', '1 day'));\n"
"-- \"{[POINT(1 1)@2001-01-01 00:00:00+01, POINT(2 2)@2001-01-01 06:00:00+01,\n"
"POINT(1 1)@2001-01-01 12:00:00+01], [POINT(2 2) @2001-01-01 18:00:00+01,\n"
"POINT(1 1)@2001-01-02 00:00:00+01]}\"\n"
"SELECT tscale(tint '1@2001-01-01', '-1 day');\n"
"-- ERROR:  The duration must be a positive interval: -1 days"

#. Tag: varname
#: manipulating_temporal_types.xml:512
#, no-c-format
msgid "shiftTscale"
msgstr "shiftTscale"

#. Tag: para
#: manipulating_temporal_types.xml:513
#, no-c-format
msgid ""
"Shift and scale the time span of the temporal value to the two intervals. "
"This function combines in a single step the functions <link "
"linkend=\"ttype_shift\"><varname>shift</varname></link> and <link "
"linkend=\"ttype_tscale\"><varname>tscale</varname></link>."
msgstr ""
"Desplazar y escalear el intervalo de tiempo del valor temporal a los dos "
"intervalos. Esta función combina en un solo paso las funciones <link "
"linkend=\"ttype_shift\"><varname>shift</varname></link> y <link "
"linkend=\"ttype_tscale\"><varname>tscale</varname></link>."

#. Tag: varname
#: manipulating_temporal_types.xml:514
#, no-c-format
msgid "shiftTscale(ttype, interval, interval): ttype"
msgstr "shiftTscale(ttype, interval, interval): ttype"

#. Tag: programlisting
#: manipulating_temporal_types.xml:515
#, no-c-format
msgid ""
"SELECT shiftTscale(tint '1@2001-01-01', '1 day', '1 day');\n"
"-- \"1@2001-01-02\"\n"
"SELECT shiftTscale(tint '{1@2001-01-01, 2@2001-01-03, 1@2001-01-05}', '1 day', '1 day');\n"
"-- \"{1@2001-01-02 00:00:00+01, 2@2001-01-02 12:00:00+01, 1@2001-01-03 00:00:00+01}\"\n"
"SELECT shiftTscale(tfloat '[1@2001-01-01, 2@2001-01-03]', '1 day', '1 day');\n"
"-- \"[1@2001-01-02, 2@2001-01-03]\"\n"
"SELECT asText(shiftTscale(tgeompoint '{[Point(1 1)@2001-01-01, Point(2 2)@2001-01-02,\n"
"Point(1 1)@2001-01-03], [Point(2 2)@2001-01-04, Point(1 1)@2001-01-05]}',\n"
"'1 day', '1 day'));\n"
"-- \"{[POINT(1 1)@2001-01-02 00:00:00+01, POINT(2 2)@2001-01-02 06:00:00+01,\n"
"POINT(1 1)@2001-01-02 12:00:00+01], [POINT(2 2) @2001-01-02 18:00:00+01,\n"
"POINT(1 1)@2001-01-03 00:00:00+01]}\""
msgstr ""
"SELECT shiftTscale(tint '1@2001-01-01', '1 day', '1 day');\n"
"-- \"1@2001-01-02\"\n"
"SELECT shiftTscale(tint '{1@2001-01-01, 2@2001-01-03, 1@2001-01-05}', '1 day', '1 day');\n"
"-- \"{1@2001-01-02 00:00:00+01, 2@2001-01-02 12:00:00+01, 1@2001-01-03 00:00:00+01}\"\n"
"SELECT shiftTscale(tfloat '[1@2001-01-01, 2@2001-01-03]', '1 day', '1 day');\n"
"-- \"[1@2001-01-02, 2@2001-01-03]\"\n"
"SELECT asText(shiftTscale(tgeompoint '{[Point(1 1)@2001-01-01, Point(2 2)@2001-01-02,\n"
"Point(1 1)@2001-01-03], [Point(2 2)@2001-01-04, Point(1 1)@2001-01-05]}',\n"
"'1 day', '1 day'));\n"
"-- \"{[POINT(1 1)@2001-01-02 00:00:00+01, POINT(2 2)@2001-01-02 06:00:00+01,\n"
"POINT(1 1)@2001-01-02 12:00:00+01], [POINT(2 2) @2001-01-02 18:00:00+01,\n"
"POINT(1 1)@2001-01-03 00:00:00+01]}\""

#. Tag: varname
#: manipulating_temporal_types.xml:519
#, no-c-format
msgid "intersectsTimestamp"
msgstr "intersectsTimestamp"

#. Tag: para
#: manipulating_temporal_types.xml:520
#, no-c-format
msgid "Does the temporal value intersect the timestamp?"
msgstr "¿El valor temporal se cruza con la marca de tiempo?"

#. Tag: varname
#: manipulating_temporal_types.xml:521
#, no-c-format
msgid "intersectsTimestamp(ttype, timestamptz): boolean"
msgstr "intersectsTimestamp(ttype, timestamptz): boolean"

#. Tag: programlisting
#: manipulating_temporal_types.xml:522
#, no-c-format
msgid ""
"SELECT intersectsTimestamp(tint '[1@2012-01-01, 1@2012-01-15)', timestamptz '2012-01-03');\n"
"-- true"
msgstr ""
"SELECT intersectsTimestamp(tint '[1@2012-01-01, 1@2012-01-15)', timestamptz '2012-01-03');\n"
"-- true"

#. Tag: varname
#: manipulating_temporal_types.xml:526
#, no-c-format
msgid "intersectsTimestampSet"
msgstr "intersectsTimestampSet"

#. Tag: para
#: manipulating_temporal_types.xml:527
#, no-c-format
msgid "Does the temporal value intersect the timestamp set?"
msgstr "¿El valor temporal se cruza con el conjunto de marcas tiempo?"

#. Tag: varname
#: manipulating_temporal_types.xml:528
#, no-c-format
msgid "intersectsTimestampSet(ttype, timestampset): boolean"
msgstr "intersectsTimestampSet(ttype, timestampset): boolean"

#. Tag: programlisting
#: manipulating_temporal_types.xml:529
#, no-c-format
msgid ""
"SELECT intersectsTimestampSet(tint '[1@2012-01-01, 1@2012-01-15)',\n"
"timestampset '{2012-01-01, 2012-01-03}');\n"
"-- true"
msgstr ""
"SELECT intersectsTimestampSet(tint '[1@2012-01-01, 1@2012-01-15)',\n"
"timestampset '{2012-01-01, 2012-01-03}');\n"
"-- true"

#. Tag: varname
#: manipulating_temporal_types.xml:533
#, no-c-format
msgid "intersectsPeriod"
msgstr "intersectsPeriod"

#. Tag: para
#: manipulating_temporal_types.xml:534
#, no-c-format
msgid "Does the temporal value intersect the period?"
msgstr "¿El valor temporal se cruza con el período?"

#. Tag: varname
#: manipulating_temporal_types.xml:535
#, no-c-format
msgid "intersectsPeriod(ttype, period): boolean"
msgstr "intersectsPeriod(ttype, period): boolean"

#. Tag: programlisting
#: manipulating_temporal_types.xml:536
#, no-c-format
msgid ""
"SELECT intersectsPeriod(tint '[1@2012-01-01, 1@2012-01-04)',\n"
"period '[2012-01-01,2012-01-05)');\n"
"-- true"
msgstr ""
"SELECT intersectsPeriod(tint '[1@2012-01-01, 1@2012-01-04)',\n"
"period '[2012-01-01,2012-01-05)');\n"
"-- true"

#. Tag: varname
#: manipulating_temporal_types.xml:540
#, no-c-format
msgid "intersectsPeriodSet"
msgstr "intersectsPeriodSet"

#. Tag: para
#: manipulating_temporal_types.xml:541
#, no-c-format
msgid "Does the temporal value intersect the period set?"
msgstr "¿El valor temporal se cruza con el conjunto de períodos?"

#. Tag: varname
#: manipulating_temporal_types.xml:542
#, no-c-format
msgid "intersectsPeriodSet(ttype, periodset): boolean"
msgstr "intersectsPeriodSet(ttype, periodset): boolean"

#. Tag: programlisting
#: manipulating_temporal_types.xml:543
#, no-c-format
msgid ""
"SELECT intersectsPeriodSet(tbool '[t@2012-01-01, f@2012-01-15]',\n"
"periodset '{[2012-01-01, 2012-01-03), [2012-01-05, 2012-01-07)}');\n"
"-- true"
msgstr ""
"SELECT intersectsPeriodSet(tbool '[t@2012-01-01, f@2012-01-15]',\n"
"periodset '{[2012-01-01, 2012-01-03), [2012-01-05, 2012-01-07)}');\n"
"-- true"

#. Tag: varname
#: manipulating_temporal_types.xml:547
#, no-c-format
msgid "twAvg"
msgstr "twAvg"

#. Tag: para
#: manipulating_temporal_types.xml:548
#, no-c-format
msgid "Get the time-weighted average"
msgstr "Obtener el promedio ponderado en el tiempo"

#. Tag: varname
#: manipulating_temporal_types.xml:549
#, no-c-format
msgid "twAvg(tnumber): float"
msgstr "twAvg(tnumber): float"

#. Tag: programlisting
#: manipulating_temporal_types.xml:550
#, no-c-format
msgid ""
"SELECT twAvg(tfloat '{[1@2012-01-01, 2@2012-01-03), [2@2012-01-04, 2@2012-01-06)}');\n"
"-- 1.75"
msgstr ""
"SELECT twAvg(tfloat '{[1@2012-01-01, 2@2012-01-03), [2@2012-01-04, 2@2012-01-06)}');\n"
"-- 1.75"

#. Tag: title
#: manipulating_temporal_types.xml:556
#, no-c-format
msgid "Spatial Functions"
msgstr "Funciones espaciales"

#. Tag: para
#: manipulating_temporal_types.xml:557
#, no-c-format
msgid ""
"In the following, we specify with the symbol &Z_support; that the function "
"supports 3D points and with the symbol &geography_support; that the function"
" is available for geographies."
msgstr ""
"A continuación, especificamos con el símbolo &Z_support; que la función "
"admite puntos 3D y con el  símbolo &geography_support; que la función está "
"disponible para geografías."

#. Tag: varname
#: manipulating_temporal_types.xml:561
#, no-c-format
msgid "asText"
msgstr "asText"

#. Tag: para
#: manipulating_temporal_types.xml:562
#, no-c-format
msgid ""
"Get the Well-Known Text (WKT) representation &Z_support; &geography_support;"
msgstr ""
"Obtener la representación de texto conocido (Well-Known Text o WKT) "
"&Z_support; &geography_support;"

#. Tag: varname
#: manipulating_temporal_types.xml:563
#, no-c-format
msgid "asText({tpoint, tpoint[], geo[]}): {text, text[]}"
msgstr "asText({tpoint, tpoint[], geo[]}): {text, text[]}"

#. Tag: programlisting
#: manipulating_temporal_types.xml:564
#, no-c-format
msgid ""
"SELECT asText(tgeompoint 'SRID=4326;[Point(0 0 0)@2012-01-01, Point(1 1 1)@2012-01-02)');\n"
"-- \"[POINT Z (0 0 0)@2012-01-01 00:00:00+00, POINT Z (1 1 1)@2012-01-02 00:00:00+00)\"\n"
"SELECT asText(ARRAY[geometry 'Point(0 0)', 'Point(1 1)']);\n"
"-- \"{\"POINT(0 0)\",\"POINT(1 1)\"}\""
msgstr ""
"SELECT asText(tgeompoint 'SRID=4326;[Point(0 0 0)@2012-01-01, Point(1 1 1)@2012-01-02)');\n"
"-- \"[POINT Z (0 0 0)@2012-01-01 00:00:00+00, POINT Z (1 1 1)@2012-01-02 00:00:00+00)\"\n"
"SELECT asText(ARRAY[geometry 'Point(0 0)', 'Point(1 1)']);\n"
"-- \"{\"POINT(0 0)\",\"POINT(1 1)\"}\""

#. Tag: varname
#: manipulating_temporal_types.xml:568
#, no-c-format
msgid "asEWKT"
msgstr "asEWKT"

#. Tag: para
#: manipulating_temporal_types.xml:569
#, no-c-format
msgid ""
"Get the Extended Well-Known Text (EWKT) representation &Z_support; "
"&geography_support;"
msgstr ""
"Obtener la representación extendida de texto conocido (Extended Well-Known "
"Text o EWKT)"

#. Tag: varname
#: manipulating_temporal_types.xml:570
#, no-c-format
msgid "asEWKT({tpoint, tpoint[], geo[]}): {text, text[]}"
msgstr "asEWKT({tpoint, tpoint[], geo[]}): {text, text[]}"

#. Tag: programlisting
#: manipulating_temporal_types.xml:571
#, no-c-format
msgid ""
"SELECT asEWKT(tgeompoint 'SRID=4326;[Point(0 0 0)@2012-01-01, Point(1 1 1)@2012-01-02)');\n"
"-- \"SRID=4326;[POINT Z (0 0 0)@2012-01-01 00:00:00+00,\n"
"POINT Z (1 1 1)@2012-01-02 00:00:00+00)\"\n"
"SELECT asEWKT(ARRAY[geometry 'SRID=5676;Point(0 0)', 'SRID=5676;Point(1 1)']);\n"
"-- \"{\"SRID=5676;POINT(0 0)\",\"SRID=5676;POINT(1 1)\"}\""
msgstr ""
"SELECT asEWKT(tgeompoint 'SRID=4326;[Point(0 0 0)@2012-01-01, Point(1 1 1)@2012-01-02)');\n"
"-- \"SRID=4326;[POINT Z (0 0 0)@2012-01-01 00:00:00+00,\n"
"POINT Z (1 1 1)@2012-01-02 00:00:00+00)\"\n"
"SELECT asEWKT(ARRAY[geometry 'SRID=5676;Point(0 0)', 'SRID=5676;Point(1 1)']);\n"
"-- \"{\"SRID=5676;POINT(0 0)\",\"SRID=5676;POINT(1 1)\"}\""

#. Tag: varname
#: manipulating_temporal_types.xml:575
#, no-c-format
msgid "asMFJSON"
msgstr "asMFJSON"

#. Tag: para
#: manipulating_temporal_types.xml:576
#, no-c-format
msgid ""
"Get the Moving Features JSON representation &Z_support; &geography_support;"
msgstr ""
"Obtener la representación JSON de característica móviles (Moving Features) "
"&Z_support; &geography_support;"

#. Tag: varname
#: manipulating_temporal_types.xml:577
#, no-c-format
msgid ""
"asMFJSON(tpoint, maxdecdigits int4 DEFAULT 15, options int4 DEFAULT 0): "
"bytea"
msgstr ""
"asMFJSON(tpoint, maxdecdigits int4 DEFAULT 15, options int4 DEFAULT 0): "
"bytea"

#. Tag: para
#: manipulating_temporal_types.xml:578
#, no-c-format
msgid ""
"The last <varname>options</varname> argument could be used to add BBOX "
"and/or CRS in MFJSON output:"
msgstr ""
"El último argumento <varname>options</varname> puede usarse para agregar "
"BBOX y / o CRS en la salida MFJSON:"

#. Tag: para
#: manipulating_temporal_types.xml:580
#, no-c-format
msgid "0: means no option (default value)"
msgstr "0: significa que no hay opción (valor por defecto)"

#. Tag: para
#: manipulating_temporal_types.xml:581
#, no-c-format
msgid "1: MFJSON BBOX"
msgstr "1: MFJSON BBOX"

#. Tag: para
#: manipulating_temporal_types.xml:582
#, no-c-format
msgid "2: MFJSON Short CRS (e.g EPSG:4326)"
msgstr "2: MFJSON Short CRS (e.g EPSG:4326)"

#. Tag: para
#: manipulating_temporal_types.xml:583
#, no-c-format
msgid "4: MFJSON Long CRS (e.g urn:ogc:def:crs:EPSG::4326)"
msgstr "4: MFJSON Long CRS (e.g urn:ogc:def:crs:EPSG::4326)"

#. Tag: programlisting
#: manipulating_temporal_types.xml:585
#, no-c-format
msgid ""
"SELECT asMFJSON(tgeompoint 'Point(1 2)@2019-01-01 18:00:00.15+02');\n"
"-- \"{\"type\":\"MovingPoint\",\"coordinates\":[1,2],\"datetimes\":\"2019-01-01T17:00:00.15+01\",\n"
"\"interpolations\":[\"Discrete\"]}\"\n"
"SELECT asMFJSON(tgeompoint 'SRID=4326;\n"
"Point(50.813810 4.384260)@2019-01-01 18:00:00.15+02', 2, 3);\n"
"-- \"{\"type\":\"MovingPoint\",\"crs\":{\"type\":\"name\",\"properties\":{\"name\":\"EPSG:4326\"}},\n"
"\"stBoundedBy\":{\"bbox\":[50.81,4.38,50.81,4.38],\n"
"\"period\":{\"begin\":\"2019-01-01 17:00:00.15+01\",\"end\":\"2019-01-01 17:00:00.15+01\"}},\n"
"\"coordinates\":[50.81,4.38],\"datetimes\":\"2019-01-01T17:00:00.15+01\",\n"
"\"interpolations\":[\"Discrete\"]}\""
msgstr ""
"SELECT asMFJSON(tgeompoint 'Point(1 2)@2019-01-01 18:00:00.15+02');\n"
"-- \"{\"type\":\"MovingPoint\",\"coordinates\":[1,2],\"datetimes\":\"2019-01-01T17:00:00.15+01\",\n"
"\"interpolations\":[\"Discrete\"]}\"\n"
"SELECT asMFJSON(tgeompoint 'SRID=4326;\n"
"Point(50.813810 4.384260)@2019-01-01 18:00:00.15+02', 2, 3);\n"
"-- \"{\"type\":\"MovingPoint\",\"crs\":{\"type\":\"name\",\"properties\":{\"name\":\"EPSG:4326\"}},\n"
"\"stBoundedBy\":{\"bbox\":[50.81,4.38,50.81,4.38],\n"
"\"period\":{\"begin\":\"2019-01-01 17:00:00.15+01\",\"end\":\"2019-01-01 17:00:00.15+01\"}},\n"
"\"coordinates\":[50.81,4.38],\"datetimes\":\"2019-01-01T17:00:00.15+01\",\n"
"\"interpolations\":[\"Discrete\"]}\""

#. Tag: varname
#: manipulating_temporal_types.xml:589
#, no-c-format
msgid "asBinary"
msgstr "asBinary"

#. Tag: para
#: manipulating_temporal_types.xml:590
#, no-c-format
msgid ""
"Get the Well-Known Binary (WKB) representation &Z_support; "
"&geography_support;"
msgstr ""
"Obtener la representación binaria conocida (Well-Known Binary o WKB) "
"&Z_support; &geography_support;"

#. Tag: varname
#: manipulating_temporal_types.xml:591
#, no-c-format
msgid "asBinary(tpoint): bytea"
msgstr "asBinary(tpoint): bytea"

#. Tag: varname
#: manipulating_temporal_types.xml:592
#, no-c-format
msgid "asBinary(tpoint, text): bytea"
msgstr "asBinary(tpoint, text): bytea"

#. Tag: para
#: manipulating_temporal_types.xml:593 manipulating_temporal_types.xml:602
#, no-c-format
msgid ""
"The result is encoded using either the little-endian (NDR) or the big-endian"
" (XDR) encoding. If no encoding is specified, then the encoding of the "
"machine is used."
msgstr ""
"El resultado se codifica utilizando la codificación little-endian (NDR) o "
"big-endian (XDR). Si no se especifica ninguna codificación, se utiliza la "
"codificación de la máquina."

#. Tag: programlisting
#: manipulating_temporal_types.xml:594
#, no-c-format
msgid ""
"SELECT asBinary(tgeompoint 'SRID=4326;Point(1 2 3)@2012-01-01');\n"
"-- \"\\001\\001\\000\\000\\000\\000\\000\\000\\360?\\000\\000\\000\\000\\000\\000\\000@\\000\\000\\000\\000\\000\\000\\010@\\000\\374\\340\\023jX\\001\\000\""
msgstr ""
"SELECT asBinary(tgeompoint 'SRID=4326;Point(1 2 3)@2012-01-01');\n"
"-- \"\\001\\001\\000\\000\\000\\000\\000\\000\\360?\\000\\000\\000\\000\\000\\000\\000@\\000\\000\\000\\000\\000\\000\\010@\\000\\374\\340\\023jX\\001\\000\""

#. Tag: varname
#: manipulating_temporal_types.xml:598
#, no-c-format
msgid "asEWKB"
msgstr "asEWKB"

#. Tag: para
#: manipulating_temporal_types.xml:599
#, no-c-format
msgid ""
"Get the Extended Well-Known Binary (EWKB) representation &Z_support; "
"&geography_support;"
msgstr ""
"Obtener la representación binaria extendida conocida (Extended Well-Known "
"Binary o EWKB) &Z_support; &geography_support;"

#. Tag: varname
#: manipulating_temporal_types.xml:600
#, no-c-format
msgid "asEWKB(tpoint): bytea"
msgstr "asEWKB(tpoint): bytea"

#. Tag: varname
#: manipulating_temporal_types.xml:601
#, no-c-format
msgid "asEWKB(tpoint, text): bytea"
msgstr "asEWKB(tpoint, text): bytea"

#. Tag: programlisting
#: manipulating_temporal_types.xml:603
#, no-c-format
msgid ""
"SELECT asEWKB(tgeompoint 'SRID=4326;Point(1 2 3)@2012-01-01');\n"
"-- \"\\0011\\346\\020\\000\\000\\000\\000\\000\\000\\000\\000\\360?\\000\\000\\000\\000\\000\\000\\000@\\000\\000\\000\\000\\000\\000\\010@\\000\\374\\340\\023jX\\001\\000\""
msgstr ""
"SELECT asEWKB(tgeompoint 'SRID=4326;Point(1 2 3)@2012-01-01');\n"
"-- \"\\0011\\346\\020\\000\\000\\000\\000\\000\\000\\000\\000\\360?\\000\\000\\000\\000\\000\\000\\000@\\000\\000\\000\\000\\000\\000\\010@\\000\\374\\340\\023jX\\001\\000\""

#. Tag: varname
#: manipulating_temporal_types.xml:607
#, no-c-format
msgid "asHexEWKB"
msgstr "asHexEWKB"

#. Tag: para
#: manipulating_temporal_types.xml:608
#, no-c-format
msgid ""
"Get the Hexadecimal Extended Well-Known Binary (EWKB) representation as text"
" &Z_support; &geography_support;"
msgstr ""
"Obtener la representación hexadecimal binaria extendida conocida (Extended "
"Well-Known Binary o EWKB) en formato texto &Z_support; &geography_support;"

#. Tag: varname
#: manipulating_temporal_types.xml:609
#, no-c-format
msgid "asHexEWKB(tpoint): text"
msgstr "asHexEWKB(tpoint): text"

#. Tag: varname
#: manipulating_temporal_types.xml:610
#, no-c-format
msgid "asHexEWKB(tpoint, text): text"
msgstr "asHexEWKB(tpoint, text): text"

#. Tag: para
#: manipulating_temporal_types.xml:611
#, no-c-format
msgid ""
"The result is encoded using either the little-endian (NDR) or the big-endian"
" (XDR) encoding. If no encoding is specified, then NDR is used."
msgstr ""
"El resultado se codifica utilizando la codificación little-endian (NDR) o "
"big-endian (XDR). Si no se especifica ninguna codificación, se utiliza NDR."

#. Tag: programlisting
#: manipulating_temporal_types.xml:612
#, no-c-format
msgid ""
"SELECT asHexEWKB(tgeompoint 'SRID=4326;Point(1 2 3)@2012-01-01');\n"
"-- \"0131E6100000000000000000F03F0000000000000040000000000000084000FCE0136A580100\""
msgstr ""
"SELECT asHexEWKB(tgeompoint 'SRID=4326;Point(1 2 3)@2012-01-01');\n"
"-- \"0131E6100000000000000000F03F0000000000000040000000000000084000FCE0136A580100\""

#. Tag: varname
#: manipulating_temporal_types.xml:616
#, no-c-format
msgid "fromMFJSON"
msgstr "fromMFJSON"

#. Tag: para
#: manipulating_temporal_types.xml:617
#, no-c-format
msgid ""
"Input a temporal point from a Moving Features JSON representation "
"&Z_support; &geography_support;"
msgstr ""
"Entrar un punto temporal en una representación JSON de características "
"móviles (Moving Features) &Z_support; &geography_support;"

#. Tag: varname
#: manipulating_temporal_types.xml:618
#, no-c-format
msgid "fromMFJSON(text): tpoint"
msgstr "fromMFJSON(text): tpoint"

#. Tag: programlisting
#: manipulating_temporal_types.xml:619
#, no-c-format
msgid ""
"SELECT asEWKT(fromMFJSON(text '{\"type\":\"MovingPoint\",\"crs\":{\"type\":\"name\",\n"
"\"properties\":{\"name\":\"EPSG:4326\"}},\"coordinates\":[50.81,4.38],\n"
"\"datetimes\":\"2019-01-01T17:00:00.15+01\",\"interpolations\":[\"Discrete\"]}'));\n"
"-- \"SRID=4326;POINT(50.81 4.38)@2019-01-01 17:00:00.15+01\""
msgstr ""
"SELECT asEWKT(fromMFJSON(text '{\"type\":\"MovingPoint\",\"crs\":{\"type\":\"name\",\n"
"\"properties\":{\"name\":\"EPSG:4326\"}},\"coordinates\":[50.81,4.38],\n"
"\"datetimes\":\"2019-01-01T17:00:00.15+01\",\"interpolations\":[\"Discrete\"]}'));\n"
"-- \"SRID=4326;POINT(50.81 4.38)@2019-01-01 17:00:00.15+01\""

#. Tag: varname
#: manipulating_temporal_types.xml:623
#, no-c-format
msgid "fromEWKB"
msgstr "fromEWKB"

#. Tag: para
#: manipulating_temporal_types.xml:624
#, no-c-format
msgid ""
"Input a temporal point from an Extended Well-Known Binary (EWKB) "
"representation &Z_support; &geography_support;"
msgstr ""
"Entrar un punto temporal en una representación binaria extendida conocida "
"(EWKB) &Z_support; &geography_support;"

#. Tag: varname
#: manipulating_temporal_types.xml:625
#, no-c-format
msgid "fromEWKB(bytea): tpoint"
msgstr "fromEWKB(bytea): tpoint"

#. Tag: programlisting
#: manipulating_temporal_types.xml:626
#, no-c-format
msgid ""
"SELECT asEWKT(fromEWKB(bytea\n"
"'\\0011\\346\\020\\000\\000\\000\\000\\000\\000\\000\\000\\360?\\000\\000\\000\\000\\000\\000\\000@\\000\\000\\000\\000\\000\\000\\010@\\000\\374\\340\\023jX\\001\\000'));\n"
"-- \"SRID=4326;POINT Z (1 2 3)@2012-01-01 00:00:00+01\""
msgstr ""
"SELECT asEWKT(fromEWKB(bytea\n"
"'\\0011\\346\\020\\000\\000\\000\\000\\000\\000\\000\\000\\360?\\000\\000\\000\\000\\000\\000\\000@\\000\\000\\000\\000\\000\\000\\010@\\000\\374\\340\\023jX\\001\\000'));\n"
"-- \"SRID=4326;POINT Z (1 2 3)@2012-01-01 00:00:00+01\""

#. Tag: varname
#: manipulating_temporal_types.xml:630
#, no-c-format
msgid "SRID"
msgstr "SRID"

#. Tag: para
#: manipulating_temporal_types.xml:631
#, no-c-format
msgid "Get the spatial reference identifier &Z_support; &geography_support;"
msgstr ""
"Obtener el identificador de referencia espacial &Z_support; "
"&geography_support;"

#. Tag: varname
#: manipulating_temporal_types.xml:632
#, no-c-format
msgid "SRID(tpoint): integer"
msgstr "SRID(tpoint): integer"

#. Tag: programlisting
#: manipulating_temporal_types.xml:633
#, no-c-format
msgid ""
"SELECT SRID(tgeompoint 'Point(0 0)@2012-01-01');\n"
"-- 0"
msgstr ""
"SELECT SRID(tgeompoint 'Point(0 0)@2012-01-01');\n"
"-- 0"

#. Tag: varname
#: manipulating_temporal_types.xml:637
#, no-c-format
msgid "setSRID"
msgstr "setSRID"

#. Tag: para
#: manipulating_temporal_types.xml:638
#, no-c-format
msgid "Set the spatial reference identifier &Z_support; &geography_support;"
msgstr ""
"Establecer el identificador de referencia espacial &Z_support; "
"&geography_support;"

#. Tag: varname
#: manipulating_temporal_types.xml:639
#, no-c-format
msgid "setSRID(tpoint): tpoint"
msgstr "setSRID(tpoint): tpoint"

#. Tag: programlisting
#: manipulating_temporal_types.xml:640
#, no-c-format
msgid ""
"SELECT asEWKT(setSRID(tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-02)', 4326));\n"
"-- \"SRID=4326;[POINT(0 0)@2012-01-01 00:00:00+00, POINT(1 1)@2012-01-02 00:00:00+00)\""
msgstr ""
"SELECT asEWKT(setSRID(tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-02)', 4326));\n"
"-- \"SRID=4326;[POINT(0 0)@2012-01-01 00:00:00+00, POINT(1 1)@2012-01-02 00:00:00+00)\""

#. Tag: varname
#: manipulating_temporal_types.xml:644
#, no-c-format
msgid "transform"
msgstr "transform"

#. Tag: para
#: manipulating_temporal_types.xml:645
#, no-c-format
msgid ""
"Transform to a different spatial reference &Z_support; &geography_support;"
msgstr ""
"Transformar a una referencia espacial diferente &Z_support; "
"&geography_support;"

#. Tag: varname
#: manipulating_temporal_types.xml:646
#, no-c-format
msgid "transform(tpoint, integer): tpoint"
msgstr "transform(tpoint, integer): tpoint"

#. Tag: programlisting
#: manipulating_temporal_types.xml:647
#, no-c-format
msgid ""
"SELECT asEWKT(transform(tgeompoint 'SRID=4326;Point(4.35 50.85)@2012-01-01', 3812));\n"
"-- \"SRID=3812;POINT(648679.018035303 671067.055638114)@2012-01-01 00:00:00+00\""
msgstr ""
"SELECT asEWKT(transform(tgeompoint 'SRID=4326;Point(4.35 50.85)@2012-01-01', 3812));\n"
"-- \"SRID=3812;POINT(648679.018035303 671067.055638114)@2012-01-01 00:00:00+00\""

#. Tag: varname
#: manipulating_temporal_types.xml:651
#, no-c-format
msgid "setPrecision"
msgstr "setPrecision"

#. Tag: para
#: manipulating_temporal_types.xml:652
#, no-c-format
msgid ""
"Round the coordinate values to a number of decimal places &Z_support; "
"&geography_support;"
msgstr ""
"Redondear los valores de las coordenadas a un número de decimales "
"&Z_support; &geography_support;"

#. Tag: varname
#: manipulating_temporal_types.xml:653
#, no-c-format
msgid "setPrecision(tpoint, int): tpoint"
msgstr "setPrecision(tpoint, int): tpoint"

#. Tag: programlisting
#: manipulating_temporal_types.xml:654
#, no-c-format
msgid ""
"SELECT asText(setPrecision(tgeompoint '{Point(1.12345 1.12345 1.12345)@2000-01-01,\n"
"Point(2 2 2)@2000-01-02, Point(1.12345 1.12345 1.12345)@2000-01-03}', 2));\n"
"-- \"{POINT Z (1.12 1.12 1.12)@2000-01-01, POINT Z (2 2 2)@2000-01-02,\n"
"POINT Z (1.12 1.12 1.12)@2000-01-03}\"\n"
"SELECT asText(setPrecision(tgeogpoint 'Point(1.12345 1.12345)@2000-01-01', 2));\n"
"-- \"POINT(1.12 1.12)@2000-01-01\""
msgstr ""
"SELECT asText(setPrecision(tgeompoint '{Point(1.12345 1.12345 1.12345)@2000-01-01,\n"
"Point(2 2 2)@2000-01-02, Point(1.12345 1.12345 1.12345)@2000-01-03}', 2));\n"
"-- \"{POINT Z (1.12 1.12 1.12)@2000-01-01, POINT Z (2 2 2)@2000-01-02,\n"
"POINT Z (1.12 1.12 1.12)@2000-01-03}\"\n"
"SELECT asText(setPrecision(tgeogpoint 'Point(1.12345 1.12345)@2000-01-01', 2));\n"
"-- \"POINT(1.12 1.12)@2000-01-01\""

#. Tag: varname
#: manipulating_temporal_types.xml:658
#, no-c-format
msgid "length"
msgstr "length"

#. Tag: para
#: manipulating_temporal_types.xml:659
#, no-c-format
msgid ""
"Get the length traversed by the temporal point &Z_support; "
"&geography_support;"
msgstr ""
"Obtener la longitud atravesada por el punto temporal &Z_support; "
"&geography_support;"

#. Tag: varname
#: manipulating_temporal_types.xml:660
#, no-c-format
msgid "length(tpoint): float"
msgstr "length(tpoint): float"

#. Tag: programlisting
#: manipulating_temporal_types.xml:661
#, no-c-format
msgid ""
"SELECT length(tgeompoint '[Point(0 0 0)@2000-01-01, Point(1 1 1)@2000-01-02]');\n"
"-- 1.73205080756888\n"
"SELECT length(tgeompoint '[Point(0 0 0)@2000-01-01, Point(1 1 1)@2000-01-02,\n"
"Point(0 0 0)@2000-01-03]');\n"
"-- 3.46410161513775\n"
"SELECT length(tgeompoint 'Interp=Stepwise;[Point(0 0 0)@2000-01-01, Point(1 1 1)@2000-01-02,\n"
"Point(0 0 0)@2000-01-03]');\n"
"-- 0"
msgstr ""
"SELECT length(tgeompoint '[Point(0 0 0)@2000-01-01, Point(1 1 1)@2000-01-02]');\n"
"-- 1.73205080756888\n"
"SELECT length(tgeompoint '[Point(0 0 0)@2000-01-01, Point(1 1 1)@2000-01-02,\n"
"Point(0 0 0)@2000-01-03]');\n"
"-- 3.46410161513775\n"
"SELECT length(tgeompoint 'Interp=Stepwise;[Point(0 0 0)@2000-01-01, Point(1 1 1)@2000-01-02,\n"
"Point(0 0 0)@2000-01-03]');\n"
"-- 0"

#. Tag: varname
#: manipulating_temporal_types.xml:665
#, no-c-format
msgid "cumulativeLength"
msgstr "cumulativeLength"

#. Tag: para
#: manipulating_temporal_types.xml:666
#, no-c-format
msgid ""
"Get the cumulative length traversed by the temporal point &Z_support; "
"&geography_support;"
msgstr ""
"Obtener la longitud acumulada atravesada por el punto temporal &Z_support; "
"&geography_support;"

#. Tag: varname
#: manipulating_temporal_types.xml:667
#, no-c-format
msgid "cumulativeLength(tpoint): tfloatseq"
msgstr "cumulativeLength(tpoint): tfloatseq"

#. Tag: programlisting
#: manipulating_temporal_types.xml:668
#, no-c-format
msgid ""
"SELECT cumulativeLength(tgeompoint\n"
"'{[Point(0 0)@2000-01-01, Point(1 1)@2000-01-02, Point(1 0)@2000-01-03],\n"
"[Point(1 0)@2000-01-04, Point(0 0)@2000-01-05]}');\n"
"-- \"{[0@2000-01-01, 1.4142135623731@2000-01-02, 2.41421356237309@2000-01-03],\n"
"[2.41421356237309@2000-01-04, 3.41421356237309@2000-01-05]}\"\n"
"SELECT cumulativeLength(tgeompoint 'Interp=Stepwise;[Point(0 0 0)@2000-01-01, Point(1 1 1)@2000-01-02,\n"
"Point(0 0 0)@2000-01-03]');\n"
"-- \"Interp=Stepwise;[0@2000-01-01, 0@2000-01-02, 0@2000-01-03]\""
msgstr ""
"SELECT cumulativeLength(tgeompoint\n"
"'{[Point(0 0)@2000-01-01, Point(1 1)@2000-01-02, Point(1 0)@2000-01-03],\n"
"[Point(1 0)@2000-01-04, Point(0 0)@2000-01-05]}');\n"
"-- \"{[0@2000-01-01, 1.4142135623731@2000-01-02, 2.41421356237309@2000-01-03],\n"
"[2.41421356237309@2000-01-04, 3.41421356237309@2000-01-05]}\"\n"
"SELECT cumulativeLength(tgeompoint 'Interp=Stepwise;[Point(0 0 0)@2000-01-01, Point(1 1 1)@2000-01-02,\n"
"Point(0 0 0)@2000-01-03]');\n"
"-- \"Interp=Stepwise;[0@2000-01-01, 0@2000-01-02, 0@2000-01-03]\""

#. Tag: varname
#: manipulating_temporal_types.xml:672
#, no-c-format
msgid "speed"
msgstr "speed"

#. Tag: para
#: manipulating_temporal_types.xml:673
#, no-c-format
msgid ""
"Get the speed of the temporal point in units per second &Z_support; "
"&geography_support;"
msgstr ""
"Obtener la velocidad del punto temporal en unidades por segundo &Z_support; "
"&geography_support;"

#. Tag: varname
#: manipulating_temporal_types.xml:674
#, no-c-format
msgid "speed(tpoint): tfloats"
msgstr "speed(tpoint): tfloats"

#. Tag: programlisting
#: manipulating_temporal_types.xml:675
#, no-c-format
msgid ""
"SELECT speed(tgeompoint '{[Point(0 0)@2000-01-01, Point(1 1)@2000-01-02, Point(1 0)@2000-01-03],\n"
"[Point(1 0)@2000-01-04, Point(0 0)@2000-01-05]}') * 3600 * 24;\n"
"-- \"Interp=Stepwise;{[1.4142135623731@2000-01-01, 1@2000-01-02, 1@2000-01-03], [1@2000-01-04, 1@2000-01-05]}\"\n"
"SELECT speed(tgeompoint 'Interp=Stepwise;[Point(0 0)@2000-01-01, Point(1 1)@2000-01-02, Point(1 0)@2000-01-03]') * 3600 * 24;\n"
"-- \"Interp=Stepwise;[0@2000-01-01 00:00:00+01, 0@2000-01-03 00:00:00+01]\""
msgstr ""
"SELECT speed(tgeompoint '{[Point(0 0)@2000-01-01, Point(1 1)@2000-01-02, Point(1 0)@2000-01-03],\n"
"[Point(1 0)@2000-01-04, Point(0 0)@2000-01-05]}') * 3600 * 24;\n"
"-- \"Interp=Stepwise;{[1.4142135623731@2000-01-01, 1@2000-01-02, 1@2000-01-03], [1@2000-01-04, 1@2000-01-05]}\"\n"
"SELECT speed(tgeompoint 'Interp=Stepwise;[Point(0 0)@2000-01-01, Point(1 1)@2000-01-02, Point(1 0)@2000-01-03]') * 3600 * 24;\n"
"-- \"Interp=Stepwise;[0@2000-01-01 00:00:00+01, 0@2000-01-03 00:00:00+01]\""

#. Tag: varname
#: manipulating_temporal_types.xml:679
#, no-c-format
msgid "twCentroid"
msgstr "twCentroid"

#. Tag: para
#: manipulating_temporal_types.xml:680
#, no-c-format
msgid "Get the time-weighted centroid &Z_support;"
msgstr "Obtener el centroide ponderado en el tiempo &Z_support;"

#. Tag: varname
#: manipulating_temporal_types.xml:681
#, no-c-format
msgid "twCentroid(tgeompoint): point"
msgstr "twCentroid(tgeompoint): point"

#. Tag: programlisting
#: manipulating_temporal_types.xml:682
#, no-c-format
msgid ""
"SELECT ST_AsText(twCentroid(tgeompoint '{[Point(0 0 0)@2012-01-01,\n"
"Point(0 1 1)@2012-01-02, Point(0 1 1)@2012-01-03, Point(0 0 0)@2012-01-04)}'));\n"
"-- \"POINT Z (0 0.666666666666667 0.666666666666667)\""
msgstr ""
"SELECT ST_AsText(twCentroid(tgeompoint '{[Point(0 0 0)@2012-01-01,\n"
"Point(0 1 1)@2012-01-02, Point(0 1 1)@2012-01-03, Point(0 0 0)@2012-01-04)}'));\n"
"-- \"POINT Z (0 0.666666666666667 0.666666666666667)\""

#. Tag: varname
#: manipulating_temporal_types.xml:686
#, no-c-format
msgid "azimuth"
msgstr "azimuth"

#. Tag: para
#: manipulating_temporal_types.xml:687
#, no-c-format
msgid "Get the temporal azimuth &Z_support; &geography_support;"
msgstr "Obtener el acimut temporal &Z_support; &geography_support;"

#. Tag: varname
#: manipulating_temporal_types.xml:688
#, no-c-format
msgid "azimuth(tpoint): tfloat"
msgstr "azimuth(tpoint): tfloat"

#. Tag: programlisting
#: manipulating_temporal_types.xml:689
#, no-c-format
msgid ""
"SELECT degrees(azimuth(tgeompoint '[Point(0 0 0)@2012-01-01, Point(1 1 1)@2012-01-02,\n"
"Point(1 1 1)@2012-01-03, Point(0 0 0)@2012-01-04)'));\n"
"-- \"Interp=Stepwise;{[45@2012-01-01, 45@2012-01-02], [225@2012-01-03, 225@2012-01-04)}\""
msgstr ""
"SELECT degrees(azimuth(tgeompoint '[Point(0 0 0)@2012-01-01, Point(1 1 1)@2012-01-02,\n"
"Point(1 1 1)@2012-01-03, Point(0 0 0)@2012-01-04)'));\n"
"-- \"Interp=Stepwise;{[45@2012-01-01, 45@2012-01-02], [225@2012-01-03, 225@2012-01-04)}\""

#. Tag: varname
#: manipulating_temporal_types.xml:693
#, no-c-format
msgid "nearestApproachInstant"
msgstr "nearestApproachInstant"

#. Tag: para
#: manipulating_temporal_types.xml:694
#, no-c-format
msgid ""
"Get the instant of the first temporal point at which the two arguments are "
"at the nearest distance &Z_support; &geography_support;"
msgstr ""
"Obtener el instante del primer punto temporal en el que los dos argumentos "
"están a la distancia más cercana &Z_support; &geography_support;"

#. Tag: varname
#: manipulating_temporal_types.xml:695
#, no-c-format
msgid "nearestApproachInstant({geo, tpoint}, {geo, tpoint}): tpoint"
msgstr "nearestApproachInstant({geo, tpoint}, {geo, tpoint}): tpoint"

#. Tag: para
#: manipulating_temporal_types.xml:696
#, no-c-format
msgid ""
"The function will only return the first instant that it finds if there are "
"more than one. The resulting instant may be at an exclusive bound."
msgstr ""
"La función solo devuelve el primer instante que encuentre si hay más de uno."
" El instante resultante puede tener un límite exclusivo."

#. Tag: programlisting
#: manipulating_temporal_types.xml:697
#, no-c-format
msgid ""
"SELECT asText(NearestApproachInstant(tgeompoint '(Point(1 1)@2000-01-01,\n"
"Point(3 1)@2000-01-03]', geometry 'Linestring(1 3,2 2,3 3)'));\n"
"-- \"POINT(2 1)@2000-01-02\"\n"
"SELECT asText(NearestApproachInstant(tgeompoint 'Interp=Stepwise;(Point(1 1)@2000-01-01,\n"
"Point(3 1)@2000-01-03]', geometry 'Linestring(1 3,2 2,3 3)'));\n"
"-- \"POINT(1 1)@2000-01-01\"\n"
"SELECT asText(NearestApproachInstant(tgeompoint '(Point(1 1)@2000-01-01,\n"
"Point(2 2)@2000-01-03]', tgeompoint '(Point(1 1)@2000-01-01, Point(4 1)@2000-01-03]'));\n"
"-- \"POINT(1 1)@2000-01-01\"\n"
"SELECT asText(nearestApproachInstant(\n"
"tgeompoint '[Point(0 0 0)@2012-01-01, Point(1 1 1)@2012-01-03,\n"
"Point(0 0 0)@2012-01-05)', tgeompoint '[Point(2 0 0)@2012-01-02,\n"
"Point(1 1 1)@2012-01-04, Point(2 2 2)@2012-01-06)'));\n"
"-- \"POINT Z (0.75 0.75 0.75)@2012-01-03 12:00:00+00\""
msgstr ""
"SELECT asText(NearestApproachInstant(tgeompoint '(Point(1 1)@2000-01-01,\n"
"Point(3 1)@2000-01-03]', geometry 'Linestring(1 3,2 2,3 3)'));\n"
"-- \"POINT(2 1)@2000-01-02\"\n"
"SELECT asText(NearestApproachInstant(tgeompoint 'Interp=Stepwise;(Point(1 1)@2000-01-01,\n"
"Point(3 1)@2000-01-03]', geometry 'Linestring(1 3,2 2,3 3)'));\n"
"-- \"POINT(1 1)@2000-01-01\"\n"
"SELECT asText(NearestApproachInstant(tgeompoint '(Point(1 1)@2000-01-01,\n"
"Point(2 2)@2000-01-03]', tgeompoint '(Point(1 1)@2000-01-01, Point(4 1)@2000-01-03]'));\n"
"-- \"POINT(1 1)@2000-01-01\"\n"
"SELECT asText(nearestApproachInstant(\n"
"tgeompoint '[Point(0 0 0)@2012-01-01, Point(1 1 1)@2012-01-03,\n"
"Point(0 0 0)@2012-01-05)', tgeompoint '[Point(2 0 0)@2012-01-02,\n"
"Point(1 1 1)@2012-01-04, Point(2 2 2)@2012-01-06)'));\n"
"-- \"POINT Z (0.75 0.75 0.75)@2012-01-03 12:00:00+00\""

#. Tag: para
#: manipulating_temporal_types.xml:698
#, no-c-format
msgid ""
"Function <varname>nearestApproachInstant</varname> generalizes the PostGIS "
"function <varname>ST_ClosestPointOfApproach</varname>. First, the latter "
"function requires both arguments to be trajectories. Second, function "
"<varname>nearestApproachInstant</varname> returns both the point and the "
"timestamp of the nearest point of approach while the PostGIS function only "
"provides the timestamp as shown next."
msgstr ""
"La función <varname>nearestApproachInstant</varname> generaliza the la "
"función PostGIS <varname>ST_ClosestPointOfApproach</varname>. Primero, la "
"última función requiere que ambos argumentos sean trayectorias. Segundo, la "
"función <varname>nearestApproachInstant</varname> devuelve tanto el punto "
"como la marca de tiempo del punto de aproximación más cercano, mientras que "
"la función PostGIS solo proporciona la marca de tiempo como se muestra a "
"continuación."

#. Tag: programlisting
#: manipulating_temporal_types.xml:699
#, no-c-format
msgid ""
"SELECT to_timestamp(ST_ClosestPointOfApproach(\n"
"tgeompoint '[Point(0 0 0)@2012-01-01, Point(1 1 1)@2012-01-03,\n"
"        Point(0 0 0)@2012-01-05)'::geometry,\n"
"tgeompoint '[Point(2 0 0)@2012-01-02, Point(1 1 1)@2012-01-04,\n"
"        Point(2 2 2)@2012-01-06)'::geometry));\n"
"-- \"2012-01-03 12:00:00+00\""
msgstr ""
"SELECT to_timestamp(ST_ClosestPointOfApproach(\n"
"tgeompoint '[Point(0 0 0)@2012-01-01, Point(1 1 1)@2012-01-03,\n"
"        Point(0 0 0)@2012-01-05)'::geometry,\n"
"tgeompoint '[Point(2 0 0)@2012-01-02, Point(1 1 1)@2012-01-04,\n"
"        Point(2 2 2)@2012-01-06)'::geometry));\n"
"-- \"2012-01-03 12:00:00+00\""

#. Tag: varname
#: manipulating_temporal_types.xml:703
#, no-c-format
msgid "nearestApproachDistance"
msgstr "nearestApproachDistance"

#. Tag: para
#: manipulating_temporal_types.xml:704 manipulating_temporal_types.xml:1270
#, no-c-format
msgid "Get the smallest distance ever &Z_support; &geography_support;"
msgstr ""
"Obtener la distancia más pequeña que haya existido &Z_support; "
"&geography_support;"

#. Tag: varname
#: manipulating_temporal_types.xml:705
#, no-c-format
msgid "nearestApproachDistance({geo, tpoint}, {geo, tpoint}): float"
msgstr "nearestApproachDistance({geo, tpoint}, {geo, tpoint}): float"

#. Tag: programlisting
#: manipulating_temporal_types.xml:706
#, no-c-format
msgid ""
"SELECT NearestApproachDistance(tgeompoint '(Point(1 1)@2000-01-01,\n"
"Point(3 1)@2000-01-03]', geometry 'Linestring(1 3,2 2,3 3)');\n"
"-- 1\n"
"SELECT NearestApproachDistance(tgeompoint 'Interp=Stepwise;(Point(1 1)@2000-01-01,\n"
"Point(3 1)@2000-01-03]', geometry 'Linestring(1 3,2 2,3 3)');\n"
"-- 1.4142135623731\n"
"SELECT nearestApproachDistance(\n"
"tgeompoint '[Point(0 0 0)@2012-01-01, Point(1 1 1)@2012-01-03,\n"
"        Point(0 0 0)@2012-01-05)',\n"
"tgeompoint '[Point(2 0 0)@2012-01-02, Point(1 1 1)@2012-01-04,\n"
"        Point(2 2 2)@2012-01-06)');\n"
"-- \"0.5\""
msgstr ""
"SELECT NearestApproachDistance(tgeompoint '(Point(1 1)@2000-01-01,\n"
"Point(3 1)@2000-01-03]', geometry 'Linestring(1 3,2 2,3 3)');\n"
"-- 1\n"
"SELECT NearestApproachDistance(tgeompoint 'Interp=Stepwise;(Point(1 1)@2000-01-01,\n"
"Point(3 1)@2000-01-03]', geometry 'Linestring(1 3,2 2,3 3)');\n"
"-- 1.4142135623731\n"
"SELECT nearestApproachDistance(\n"
"tgeompoint '[Point(0 0 0)@2012-01-01, Point(1 1 1)@2012-01-03,\n"
"        Point(0 0 0)@2012-01-05)',\n"
"tgeompoint '[Point(2 0 0)@2012-01-02, Point(1 1 1)@2012-01-04,\n"
"        Point(2 2 2)@2012-01-06)');\n"
"-- \"0.5\""

#. Tag: para
#: manipulating_temporal_types.xml:707
#, no-c-format
msgid ""
"Function <varname>nearestApproachDistance</varname> has an associated "
"operator <varname>|=|</varname> that can be used for doing nearest neightbor"
" searches using a GiST index (see <xref "
"linkend=\"operators_temporal_types\"/>). This function corresponds to the "
"function <varname>ST_DistanceCPA</varname> provided by PostGIS, altough the "
"latter requires both arguments to be a trajectory."
msgstr ""
"La función <varname>nearestApproachDistance</varname> tiene un operador "
"asociado <varname>|=|</varname> que se puede utilizar para realizar una "
"búsqueda de vecino más cercano utilizando un índice GiST (see <xref "
"linkend=\"operators_temporal_types\"/>). Esta función corresponde a la "
"función <varname>ST_DistanceCPA</varname> proporcionada por PostGIS, aunque "
"este última requiere que ambos argumentos sean una trayectoria."

#. Tag: programlisting
#: manipulating_temporal_types.xml:708
#, no-c-format
msgid ""
"SELECT ST_DistanceCPA(\n"
"tgeompoint '[Point(0 0 0)@2012-01-01, Point(1 1 1)@2012-01-03,\n"
"        Point(0 0 0)@2012-01-05)'::geometry,\n"
"tgeompoint '[Point(2 0 0)@2012-01-02, Point(1 1 1)@2012-01-04,\n"
"        Point(2 2 2)@2012-01-06)'::geometry);\n"
"-- \"0.5\""
msgstr ""
"SELECT ST_DistanceCPA(\n"
"tgeompoint '[Point(0 0 0)@2012-01-01, Point(1 1 1)@2012-01-03,\n"
"        Point(0 0 0)@2012-01-05)'::geometry,\n"
"tgeompoint '[Point(2 0 0)@2012-01-02, Point(1 1 1)@2012-01-04,\n"
"        Point(2 2 2)@2012-01-06)'::geometry);\n"
"-- \"0.5\""

#. Tag: varname
#: manipulating_temporal_types.xml:712
#, no-c-format
msgid "shortestLine"
msgstr "shortestLine"

#. Tag: para
#: manipulating_temporal_types.xml:713
#, no-c-format
msgid ""
"Get the line connecting the nearest approach point &Z_support; "
"&geography_support;"
msgstr ""
"Obtener la línea que conecta el punto de aproximación más cercano "
"&Z_support; &geography_support;"

#. Tag: varname
#: manipulating_temporal_types.xml:714
#, no-c-format
msgid "shortestLine({geo, tpoint}, {geo, tpoint}): geo"
msgstr "shortestLine({geo, tpoint}, {geo, tpoint}): geo"

#. Tag: para
#: manipulating_temporal_types.xml:715
#, no-c-format
msgid ""
"The function will only return the first line that it finds if there are more"
" than one."
msgstr ""
"La función solo devolverá la primera línea que encuentre si hay más de una."

#. Tag: programlisting
#: manipulating_temporal_types.xml:716
#, no-c-format
msgid ""
"SELECT ST_AsText(shortestLine(tgeompoint '(Point(1 1)@2000-01-01,\n"
"Point(3 1)@2000-01-03]', geometry 'Linestring(1 3,2 2,3 3)'));\n"
"-- \"LINESTRING(2 1,2 2)\"\n"
"SELECT ST_AsText(shortestLine(tgeompoint 'Interp=Stepwise;(Point(1 1)@2000-01-01,\n"
"Point(3 1)@2000-01-03]', geometry 'Linestring(1 3,2 2,3 3)'));\n"
"-- \"LINESTRING(1 1,2 2)\"\n"
"SELECT ST_AsText(shortestLine(\n"
"tgeompoint '[Point(0 0 0)@2012-01-01, Point(1 1 1)@2012-01-03,\n"
"        Point(0 0 0)@2012-01-05)',\n"
"tgeompoint '[Point(2 0 0)@2012-01-02, Point(1 1 1)@2012-01-04,\n"
"        Point(2 2 2)@2012-01-06)'));\n"
"-- \"LINESTRING Z (0.75 0.75 0.75,1.25 0.75 0.75)\""
msgstr ""
"SELECT ST_AsText(shortestLine(tgeompoint '(Point(1 1)@2000-01-01,\n"
"Point(3 1)@2000-01-03]', geometry 'Linestring(1 3,2 2,3 3)'));\n"
"-- \"LINESTRING(2 1,2 2)\"\n"
"SELECT ST_AsText(shortestLine(tgeompoint 'Interp=Stepwise;(Point(1 1)@2000-01-01,\n"
"Point(3 1)@2000-01-03]', geometry 'Linestring(1 3,2 2,3 3)'));\n"
"-- \"LINESTRING(1 1,2 2)\"\n"
"SELECT ST_AsText(shortestLine(\n"
"tgeompoint '[Point(0 0 0)@2012-01-01, Point(1 1 1)@2012-01-03,\n"
"        Point(0 0 0)@2012-01-05)',\n"
"tgeompoint '[Point(2 0 0)@2012-01-02, Point(1 1 1)@2012-01-04,\n"
"        Point(2 2 2)@2012-01-06)'));\n"
"-- \"LINESTRING Z (0.75 0.75 0.75,1.25 0.75 0.75)\""

#. Tag: para
#: manipulating_temporal_types.xml:717
#, no-c-format
msgid ""
"Function <varname>shortestLine</varname> can be used to obtain the result "
"provided by the PostGIS function <varname>ST_CPAWithin</varname> when both "
"arguments are trajectories as shown next."
msgstr ""
"La función <varname>shortestLine</varname> se puede utilizar para obtener el"
" resultado proporcionado por la función PostGIS "
"<varname>ST_CPAWithin</varname> cuando ambos argumentos son trayectorias "
"como se muestra a continuación."

#. Tag: programlisting
#: manipulating_temporal_types.xml:718
#, no-c-format
msgid ""
"SELECT ST_Length(shortestLine(\n"
"tgeompoint '[Point(0 0 0)@2012-01-01, Point(1 1 1)@2012-01-03,\n"
"        Point(0 0 0)@2012-01-05)',\n"
"tgeompoint '[Point(2 0 0)@2012-01-02, Point(1 1 1)@2012-01-04,\n"
"        Point(2 2 2)@2012-01-06)')) &lt;= 0.5;\n"
"-- true\n"
"SELECT ST_CPAWithin(\n"
"tgeompoint '[Point(0 0 0)@2012-01-01, Point(1 1 1)@2012-01-03,\n"
"        Point(0 0 0)@2012-01-05)'::geometry,\n"
"tgeompoint '[Point(2 0 0)@2012-01-02, Point(1 1 1)@2012-01-04,\n"
"        Point(2 2 2)@2012-01-06)'::geometry, 0.5);\n"
"-- true"
msgstr ""
"SELECT ST_Length(shortestLine(\n"
"tgeompoint '[Point(0 0 0)@2012-01-01, Point(1 1 1)@2012-01-03,\n"
"        Point(0 0 0)@2012-01-05)',\n"
"tgeompoint '[Point(2 0 0)@2012-01-02, Point(1 1 1)@2012-01-04,\n"
"        Point(2 2 2)@2012-01-06)')) &lt;= 0.5;\n"
"-- true\n"
"SELECT ST_CPAWithin(\n"
"tgeompoint '[Point(0 0 0)@2012-01-01, Point(1 1 1)@2012-01-03,\n"
"        Point(0 0 0)@2012-01-05)'::geometry,\n"
"tgeompoint '[Point(2 0 0)@2012-01-02, Point(1 1 1)@2012-01-04,\n"
"        Point(2 2 2)@2012-01-06)'::geometry, 0.5);\n"
"-- true"

#. Tag: varname
#: manipulating_temporal_types.xml:722
#, no-c-format
msgid "simplify"
msgstr "simplify"

#. Tag: para
#: manipulating_temporal_types.xml:723
#, no-c-format
msgid ""
"Simplify a temporal point using a generalization of the Douglas-Peucker "
"algorithm &Z_support;"
msgstr ""
"Simplificar un punto temporal usando una generalización del algoritmo de "
"Douglas-Peucker &Z_support;"

#. Tag: varname
#: manipulating_temporal_types.xml:724
#, no-c-format
msgid "simplify(tpoint, float): tpoint"
msgstr "simplify(tpoint, float): tpoint"

#. Tag: varname
#: manipulating_temporal_types.xml:725
#, no-c-format
msgid "simplify(tpoint, float, float): tpoint"
msgstr "simplify(tpoint, float, float): tpoint"

#. Tag: para
#: manipulating_temporal_types.xml:726
#, no-c-format
msgid ""
"The first version remove points that are less than the distance passed as "
"second argument, which is specified in the units of the coordinate system. "
"The second version remove points that are less than the distance passed as "
"second argument provided that the speed difference between the point and the"
" corresponding point in the simplified version is less than the speed passed"
" as third argument, which is specified in units per second. Notice that "
"simplification applies only to temporal sequences or sequence sets with "
"linear interpolation. In all other cases, a copy of the given temporal point"
" is returned."
msgstr ""
"La primera versión elimina los puntos cuya distancia es menor que la "
"distancia pasada como segundo argumento, que se especifica en las unidades "
"del sistema de coordenadas. La segunda versión elimina los puntos cuya "
"distancia es menor que la distancia pasada como segundo argumento siempre "
"que la diferencia de velocidad entre el punto y el punto correspondiente en "
"la versión simplificada sea menor que la velocidad pasada como tercer "
"argumento, que se especifica en unidades por segundo. Observe que la "
"simplificación se aplica solo a secuencias temporales o conjuntos de "
"secuencias con interpolación lineal. En todos los demás casos, se devuelve "
"una copia del punto temporal dado."

#. Tag: programlisting
#: manipulating_temporal_types.xml:728
#, no-c-format
msgid ""
"-- Only distance specified\n"
"SELECT ST_AsText(trajectory(simplify(tgeompoint '[Point(0 4)@2000-01-01,\n"
"Point(1 1)@2000-01-02, Point(2 3)@2000-01-03, Point(3 1)@2000-01-04,\n"
"Point(4 3)@2000-01-05, Point(5 0)@2000-01-06, Point(6 4)@2000-01-07]', 1.5)));\n"
"-- \"LINESTRING(0 4,1 1,4 3,5 0,6 4)\"\n"
"SELECT ST_AsText(trajectory(simplify(tgeompoint '[Point(0 4)@2000-01-01,\n"
"Point(1 1)@2000-01-02, Point(2 3)@2000-01-03, Point(3 1)@2000-01-04,\n"
"Point(4 3)@2000-01-05, Point(5 0)@2000-01-06, Point(6 4)@2000-01-07]', 2)));\n"
"-- \"LINESTRING(0 4,5 0,6 4)\"\n"
"SELECT ST_AsText(trajectory(simplify(tgeompoint '[Point(0 4)@2000-01-01,\n"
"Point(1 1)@2000-01-02, Point(2 3)@2000-01-03, Point(3 1)@2000-01-04,\n"
"Point(4 3)@2000-01-05, Point(5 0)@2000-01-06, Point(6 4)@2000-01-07]', 4)));\n"
"-- \"LINESTRING(0 4,6 4)\"\n"
"\n"
"-- Speed of the temporal point\n"
"SELECT round(speed(tgeompoint '[Point(0 4)@2000-01-01, Point(1 1)@2000-01-02,\n"
"Point(2 3)@2000-01-03, Point(3 1)@2000-01-04, Point(4 3)@2000-01-05,\n"
"Point(5 0)@2000-01-06, Point(6 4)@2000-01-07]') * 1e5, 2);\n"
"-- \"Interp=Stepwise;[3.66@2000-01-01, 2.59@2000-01-02, 3.66@2000-01-05,\n"
"4.77@2000-01-06, 4.77@2000-01-07]\"\n"
"\n"
"-- Both distance and delta speed specified\n"
"SELECT ST_AsText(trajectory(simplify(tgeompoint '[Point(0 4)@2000-01-01,\n"
"Point(1 1)@2000-01-02, Point(2 3)@2000-01-03, Point(3 1)@2000-01-04,\n"
"Point(4 3)@2000-01-05, Point(5 0)@2000-01-06, Point(6 4)@2000-01-07]', 4, 1 / 1e5)));\n"
"-- \"LINESTRING(0 4,1 1,2 3,3 1,4 3,5 0,6 4)\"\n"
"SELECT ST_AsText(trajectory(simplify(tgeompoint '[Point(0 4)@2000-01-01,\n"
"Point(1 1)@2000-01-02, Point(2 3)@2000-01-03, Point(3 1)@2000-01-04,\n"
"Point(4 3)@2000-01-05, Point(5 0)@2000-01-06, Point(6 4)@2000-01-07]', 4, 2 / 1e5)));\n"
"-- \"LINESTRING(0 4,1 1,5 0,6 4)\"\n"
"SELECT ST_AsText(trajectory(simplify(tgeompoint '[Point(0 4)@2000-01-01,\n"
"Point(1 1)@2000-01-02, Point(2 3)@2000-01-03, Point(3 1)@2000-01-04,\n"
"Point(4 3)@2000-01-05, Point(5 0)@2000-01-06, Point(6 4)@2000-01-07]', 4, 3 / 1e5)));\n"
"-- \"LINESTRING(0 4,6 4)\""
msgstr ""
"-- Solo distancia especificada\n"
"SELECT ST_AsText(trajectory(simplify(tgeompoint '[Point(0 4)@2000-01-01,\n"
"Point(1 1)@2000-01-02, Point(2 3)@2000-01-03, Point(3 1)@2000-01-04,\n"
"Point(4 3)@2000-01-05, Point(5 0)@2000-01-06, Point(6 4)@2000-01-07]', 1.5)));\n"
"-- \"LINESTRING(0 4,1 1,4 3,5 0,6 4)\"\n"
"SELECT ST_AsText(trajectory(simplify(tgeompoint '[Point(0 4)@2000-01-01,\n"
"Point(1 1)@2000-01-02, Point(2 3)@2000-01-03, Point(3 1)@2000-01-04,\n"
"Point(4 3)@2000-01-05, Point(5 0)@2000-01-06, Point(6 4)@2000-01-07]', 2)));\n"
"-- \"LINESTRING(0 4,5 0,6 4)\"\n"
"SELECT ST_AsText(trajectory(simplify(tgeompoint '[Point(0 4)@2000-01-01,\n"
"Point(1 1)@2000-01-02, Point(2 3)@2000-01-03, Point(3 1)@2000-01-04,\n"
"Point(4 3)@2000-01-05, Point(5 0)@2000-01-06, Point(6 4)@2000-01-07]', 4)));\n"
"-- \"LINESTRING(0 4,6 4)\"\n"
"\n"
"-- Solo diferencia de velocidad especificada\n"
"SELECT round(speed(tgeompoint '[Point(0 4)@2000-01-01, Point(1 1)@2000-01-02,\n"
"Point(2 3)@2000-01-03, Point(3 1)@2000-01-04, Point(4 3)@2000-01-05,\n"
"Point(5 0)@2000-01-06, Point(6 4)@2000-01-07]') * 1e5, 2);\n"
"-- \"Interp=Stepwise;[3.66@2000-01-01, 2.59@2000-01-02, 3.66@2000-01-05,\n"
"4.77@2000-01-06, 4.77@2000-01-07]\"\n"
"\n"
"-- Se especifican tanto la distancia como la diferencia de velocidad\n"
"SELECT ST_AsText(trajectory(simplify(tgeompoint '[Point(0 4)@2000-01-01,\n"
"Point(1 1)@2000-01-02, Point(2 3)@2000-01-03, Point(3 1)@2000-01-04,\n"
"Point(4 3)@2000-01-05, Point(5 0)@2000-01-06, Point(6 4)@2000-01-07]', 4, 1 / 1e5)));\n"
"-- \"LINESTRING(0 4,1 1,2 3,3 1,4 3,5 0,6 4)\"\n"
"SELECT ST_AsText(trajectory(simplify(tgeompoint '[Point(0 4)@2000-01-01,\n"
"Point(1 1)@2000-01-02, Point(2 3)@2000-01-03, Point(3 1)@2000-01-04,\n"
"Point(4 3)@2000-01-05, Point(5 0)@2000-01-06, Point(6 4)@2000-01-07]', 4, 2 / 1e5)));\n"
"-- \"LINESTRING(0 4,1 1,5 0,6 4)\"\n"
"SELECT ST_AsText(trajectory(simplify(tgeompoint '[Point(0 4)@2000-01-01,\n"
"Point(1 1)@2000-01-02, Point(2 3)@2000-01-03, Point(3 1)@2000-01-04,\n"
"Point(4 3)@2000-01-05, Point(5 0)@2000-01-06, Point(6 4)@2000-01-07]', 4, 3 / 1e5)));\n"
"-- \"LINESTRING(0 4,6 4)\""

#. Tag: para
#: manipulating_temporal_types.xml:729
#, no-c-format
msgid ""
"A typical use for the <varname>simplify</varname> function is to reduce the "
"size of a dataset, in particular for visualization purposes."
msgstr ""
"Un uso típico de la función <varname>simplify</varname> es reducir el tamaño"
" de un conjunto de datos, en particular con fines de visualización."

#. Tag: varname
#: manipulating_temporal_types.xml:733
#, no-c-format
msgid "geoMeasure"
msgstr "geoMeasure"

#. Tag: para
#: manipulating_temporal_types.xml:734
#, no-c-format
msgid ""
"Construct a geometry/geography with M measure from a temporal point and a "
"temporal float &Z_support; &geography_support;"
msgstr ""
"Construir una geometría/geografía con medida M a partir de un punto temporal"
" y un número flotante temporal &Z_support; &geography_support;"

#. Tag: varname
#: manipulating_temporal_types.xml:735
#, no-c-format
msgid "geoMeasure(tpoint, tfloat, segmentize = false): geo"
msgstr "geoMeasure(tpoint, tfloat, segmentize = false): geo"

#. Tag: para
#: manipulating_temporal_types.xml:736
#, no-c-format
msgid ""
"The last <varname>segmentize</varname> argument states whether a resulting "
"Linestring M value is transformed into a MultiLinestring M, where each "
"component is a segment of two points."
msgstr ""
"El último argumento <varname>segmentize</varname> establece si el valor "
"resultado Linestring M se transforma en un MultiLinestringM, donde cada "
"componente es un segmento de dos puntos."

#. Tag: programlisting
#: manipulating_temporal_types.xml:738
#, no-c-format
msgid ""
"SELECT st_astext(geoMeasure(tgeompoint '{Point(1 1 1)@2000-01-01,\n"
"Point(2 2 2)@2000-01-02}', '{5@2000-01-01, 5@2000-01-02}'));\n"
"-- \"MULTIPOINT ZM (1 1 1 5,2 2 2 5)\"\n"
"SELECT st_astext(geoMeasure(tgeogpoint '{[Point(1 1)@2000-01-01, Point(2 2)@2000-01-02],\n"
"[Point(1 1)@2000-01-03, Point(1 1)@2000-01-04]}',\n"
"'{[5@2000-01-01, 5@2000-01-02],[7@2000-01-03, 7@2000-01-04]}'));\n"
"-- \"GEOMETRYCOLLECTION M (LINESTRING M (1 1 5,2 2 5),POINT M (1 1 7))\"\n"
"SELECT st_astext(geoMeasure(tgeompoint '[Point(1 1)@2000-01-01,\n"
"Point(2 2)@2000-01-02, Point(1 1)@2000-01-03]', '[5@2000-01-01, 7@2000-01-02, 5@2000-01-03]', true));\n"
"-- \"MULTILINESTRING M ((1 1 5,2 2 5),(2 2 7,1 1 7))\""
msgstr ""
"SELECT st_astext(geoMeasure(tgeompoint '{Point(1 1 1)@2000-01-01,\n"
"Point(2 2 2)@2000-01-02}', '{5@2000-01-01, 5@2000-01-02}'));\n"
"-- \"MULTIPOINT ZM (1 1 1 5,2 2 2 5)\"\n"
"SELECT st_astext(geoMeasure(tgeogpoint '{[Point(1 1)@2000-01-01, Point(2 2)@2000-01-02],\n"
"[Point(1 1)@2000-01-03, Point(1 1)@2000-01-04]}',\n"
"'{[5@2000-01-01, 5@2000-01-02],[7@2000-01-03, 7@2000-01-04]}'));\n"
"-- \"GEOMETRYCOLLECTION M (LINESTRING M (1 1 5,2 2 5),POINT M (1 1 7))\"\n"
"SELECT st_astext(geoMeasure(tgeompoint '[Point(1 1)@2000-01-01,\n"
"Point(2 2)@2000-01-02, Point(1 1)@2000-01-03]', '[5@2000-01-01, 7@2000-01-02, 5@2000-01-03]', true));\n"
"-- \"MULTILINESTRING M ((1 1 5,2 2 5),(2 2 7,1 1 7))\""

#. Tag: para
#: manipulating_temporal_types.xml:739
#, no-c-format
msgid ""
"A typical visualization for mobility data is to show on a map the trajectory"
" of the moving object using different colors according to the speed. <xref "
"linkend=\"figspeed\"/> shows the result of the query below using a color "
"ramp in QGIS."
msgstr ""
"Una visualización típica de los datos de movilidad es mostrar en un mapa la "
"trayectoria del objeto en movimiento utilizando diferentes colores según la "
"velocidad. <xref linkend=\"figspeed\"/> muestra el resultado de la consulta "
"a continuación usando una rampa de color en QGIS."

#. Tag: programlisting
#: manipulating_temporal_types.xml:740
#, no-c-format
msgid ""
"WITH Temp(t) AS (\n"
"SELECT tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-05,\n"
"                Point(2 0)@2012-01-08, Point(3 1)@2012-01-10, Point(4 0)@2012-01-11]'\n"
")\n"
"SELECT ST_AsText(geoMeasure(t,  round(speed(t) * 3600 * 24, 2), true))\n"
"FROM Temp;\n"
"-- \"MULTILINESTRING M ((0 0 0.35,1 1 0.35),(1 1 0.47,2 0 0.47),(2 0 0.71,3 1 0.71),\n"
"(3 1 1.41,4 0 1.41))\""
msgstr ""
"WITH Temp(t) AS (\n"
"SELECT tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-05,\n"
"                Point(2 0)@2012-01-08, Point(3 1)@2012-01-10, Point(4 0)@2012-01-11]'\n"
")\n"
"SELECT ST_AsText(geoMeasure(t,  round(speed(t) * 3600 * 24, 2), true))\n"
"FROM Temp;\n"
"-- \"MULTILINESTRING M ((0 0 0.35,1 1 0.35),(1 1 0.47,2 0 0.47),(2 0 0.71,3 1 0.71),\n"
"(3 1 1.41,4 0 1.41))\""

#. Tag: para
#: manipulating_temporal_types.xml:741
#, no-c-format
msgid ""
"The following expression is used in QGIS to achieve this. The "
"<varname>scale_linear</varname> function transforms the M value of each "
"composing segment to the range [0, 1]. This value is then passed to the "
"<varname>ramp_color</varname> function."
msgstr ""
"La siguiente expresión se usa en QGIS para lograr esto. La función "
"<varname>scale_linear</varname> transforma el valor M de cada segmento "
"componente al rango [0, 1]. Este valor luego se pasa a la función "
"<varname>ramp_color</varname>."

#. Tag: programlisting
#: manipulating_temporal_types.xml:742
#, no-c-format
msgid ""
"ramp_color(\n"
"'RdYlBu',\n"
"scale_linear(\n"
"        m(start_point(geometry_n($geometry,@geometry_part_num))),\n"
"        0, 2, 0, 1\n"
")\n"
")"
msgstr ""
"ramp_color(\n"
"'RdYlBu',\n"
"scale_linear(\n"
"        m(start_point(geometry_n($geometry,@geometry_part_num))),\n"
"        0, 2, 0, 1\n"
")\n"
")"

#. Tag: title
#: manipulating_temporal_types.xml:743
#, no-c-format
msgid "Visualizing the speed of a moving object using a color ramp in QGIS."
msgstr ""
"Visualización de la velocidad de un objeto en movimiento usando una rampa de"
" color en QGIS."

#. Tag: title
#: manipulating_temporal_types.xml:754
#, no-c-format
msgid "Restriction Functions"
msgstr "Funciones de restricción"

#. Tag: para
#: manipulating_temporal_types.xml:755
#, no-c-format
msgid ""
"These functions restrict the temporal value with respect to a value extent "
"or a time extent."
msgstr ""
"Estas funciones restringen el valor temporal con respecto a una extensión de"
" valores o una extensión de tiempo."

#. Tag: varname
#: manipulating_temporal_types.xml:759
#, no-c-format
msgid "atValue"
msgstr "atValue"

#. Tag: para
#: manipulating_temporal_types.xml:760
#, no-c-format
msgid "Restrict to a value"
msgstr ""
"Restringir a un valor\n"
"\n"
" "

#. Tag: varname
#: manipulating_temporal_types.xml:761
#, no-c-format
msgid "atValue(ttype, base): ttype"
msgstr "atValue(ttype, base): ttype"

#. Tag: programlisting
#: manipulating_temporal_types.xml:762
#, no-c-format
msgid ""
"SELECT atValue(tint '[1@2012-01-01, 1@2012-01-15)', 1);\n"
"-- \"[1@2012-01-01, 1@2012-01-15)\"\n"
"SELECT asText(atValue(tgeompoint '[Point(0 0 0)@2012-01-01, Point(2 2 2)@2012-01-03)',\n"
"'Point(1 1 1)'));\n"
"-- \"{[POINT Z (1 1 1)@2012-01-02]}\""
msgstr ""
"SELECT atValue(tint '[1@2012-01-01, 1@2012-01-15)', 1);\n"
"-- \"[1@2012-01-01, 1@2012-01-15)\"\n"
"SELECT asText(atValue(tgeompoint '[Point(0 0 0)@2012-01-01, Point(2 2 2)@2012-01-03)',\n"
"'Point(1 1 1)'));\n"
"-- \"{[POINT Z (1 1 1)@2012-01-02]}\""

#. Tag: varname
#: manipulating_temporal_types.xml:766
#, no-c-format
msgid "atValues"
msgstr "atValues"

#. Tag: para
#: manipulating_temporal_types.xml:767
#, no-c-format
msgid "Restrict to an array of values"
msgstr "Restringir a una matriz de valores"

#. Tag: varname
#: manipulating_temporal_types.xml:768
#, no-c-format
msgid "atValues(ttype, base[]): ttype"
msgstr "atValues(ttype, base[]): ttype"

#. Tag: programlisting
#: manipulating_temporal_types.xml:769
#, no-c-format
msgid ""
"SELECT atValues(tfloat '[1@2012-01-01, 4@2012-01-4)', ARRAY[1, 3, 5]);\n"
"-- \"{[1@2012-01-01], [3@2012-01-03]}\"\n"
"SELECT asText(atValues(tgeompoint '[Point(0 0)@2012-01-01, Point(2 2)@2012-01-03)',\n"
"ARRAY[geometry 'Point(0 0)', 'Point(1 1)']));\n"
"-- \"{[POINT(0 0)@2012-01-01 00:00:00+00], [POINT(1 1)@2012-01-02 00:00:00+00]}\""
msgstr ""
"SELECT atValues(tfloat '[1@2012-01-01, 4@2012-01-4)', ARRAY[1, 3, 5]);\n"
"-- \"{[1@2012-01-01], [3@2012-01-03]}\"\n"
"SELECT asText(atValues(tgeompoint '[Point(0 0)@2012-01-01, Point(2 2)@2012-01-03)',\n"
"ARRAY[geometry 'Point(0 0)', 'Point(1 1)']));\n"
"-- \"{[POINT(0 0)@2012-01-01 00:00:00+00], [POINT(1 1)@2012-01-02 00:00:00+00]}\""

#. Tag: varname
#: manipulating_temporal_types.xml:773
#, no-c-format
msgid "atRange"
msgstr "atRange"

#. Tag: para
#: manipulating_temporal_types.xml:774
#, no-c-format
msgid "Restrict to a range"
msgstr "Restringir a un rango de valores"

#. Tag: varname
#: manipulating_temporal_types.xml:775
#, no-c-format
msgid "atRange(tnumber, numrange): ttype"
msgstr "atRange(tnumber, numrange): ttype"

#. Tag: programlisting
#: manipulating_temporal_types.xml:776
#, no-c-format
msgid ""
"SELECT atRange(tfloat '[1@2012-01-01, 4@2012-01-4)', floatrange '[1,3]');\n"
"-- \"[1@2012-01-01, 3@2012-01-03]\""
msgstr ""
"SELECT atRange(tfloat '[1@2012-01-01, 4@2012-01-4)', floatrange '[1,3]');\n"
"-- \"[1@2012-01-01, 3@2012-01-03]\""

#. Tag: varname
#: manipulating_temporal_types.xml:780
#, no-c-format
msgid "atRanges"
msgstr "atRanges"

#. Tag: para
#: manipulating_temporal_types.xml:781
#, no-c-format
msgid "Restrict to an array of ranges"
msgstr "Restringir a una matriz de rangos de valores"

#. Tag: varname
#: manipulating_temporal_types.xml:782
#, no-c-format
msgid "atRanges(tnumber, numrange[]): ttype"
msgstr "atRanges(tnumber, numrange[]): ttype"

#. Tag: programlisting
#: manipulating_temporal_types.xml:783
#, no-c-format
msgid ""
"SELECT atRanges(tfloat '[1@2012-01-01, 5@2012-01-05)',\n"
"ARRAY[floatrange '[1,2]', '[3,4]']);\n"
"-- \"{[1@2012-01-01, 2@2012-01-02],[3@2012-01-03, 4@2012-01-04]}\""
msgstr ""
"SELECT atRanges(tfloat '[1@2012-01-01, 5@2012-01-05)',\n"
"ARRAY[floatrange '[1,2]', '[3,4]']);\n"
"-- \"{[1@2012-01-01, 2@2012-01-02],[3@2012-01-03, 4@2012-01-04]}\""

#. Tag: varname
#: manipulating_temporal_types.xml:787
#, no-c-format
msgid "atMin"
msgstr "atMin"

#. Tag: para
#: manipulating_temporal_types.xml:788
#, no-c-format
msgid "Restrict to the minimum value"
msgstr "Restringir al valor mínimo"

#. Tag: varname
#: manipulating_temporal_types.xml:789
#, no-c-format
msgid "atMin(torder): torder"
msgstr "atMin(torder): torder"

#. Tag: para
#: manipulating_temporal_types.xml:790
#, no-c-format
msgid ""
"The function returns null if the minimum value only happens at exclusive "
"bounds."
msgstr ""
"La función devuelve nulo si el valor mínimo solo ocurre en límites "
"exclusivos."

#. Tag: programlisting
#: manipulating_temporal_types.xml:791
#, no-c-format
msgid ""
"SELECT atMin(tint '{1@2012-01-01, 2@2012-01-03, 1@2012-01-05}');\n"
"-- \"{1@2012-01-01, 1@2012-01-05}\"\n"
"SELECT atMin(tint '(1@2012-01-01, 3@2012-01-03]');\n"
"-- \"{(1@2012-01-01, 1@2012-01-03)}\"\n"
"SELECT atMin(tfloat '(1@2012-01-01, 3@2012-01-03]');\n"
"-- NULL\n"
"SELECT atMin(ttext '{(AA@2012-01-01, AA@2012-01-03), (BB@2012-01-03, AA@2012-01-05]}');\n"
"-- \"{(AA@2012-01-01, AA@2012-01-03), [AA@2012-01-05]}\""
msgstr ""
"SELECT atMin(tint '{1@2012-01-01, 2@2012-01-03, 1@2012-01-05}');\n"
"-- \"{1@2012-01-01, 1@2012-01-05}\"\n"
"SELECT atMin(tint '(1@2012-01-01, 3@2012-01-03]');\n"
"-- \"{(1@2012-01-01, 1@2012-01-03)}\"\n"
"SELECT atMin(tfloat '(1@2012-01-01, 3@2012-01-03]');\n"
"-- NULL\n"
"SELECT atMin(ttext '{(AA@2012-01-01, AA@2012-01-03), (BB@2012-01-03, AA@2012-01-05]}');\n"
"-- \"{(AA@2012-01-01, AA@2012-01-03), [AA@2012-01-05]}\""

#. Tag: varname
#: manipulating_temporal_types.xml:795
#, no-c-format
msgid "atMax"
msgstr "atMax"

#. Tag: para
#: manipulating_temporal_types.xml:796
#, no-c-format
msgid "Restrict to the maximum value"
msgstr "Restringir al valor máximo"

#. Tag: varname
#: manipulating_temporal_types.xml:797
#, no-c-format
msgid "atMax(torder): torder"
msgstr "atMax(torder): torder"

#. Tag: para
#: manipulating_temporal_types.xml:798
#, no-c-format
msgid ""
"The function returns null if the maximum value only happens at exclusive "
"bounds."
msgstr ""
"La función devuelve nulo si el valor máximo solo ocurre en límites "
"exclusivos."

#. Tag: programlisting
#: manipulating_temporal_types.xml:799
#, no-c-format
msgid ""
"SELECT atMax(tint '{1@2012-01-01, 2@2012-01-03, 3@2012-01-05}');\n"
"-- \"{3@2012-01-05}\"\n"
"SELECT atMax(tfloat '(1@2012-01-01, 3@2012-01-03)');\n"
"-- NULL\n"
"SELECT atMax(tfloat '{(2@2012-01-01, 1@2012-01-03), [2@2012-01-03, 2@2012-01-05)}');\n"
"-- \"{[2@2012-01-03, 2@2012-01-05]}\"\n"
"SELECT atMax(ttext '{(AA@2012-01-01, AA@2012-01-03), (BB@2012-01-03, AA@2012-01-05]}');\n"
"-- \"{(\"BB\"@2012-01-03, \"BB\"@2012-01-05)}\""
msgstr ""
"SELECT atMax(tint '{1@2012-01-01, 2@2012-01-03, 3@2012-01-05}');\n"
"-- \"{3@2012-01-05}\"\n"
"SELECT atMax(tfloat '(1@2012-01-01, 3@2012-01-03)');\n"
"-- NULL\n"
"SELECT atMax(tfloat '{(2@2012-01-01, 1@2012-01-03), [2@2012-01-03, 2@2012-01-05)}');\n"
"-- \"{[2@2012-01-03, 2@2012-01-05]}\"\n"
"SELECT atMax(ttext '{(AA@2012-01-01, AA@2012-01-03), (BB@2012-01-03, AA@2012-01-05]}');\n"
"-- \"{(\"BB\"@2012-01-03, \"BB\"@2012-01-05)}\""

#. Tag: varname
#: manipulating_temporal_types.xml:803
#, no-c-format
msgid "atGeometry"
msgstr "atGeometry"

#. Tag: para
#: manipulating_temporal_types.xml:804
#, no-c-format
msgid "Restrict to a geometry"
msgstr "Restringir a una geometría"

#. Tag: varname
#: manipulating_temporal_types.xml:805
#, no-c-format
msgid "atGeometry(tgeompoint, geometry): tgeompoint"
msgstr "atGeometry(tgeompoint, geometry): tgeompoint"

#. Tag: programlisting
#: manipulating_temporal_types.xml:806
#, no-c-format
msgid ""
"SELECT asText(atGeometry(tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-04)',\n"
"geometry 'Polygon((1 1,1 2,2 2,2 1,1 1))'));\n"
"-- \"{\"[POINT(1 1)@2012-01-02, POINT(2 2)@2012-01-03]\"}\""
msgstr ""
"SELECT asText(atGeometry(tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-04)',\n"
"geometry 'Polygon((1 1,1 2,2 2,2 1,1 1))'));\n"
"-- \"{\"[POINT(1 1)@2012-01-02, POINT(2 2)@2012-01-03]\"}\""

#. Tag: varname
#: manipulating_temporal_types.xml:810
#, no-c-format
msgid "atTimestamp"
msgstr "atTimestamp"

#. Tag: para
#: manipulating_temporal_types.xml:811
#, no-c-format
msgid "Restrict to a timestamp"
msgstr "Restringir a una marca de tiempo"

#. Tag: varname
#: manipulating_temporal_types.xml:812
#, no-c-format
msgid "atTimestamp(ttype, timestamptz): ttypeinst"
msgstr "atTimestamp(ttype, timestamptz): ttypeinst"

#. Tag: programlisting
#: manipulating_temporal_types.xml:813
#, no-c-format
msgid ""
"SELECT atTimestamp(tfloat '[1@2012-01-01, 5@2012-01-05)', '2012-01-02');\n"
"-- \"2@2012-01-02\""
msgstr ""
"SELECT atTimestamp(tfloat '[1@2012-01-01, 5@2012-01-05)', '2012-01-02');\n"
"-- \"2@2012-01-02\""

#. Tag: varname
#: manipulating_temporal_types.xml:817
#, no-c-format
msgid "atTimestampSet"
msgstr "atTimestampSet"

#. Tag: para
#: manipulating_temporal_types.xml:818
#, no-c-format
msgid "Restrict to a timestamp set"
msgstr "Restringir a un conjunto de marcas de tiempo"

#. Tag: varname
#: manipulating_temporal_types.xml:819
#, no-c-format
msgid "atTimestampSet(ttype, timestampset): {ttypeinst, ttypei}"
msgstr "atTimestampSet(ttype, timestampset): {ttypeinst, ttypei}"

#. Tag: programlisting
#: manipulating_temporal_types.xml:820
#, no-c-format
msgid ""
"SELECT atTimestampSet(tint '[1@2012-01-01, 1@2012-01-15)',\n"
"timestampset '{2012-01-01, 2012-01-03}');\n"
"-- \"{1@2012-01-01, 1@2012-01-03}\""
msgstr ""
"SELECT atTimestampSet(tint '[1@2012-01-01, 1@2012-01-15)',\n"
"timestampset '{2012-01-01, 2012-01-03}');\n"
"-- \"{1@2012-01-01, 1@2012-01-03}\""

#. Tag: varname
#: manipulating_temporal_types.xml:824
#, no-c-format
msgid "atPeriod"
msgstr "atPeriod"

#. Tag: para
#: manipulating_temporal_types.xml:825
#, no-c-format
msgid "Restrict to a period"
msgstr "Restringir a un período"

#. Tag: varname
#: manipulating_temporal_types.xml:826
#, no-c-format
msgid "atPeriod(ttype, period): ttype"
msgstr "atPeriod(ttype, period): ttype"

#. Tag: programlisting
#: manipulating_temporal_types.xml:827
#, no-c-format
msgid ""
"SELECT atPeriod(tfloat '{[1@2012-01-01, 3@2012-01-03), [3@2012-01-04, 1@2012-01-06)}',\n"
"'[2012-01-02,2012-01-05)');\n"
"-- \"{[2@2012-01-02, 3@2012-01-03), [3@2012-01-04, 2@2012-01-05)}\""
msgstr ""
"SELECT atPeriod(tfloat '{[1@2012-01-01, 3@2012-01-03), [3@2012-01-04, 1@2012-01-06)}',\n"
"'[2012-01-02,2012-01-05)');\n"
"-- \"{[2@2012-01-02, 3@2012-01-03), [3@2012-01-04, 2@2012-01-05)}\""

#. Tag: varname
#: manipulating_temporal_types.xml:831
#, no-c-format
msgid "atPeriodSet"
msgstr "atPeriodSet"

#. Tag: para
#: manipulating_temporal_types.xml:832
#, no-c-format
msgid "Restrict to a period set"
msgstr "Restringir a un conjunto de períodos"

#. Tag: varname
#: manipulating_temporal_types.xml:833
#, no-c-format
msgid "atPeriodSet(ttype, periodset): ttype"
msgstr "atPeriodSet(ttype, periodset): ttype"

#. Tag: programlisting
#: manipulating_temporal_types.xml:834
#, no-c-format
msgid ""
"SELECT atPeriodSet(tint '[1@2012-01-01, 1@2012-01-15)',\n"
"periodset '{[2012-01-01, 2012-01-03), [2012-01-04, 2012-01-05)}');\n"
"-- \"{[1@2012-01-01, 1@2012-01-03),[1@2012-01-04, 1@2012-01-05)}\""
msgstr ""
"SELECT atPeriodSet(tint '[1@2012-01-01, 1@2012-01-15)',\n"
"periodset '{[2012-01-01, 2012-01-03), [2012-01-04, 2012-01-05)}');\n"
"-- \"{[1@2012-01-01, 1@2012-01-03),[1@2012-01-04, 1@2012-01-05)}\""

#. Tag: varname
#: manipulating_temporal_types.xml:838
#, no-c-format
msgid "atTbox"
msgstr "atTbox"

#. Tag: para
#: manipulating_temporal_types.xml:839
#, no-c-format
msgid "Restrict to a <varname>tbox</varname>"
msgstr "Restringir a un <varname>tbox</varname>"

#. Tag: varname
#: manipulating_temporal_types.xml:840
#, no-c-format
msgid "atTbox(tnumber, tbox): tnumber"
msgstr "atTbox(tnumber, tbox): tnumber"

#. Tag: programlisting
#: manipulating_temporal_types.xml:841
#, no-c-format
msgid ""
"SELECT atTbox(tfloat '[0@2012-01-01, 3@2012-01-04)',\n"
"tbox 'TBOX((0, 2012-01-02), (2, 2012-01-04))');\n"
"-- \"{[1@2012-01-02, 2@2012-01-03]}\""
msgstr ""
"SELECT atTbox(tfloat '[0@2012-01-01, 3@2012-01-04)',\n"
"tbox 'TBOX((0, 2012-01-02), (2, 2012-01-04))');\n"
"-- \"{[1@2012-01-02, 2@2012-01-03]}\""

#. Tag: varname
#: manipulating_temporal_types.xml:845
#, no-c-format
msgid "atStbox"
msgstr "atStbox"

#. Tag: para
#: manipulating_temporal_types.xml:846
#, no-c-format
msgid "Restrict to an <varname>stbox</varname>"
msgstr "Restringir a un <varname>stbox</varname>"

#. Tag: varname
#: manipulating_temporal_types.xml:847
#, no-c-format
msgid "atStbox(tgeompoint, stbox): tgeompoint"
msgstr "atStbox(tgeompoint, stbox): tgeompoint"

#. Tag: programlisting
#: manipulating_temporal_types.xml:848
#, no-c-format
msgid ""
"SELECT asText(atStbox(tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-04)',\n"
"stbox 'STBOX T((0, 0, 2012-01-02), (2, 2, 2012-01-04))'));\n"
"-- \"{[POINT(1 1)@2012-01-02, POINT(2 2)@2012-01-03]}\""
msgstr ""
"SELECT asText(atStbox(tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-04)',\n"
"stbox 'STBOX T((0, 0, 2012-01-02), (2, 2, 2012-01-04))'));\n"
"-- \"{[POINT(1 1)@2012-01-02, POINT(2 2)@2012-01-03]}\""

#. Tag: title
#: manipulating_temporal_types.xml:854
#, no-c-format
msgid "Difference Functions"
msgstr "Funciones de diferencia"

#. Tag: para
#: manipulating_temporal_types.xml:855
#, no-c-format
msgid ""
"These functions restrict the temporal value with respect to the complement "
"of a value/range or a time extent."
msgstr ""
"Estas funciones restringen el valor temporal con respecto al complemento de "
"un valor/rango o una extensión de tiempo."

#. Tag: varname
#: manipulating_temporal_types.xml:858
#, no-c-format
msgid "minusValue"
msgstr "minusValue"

#. Tag: para
#: manipulating_temporal_types.xml:859
#, no-c-format
msgid "Difference with a value"
msgstr "Diferencia con un valor"

#. Tag: varname
#: manipulating_temporal_types.xml:860
#, no-c-format
msgid "minusValue(ttype, base): ttype"
msgstr "minusValue(ttype, base): ttype"

#. Tag: programlisting
#: manipulating_temporal_types.xml:861
#, no-c-format
msgid ""
"SELECT minusValue(tint '[1@2012-01-01, 2@2012-01-02, 2@2012-01-03)', 1);\n"
"-- \"{[2@2012-01-02, 2@2012-01-03)}\"\n"
"SELECT asText(minusValue(tgeompoint '[Point(0 0 0)@2012-01-01, Point(2 2 2)@2012-01-03)',\n"
"'Point(1 1 1)'));\n"
"-- \"{[POINT Z (0 0 0)@2012-01-01, POINT Z (1 1 1)@2012-01-02),\n"
"(POINT Z (1 1 1)@2012-01-02, POINT Z (2 2 2)@2012-01-03)}\""
msgstr ""
"SELECT minusValue(tint '[1@2012-01-01, 2@2012-01-02, 2@2012-01-03)', 1);\n"
"-- \"{[2@2012-01-02, 2@2012-01-03)}\"\n"
"SELECT asText(minusValue(tgeompoint '[Point(0 0 0)@2012-01-01, Point(2 2 2)@2012-01-03)',\n"
"'Point(1 1 1)'));\n"
"-- \"{[POINT Z (0 0 0)@2012-01-01, POINT Z (1 1 1)@2012-01-02),\n"
"(POINT Z (1 1 1)@2012-01-02, POINT Z (2 2 2)@2012-01-03)}\""

#. Tag: varname
#: manipulating_temporal_types.xml:865
#, no-c-format
msgid "minusValues"
msgstr "minusValues"

#. Tag: para
#: manipulating_temporal_types.xml:866
#, no-c-format
msgid "Difference with an array of values"
msgstr "Diferencia con una matriz de valores"

#. Tag: varname
#: manipulating_temporal_types.xml:867
#, no-c-format
msgid "minusValues(ttype, base[]): ttype"
msgstr "minusValues(ttype, base[]): ttype"

#. Tag: programlisting
#: manipulating_temporal_types.xml:868
#, no-c-format
msgid ""
"SELECT minusValues(tfloat '[1@2012-01-01, 4@2012-01-4)', ARRAY[2, 3]);\n"
"-- \"{[1@2012-01-01, 2@2012-01-02), (2@2012-01-02, 3@2012-01-03),\n"
"(3@2012-01-03, 4@2012-01-04)}\"\n"
"SELECT asText(minusValues(tgeompoint '[Point(0 0 0)@2012-01-01, Point(3 3 3)@2012-01-04)',\n"
"ARRAY[geometry 'Point(1 1 1)', 'Point(2 2 2)']));\n"
"-- \"{[POINT Z (0 0 0)@2012-01-01, POINT Z (1 1 1)@2012-01-02),\n"
"(POINT Z (1 1 1)@2012-01-02, POINT Z (2 2 2)@2012-01-03),\n"
"(POINT Z (2 2 2)@2012-01-03, POINT Z (3 3 3)@2012-01-04)}\""
msgstr ""
"SELECT minusValues(tfloat '[1@2012-01-01, 4@2012-01-4)', ARRAY[2, 3]);\n"
"-- \"{[1@2012-01-01, 2@2012-01-02), (2@2012-01-02, 3@2012-01-03),\n"
"(3@2012-01-03, 4@2012-01-04)}\"\n"
"SELECT asText(minusValues(tgeompoint '[Point(0 0 0)@2012-01-01, Point(3 3 3)@2012-01-04)',\n"
"ARRAY[geometry 'Point(1 1 1)', 'Point(2 2 2)']));\n"
"-- \"{[POINT Z (0 0 0)@2012-01-01, POINT Z (1 1 1)@2012-01-02),\n"
"(POINT Z (1 1 1)@2012-01-02, POINT Z (2 2 2)@2012-01-03),\n"
"(POINT Z (2 2 2)@2012-01-03, POINT Z (3 3 3)@2012-01-04)}\""

#. Tag: varname
#: manipulating_temporal_types.xml:872
#, no-c-format
msgid "minusRange"
msgstr "minusRange"

#. Tag: para
#: manipulating_temporal_types.xml:873
#, no-c-format
msgid "Difference with a range"
msgstr "Diferencia con un rango de valores"

#. Tag: varname
#: manipulating_temporal_types.xml:874
#, no-c-format
msgid "minusRange(tnumber, numrange): ttype"
msgstr "minusRange(tnumber, numrange): ttype"

#. Tag: programlisting
#: manipulating_temporal_types.xml:875
#, no-c-format
msgid ""
"SELECT minusRange(tfloat '[1@2012-01-01, 4@2012-01-4)', floatrange '[2,3]');\n"
"-- \"{[1@2012-01-01, 2@2012-01-02), (3@2012-01-03, 4@2012-01-04)}\""
msgstr ""
"SELECT minusRange(tfloat '[1@2012-01-01, 4@2012-01-4)', floatrange '[2,3]');\n"
"-- \"{[1@2012-01-01, 2@2012-01-02), (3@2012-01-03, 4@2012-01-04)}\""

#. Tag: varname
#: manipulating_temporal_types.xml:879
#, no-c-format
msgid "minusRanges"
msgstr "minusRanges"

#. Tag: para
#: manipulating_temporal_types.xml:880
#, no-c-format
msgid "Difference with an array of ranges"
msgstr "Diferencia con una matriz de rangos de valores"

#. Tag: varname
#: manipulating_temporal_types.xml:881
#, no-c-format
msgid "minusRanges(tnumber, numrange[]): ttype"
msgstr "minusRanges(tnumber, numrange[]): ttype"

#. Tag: programlisting
#: manipulating_temporal_types.xml:882
#, no-c-format
msgid ""
"SELECT minusRanges(tfloat '[1@2012-01-01, 5@2012-01-05)',\n"
"ARRAY[floatrange '[1,2]', '[3,4]']);\n"
"-- \"{(2@2012-01-02, 3@2012-01-03), (4@2012-01-04, 5@2012-01-05)}\""
msgstr ""
"SELECT minusRanges(tfloat '[1@2012-01-01, 5@2012-01-05)',\n"
"ARRAY[floatrange '[1,2]', '[3,4]']);\n"
"-- \"{(2@2012-01-02, 3@2012-01-03), (4@2012-01-04, 5@2012-01-05)}\""

#. Tag: varname
#: manipulating_temporal_types.xml:886
#, no-c-format
msgid "minusMin"
msgstr "minusMin"

#. Tag: para
#: manipulating_temporal_types.xml:887
#, no-c-format
msgid "Difference with the minimum value"
msgstr "Diferencia con el valor mínimo"

#. Tag: varname
#: manipulating_temporal_types.xml:888
#, no-c-format
msgid "minusMin(torder): torder"
msgstr "minusMin(torder): torder"

#. Tag: programlisting
#: manipulating_temporal_types.xml:889
#, no-c-format
msgid ""
"SELECT minusMin(tint '{1@2012-01-01, 2@2012-01-03, 1@2012-01-05}');\n"
"-- \"{2@2012-01-03}\"\n"
"SELECT minusMin(tfloat '[1@2012-01-01, 3@2012-01-03]');\n"
"-- \"{(1@2012-01-01, 3@2012-01-03]}\"\n"
"SELECT minusMin(tfloat '(1@2012-01-01, 3@2012-01-03)');\n"
"-- \"{(1@2012-01-01, 3@2012-01-03)}\"\n"
"SELECT minusMin(tint '{[1@2012-01-01, 1@2012-01-03), (1@2012-01-03, 1@2012-01-05)}');\n"
"-- NULL"
msgstr ""
"SELECT minusMin(tint '{1@2012-01-01, 2@2012-01-03, 1@2012-01-05}');\n"
"-- \"{2@2012-01-03}\"\n"
"SELECT minusMin(tfloat '[1@2012-01-01, 3@2012-01-03]');\n"
"-- \"{(1@2012-01-01, 3@2012-01-03]}\"\n"
"SELECT minusMin(tfloat '(1@2012-01-01, 3@2012-01-03)');\n"
"-- \"{(1@2012-01-01, 3@2012-01-03)}\"\n"
"SELECT minusMin(tint '{[1@2012-01-01, 1@2012-01-03), (1@2012-01-03, 1@2012-01-05)}');\n"
"-- NULL"

#. Tag: varname
#: manipulating_temporal_types.xml:893
#, no-c-format
msgid "minusMax"
msgstr "minusMax"

#. Tag: para
#: manipulating_temporal_types.xml:894
#, no-c-format
msgid "Difference with the maximum value"
msgstr "Diferencia con el valor máximo"

#. Tag: varname
#: manipulating_temporal_types.xml:895
#, no-c-format
msgid "minusMax(torder): torder"
msgstr "minusMax(torder): torder"

#. Tag: programlisting
#: manipulating_temporal_types.xml:896
#, no-c-format
msgid ""
"SELECT minusMax(tint '{1@2012-01-01, 2@2012-01-03, 3@2012-01-05}');\n"
"-- \"{1@2012-01-01, 2@2012-01-03}\"\n"
"SELECT minusMax(tfloat '[1@2012-01-01, 3@2012-01-03]');\n"
"-- \"{[1@2012-01-01, 3@2012-01-03)}\"\n"
"SELECT minusMax(tfloat '(1@2012-01-01, 3@2012-01-03)');\n"
"-- \"{(1@2012-01-01, 3@2012-01-03)}\"\n"
"SELECT minusMax(tfloat '{[2@2012-01-01, 1@2012-01-03), [2@2012-01-03, 2@2012-01-05)}');\n"
"-- \"{(2@2012-01-01, 1@2012-01-03)}\"\n"
"SELECT minusMax(tfloat '{[1@2012-01-01, 3@2012-01-03), (3@2012-01-03, 1@2012-01-05)}');\n"
"-- \"{[1@2012-01-01, 3@2012-01-03), (3@2012-01-03, 1@2012-01-05)}\""
msgstr ""
"SELECT minusMax(tint '{1@2012-01-01, 2@2012-01-03, 3@2012-01-05}');\n"
"-- \"{1@2012-01-01, 2@2012-01-03}\"\n"
"SELECT minusMax(tfloat '[1@2012-01-01, 3@2012-01-03]');\n"
"-- \"{[1@2012-01-01, 3@2012-01-03)}\"\n"
"SELECT minusMax(tfloat '(1@2012-01-01, 3@2012-01-03)');\n"
"-- \"{(1@2012-01-01, 3@2012-01-03)}\"\n"
"SELECT minusMax(tfloat '{[2@2012-01-01, 1@2012-01-03), [2@2012-01-03, 2@2012-01-05)}');\n"
"-- \"{(2@2012-01-01, 1@2012-01-03)}\"\n"
"SELECT minusMax(tfloat '{[1@2012-01-01, 3@2012-01-03), (3@2012-01-03, 1@2012-01-05)}');\n"
"-- \"{[1@2012-01-01, 3@2012-01-03), (3@2012-01-03, 1@2012-01-05)}\""

#. Tag: varname
#: manipulating_temporal_types.xml:900
#, no-c-format
msgid "minusGeometry"
msgstr "minusGeometry"

#. Tag: para
#: manipulating_temporal_types.xml:901
#, no-c-format
msgid "Difference with a geometry"
msgstr "Diferencia con una geometría"

#. Tag: varname
#: manipulating_temporal_types.xml:902
#, no-c-format
msgid "minusGeometry(tgeompoint, geometry): tgeompoint"
msgstr "minusGeometry(tgeompoint, geometry): tgeompoint"

#. Tag: programlisting
#: manipulating_temporal_types.xml:903
#, no-c-format
msgid ""
"SELECT asText(minusGeometry(tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-04)',\n"
"geometry 'Polygon((1 1,1 2,2 2,2 1,1 1))'));\n"
"-- \"{[POINT(0 0)@2012-01-01, POINT(1 1)@2012-01-02), (POINT(2 2)@2012-01-03,\n"
"POINT(3 3)@2012-01-04)}\""
msgstr ""
"SELECT asText(minusGeometry(tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-04)',\n"
"geometry 'Polygon((1 1,1 2,2 2,2 1,1 1))'));\n"
"-- \"{[POINT(0 0)@2012-01-01, POINT(1 1)@2012-01-02), (POINT(2 2)@2012-01-03,\n"
"POINT(3 3)@2012-01-04)}\""

#. Tag: varname
#: manipulating_temporal_types.xml:907
#, no-c-format
msgid "minusTimestamp"
msgstr "minusTimestamp"

#. Tag: para
#: manipulating_temporal_types.xml:908
#, no-c-format
msgid "Difference with a timestamp"
msgstr "Diferencia con una marca de tiempo"

#. Tag: varname
#: manipulating_temporal_types.xml:909
#, no-c-format
msgid "minusTimestamp(ttype, timestamptz): ttype"
msgstr "minusTimestamp(ttype, timestamptz): ttype"

#. Tag: programlisting
#: manipulating_temporal_types.xml:910
#, no-c-format
msgid ""
"SELECT minusTimestamp(tfloat '[1@2012-01-01, 5@2012-01-05)', '2012-01-02');\n"
"-- \"{[1@2012-01-01, 2@2012-01-02), (2@2012-01-02, 5@2012-01-05)}\""
msgstr ""
"SELECT minusTimestamp(tfloat '[1@2012-01-01, 5@2012-01-05)', '2012-01-02');\n"
"-- \"{[1@2012-01-01, 2@2012-01-02), (2@2012-01-02, 5@2012-01-05)}\""

#. Tag: varname
#: manipulating_temporal_types.xml:914
#, no-c-format
msgid "minusTimestampSet"
msgstr "minusTimestampSet"

#. Tag: para
#: manipulating_temporal_types.xml:915
#, no-c-format
msgid "Difference with a timestamp set"
msgstr "Diferencia con un conjunto de marcas de tiempo"

#. Tag: varname
#: manipulating_temporal_types.xml:916
#, no-c-format
msgid "minusTimestampSet(ttype, timestampset): ttype"
msgstr "minusTimestampSet(ttype, timestampset): ttype"

#. Tag: programlisting
#: manipulating_temporal_types.xml:917
#, no-c-format
msgid ""
"SELECT minusTimestampSet(tint '[1@2012-01-01, 1@2012-01-15)',\n"
"timestampset '{2012-01-02, 2012-01-03}');\n"
"-- \"{[1@2012-01-01, 1@2012-01-02), (1@2012-01-02, 1@2012-01-03),\n"
"(1@2012-01-03, 1@2012-01-15)}\""
msgstr ""
"SELECT minusTimestampSet(tint '[1@2012-01-01, 1@2012-01-15)',\n"
"timestampset '{2012-01-02, 2012-01-03}');\n"
"-- \"{[1@2012-01-01, 1@2012-01-02), (1@2012-01-02, 1@2012-01-03),\n"
"(1@2012-01-03, 1@2012-01-15)}\""

#. Tag: varname
#: manipulating_temporal_types.xml:921
#, no-c-format
msgid "minusPeriod"
msgstr "minusPeriod"

#. Tag: para
#: manipulating_temporal_types.xml:922
#, no-c-format
msgid "Difference with a period"
msgstr "Diferencia con un período"

#. Tag: varname
#: manipulating_temporal_types.xml:923
#, no-c-format
msgid "minusPeriod(ttype, period): ttype"
msgstr "minusPeriod(ttype, period): ttype"

#. Tag: programlisting
#: manipulating_temporal_types.xml:924
#, no-c-format
msgid ""
"SELECT minusPeriod(tfloat '{[1@2012-01-01, 3@2012-01-03), [3@2012-01-04, 1@2012-01-06)}',\n"
"'[2012-01-02,2012-01-05)');\n"
"-- \"{[1@2012-01-01, 2@2012-01-02), [2@2012-01-05, 1@2012-01-06)}\""
msgstr ""
"SELECT minusPeriod(tfloat '{[1@2012-01-01, 3@2012-01-03), [3@2012-01-04, 1@2012-01-06)}',\n"
"'[2012-01-02,2012-01-05)');\n"
"-- \"{[1@2012-01-01, 2@2012-01-02), [2@2012-01-05, 1@2012-01-06)}\""

#. Tag: varname
#: manipulating_temporal_types.xml:928
#, no-c-format
msgid "minusPeriodSet"
msgstr "minusPeriodSet"

#. Tag: para
#: manipulating_temporal_types.xml:929
#, no-c-format
msgid "Difference with a period set"
msgstr "Diferencia con un conjunto de períodos"

#. Tag: varname
#: manipulating_temporal_types.xml:930
#, no-c-format
msgid "minusPeriodSet(ttype, periodset): ttype"
msgstr "minusPeriodSet(ttype, periodset): ttype"

#. Tag: programlisting
#: manipulating_temporal_types.xml:931
#, no-c-format
msgid ""
"SELECT minusPeriodSet(tint '[1@2012-01-01, 1@2012-01-15)',\n"
"periodset '{[2012-01-02, 2012-01-03), [2012-01-04, 2012-01-05)}');\n"
"-- \"{[1@2012-01-01, 1@2012-01-02), [1@2012-01-03, 1@2012-01-04),\n"
"[1@2012-01-05, 1@2012-01-15)}\""
msgstr ""
"SELECT minusPeriodSet(tint '[1@2012-01-01, 1@2012-01-15)',\n"
"periodset '{[2012-01-02, 2012-01-03), [2012-01-04, 2012-01-05)}');\n"
"-- \"{[1@2012-01-01, 1@2012-01-02), [1@2012-01-03, 1@2012-01-04),\n"
"[1@2012-01-05, 1@2012-01-15)}\""

#. Tag: varname
#: manipulating_temporal_types.xml:935
#, no-c-format
msgid "minusTbox"
msgstr "minusTbox"

#. Tag: para
#: manipulating_temporal_types.xml:936
#, no-c-format
msgid "Difference with a <varname>tbox</varname>"
msgstr "Diferencia con un <varname>tbox</varname>"

#. Tag: varname
#: manipulating_temporal_types.xml:937
#, no-c-format
msgid "minusTbox(tnumber, tbox): tnumber"
msgstr "minusTbox(tnumber, tbox): tnumber"

#. Tag: programlisting
#: manipulating_temporal_types.xml:938
#, no-c-format
msgid ""
"SELECT minusTbox(tfloat '[0@2012-01-01, 3@2012-01-04)',\n"
"tbox 'TBOX((0, 2012-01-02), (2, 2012-01-04))');\n"
"-- \"{[0@2012-01-01, 1@2012-01-02), (2@2012-01-03, 3@2012-01-04)}\""
msgstr ""
"SELECT minusTbox(tfloat '[0@2012-01-01, 3@2012-01-04)',\n"
"tbox 'TBOX((0, 2012-01-02), (2, 2012-01-04))');\n"
"-- \"{[0@2012-01-01, 1@2012-01-02), (2@2012-01-03, 3@2012-01-04)}\""

#. Tag: varname
#: manipulating_temporal_types.xml:942
#, no-c-format
msgid "minusStbox"
msgstr "minusStbox"

#. Tag: para
#: manipulating_temporal_types.xml:943
#, no-c-format
msgid "Difference with an <varname>stbox</varname>"
msgstr "Diferencia con un <varname>stbox</varname>"

#. Tag: varname
#: manipulating_temporal_types.xml:944
#, no-c-format
msgid "minusStbox(tgeompoint, stbox): tgeompoint"
msgstr "minusStbox(tgeompoint, stbox): tgeompoint"

#. Tag: programlisting
#: manipulating_temporal_types.xml:945
#, no-c-format
msgid ""
"SELECT asText(minusStbox(tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-04)',\n"
"stbox 'STBOX T((0, 0, 2012-01-02), (2, 2, 2012-01-04))'));\n"
"-- \"{[POINT(0 0)@2012-01-01, POINT(1 1)@2012-01-02),\n"
"(POINT(2 2)@2012-01-03, POINT(3 3)@2012-01-04)}\""
msgstr ""
"SELECT asText(minusStbox(tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-04)',\n"
"stbox 'STBOX T((0, 0, 2012-01-02), (2, 2, 2012-01-04))'));\n"
"-- \"{[POINT(0 0)@2012-01-01, POINT(1 1)@2012-01-02),\n"
"(POINT(2 2)@2012-01-03, POINT(3 3)@2012-01-04)}\""

#. Tag: title
#: manipulating_temporal_types.xml:951
#, no-c-format
msgid "Comparison Operators"
msgstr "Operadores de comparación"

#. Tag: para
#: manipulating_temporal_types.xml:953
#, no-c-format
msgid ""
"The traditional comparison operators (<varname>=</varname>, "
"<varname>&lt;</varname>, and so on) require that the left and right operands"
" be of the same base type. Excepted equality and inequality, the other "
"comparison operators are not useful in the real world but allow B-tree "
"indexes to be constructed on temporal types. These operators compare the "
"bounding boxes (see <xref linkend=\"comparison_box_types\"/>) and if those "
"are equal, then the comparison depends on the duration. For temporal instant"
" values, they compare first the timestamps and if those are equal, compare "
"the values. For temporal instant set and sequence values, they compare the "
"first N instants, where N is the minimum of the number of composing instants"
" of both values. Finally, for temporal sequence set values, they compare the"
" first N sequence values, where N is the minimum of the number of composing "
"sequences of both values."
msgstr ""
"Los operadores de comparación tradicionales (<varname>=</varname>, "
"<varname>&lt;</varname>, etc.) requieren que los operandos izquierdo y "
"derecho sean del mismo tipo base. Excepto la igualdad y la desigualdad, los "
"otros operadores de comparación no son útiles en el mundo real pero permiten"
" que los índices de árbol B se construyan sobre tipos temporales. Estos "
"operadores comparan los cuadros delimitadores (ver <xref "
"linkend=\"comparison_box_types\"/>) y si son iguales, entonces la "
"comparación depende de la duración. Para los valores instantáneos "
"temporales, primero comparan las marcas de tiempo y, si son iguales, "
"comparan los valores. Para los valores de secuencia y conjunto de "
"instantáneos temporales, comparan los primeros N instantes, donde N es el "
"mínimo del número de instantes que componen ambos valores. Finalmente, para "
"los valores de conjuntos de secuencias temporales, comparan los primeros N "
"valores de secuencia, donde N es el mínimo del número de secuencias que "
"componen ambos valores."

#. Tag: para
#: manipulating_temporal_types.xml:955
#, no-c-format
msgid ""
"The equality and inequality operators consider the equivalent representation"
" for different durations as shown next."
msgstr ""
"Los operadores de igualdad y desigualdad consideran la representación "
"equivalente para diferentes duraciones como se muestra a continuación."

#. Tag: programlisting
#: manipulating_temporal_types.xml:956
#, no-c-format
msgid ""
"SELECT tint '1@2001-01-01' = tint '{1@2001-01-01}';\n"
"-- true\n"
"SELECT tfloat '1.5@2001-01-01' = tfloat '[1.5@2001-01-01]';\n"
"-- true\n"
"SELECT ttext 'AAA@2001-01-01' = ttext '{[AAA@2001-01-01]}';\n"
"-- true\n"
"SELECT tgeompoint '{Point(1 1)@2001-01-01, Point(2 2)@2001-01-02}' =\n"
"tgeompoint '{[Point(1 1)@2001-01-01], [Point(2 2)@2001-01-02]}';\n"
"-- true\n"
"SELECT tgeogpoint '[Point(1 1 1)@2001-01-01, Point(2 2 2)@2001-01-02]' =\n"
"tgeogpoint '{[Point(1 1 1)@2001-01-01], [Point(2 2 2)@2001-01-02]}';\n"
"-- true"
msgstr ""
"SELECT tint '1@2001-01-01' = tint '{1@2001-01-01}';\n"
"-- true\n"
"SELECT tfloat '1.5@2001-01-01' = tfloat '[1.5@2001-01-01]';\n"
"-- true\n"
"SELECT ttext 'AAA@2001-01-01' = ttext '{[AAA@2001-01-01]}';\n"
"-- true\n"
"SELECT tgeompoint '{Point(1 1)@2001-01-01, Point(2 2)@2001-01-02}' =\n"
"tgeompoint '{[Point(1 1)@2001-01-01], [Point(2 2)@2001-01-02]}';\n"
"-- true\n"
"SELECT tgeogpoint '[Point(1 1 1)@2001-01-01, Point(2 2 2)@2001-01-02]' =\n"
"tgeogpoint '{[Point(1 1 1)@2001-01-01], [Point(2 2 2)@2001-01-02]}';\n"
"-- true"

#. Tag: varname
#: manipulating_temporal_types.xml:961
#, no-c-format
msgid "<varname>=</varname>"
msgstr "<varname>=</varname>"

#. Tag: para
#: manipulating_temporal_types.xml:962
#, no-c-format
msgid "Are the temporal values equal?"
msgstr "¿Son iguales los valores temporales?"

#. Tag: varname
#: manipulating_temporal_types.xml:963
#, no-c-format
msgid "ttype = ttype: boolean"
msgstr "ttype = ttype: boolean"

#. Tag: programlisting
#: manipulating_temporal_types.xml:964
#, no-c-format
msgid ""
"SELECT tint '[1@2012-01-01, 1@2012-01-04)' = tint '[2@2012-01-03, 2@2012-01-05)';\n"
"-- false"
msgstr ""
"SELECT tint '[1@2012-01-01, 1@2012-01-04)' = tint '[2@2012-01-03, 2@2012-01-05)';\n"
"-- false"

#. Tag: varname
#: manipulating_temporal_types.xml:968
#, no-c-format
msgid "&lt;&gt;"
msgstr "&lt;&gt;"

#. Tag: para
#: manipulating_temporal_types.xml:969
#, no-c-format
msgid "Are the temporal values different?"
msgstr "¿Son diferentes los valores temporales?"

#. Tag: varname
#: manipulating_temporal_types.xml:970
#, no-c-format
msgid "ttype &lt;&gt; ttype: boolean"
msgstr "ttype &lt;&gt; ttype: boolean"

#. Tag: programlisting
#: manipulating_temporal_types.xml:971
#, no-c-format
msgid ""
"SELECT tint '[1@2012-01-01, 1@2012-01-04)' &lt;&gt; tint '[2@2012-01-03, 2@2012-01-05)'\n"
"-- true"
msgstr ""
"SELECT tint '[1@2012-01-01, 1@2012-01-04)' &lt;&gt; tint '[2@2012-01-03, 2@2012-01-05)'\n"
"-- true"

#. Tag: varname
#: manipulating_temporal_types.xml:975
#, no-c-format
msgid "&lt;"
msgstr "&lt;"

#. Tag: para
#: manipulating_temporal_types.xml:976
#, no-c-format
msgid "Is the first temporal value less than the second one?"
msgstr "¿Es el primer valor temporal menor que el segundo?"

#. Tag: varname
#: manipulating_temporal_types.xml:977
#, no-c-format
msgid "ttype &lt; ttype: boolean"
msgstr "ttype &lt; ttype: boolean"

#. Tag: programlisting
#: manipulating_temporal_types.xml:978
#, no-c-format
msgid ""
"SELECT tint '[1@2012-01-01, 1@2012-01-04)' &lt; tint '[2@2012-01-03, 2@2012-01-05)'\n"
"-- true"
msgstr ""
"SELECT tint '[1@2012-01-01, 1@2012-01-04)' &lt; tint '[2@2012-01-03, 2@2012-01-05)'\n"
"-- true"

#. Tag: varname
#: manipulating_temporal_types.xml:982
#, no-c-format
msgid "&gt;"
msgstr "&gt;"

#. Tag: para
#: manipulating_temporal_types.xml:983
#, no-c-format
msgid "Is the first temporal value greater than the second one?"
msgstr "¿Es el primer valor temporal mayor que el segundo?"

#. Tag: varname
#: manipulating_temporal_types.xml:984
#, no-c-format
msgid "ttype &gt; ttype: boolean"
msgstr "ttype &gt; ttype: boolean"

#. Tag: programlisting
#: manipulating_temporal_types.xml:985
#, no-c-format
msgid ""
"SELECT tint '[1@2012-01-01, 1@2012-01-04)' &gt; tint '[2@2012-01-03, 2@2012-01-05)'\n"
"-- false"
msgstr ""
"SELECT tint '[1@2012-01-01, 1@2012-01-04)' &gt; tint '[2@2012-01-03, 2@2012-01-05)'\n"
"-- false"

#. Tag: varname
#: manipulating_temporal_types.xml:989
#, no-c-format
msgid "&lt;="
msgstr "&lt;="

#. Tag: para
#: manipulating_temporal_types.xml:990
#, no-c-format
msgid "Is the first temporal value less than or equal to the second one?"
msgstr "¿Es el primer valor temporal menor o igual que el segundo?"

#. Tag: varname
#: manipulating_temporal_types.xml:991
#, no-c-format
msgid "ttype &lt;= ttype: boolean"
msgstr "ttype &lt;= ttype: boolean"

#. Tag: programlisting
#: manipulating_temporal_types.xml:992
#, no-c-format
msgid ""
"SELECT tint '[1@2012-01-01, 1@2012-01-04)' &lt;= tint '[2@2012-01-03, 2@2012-01-05)'\n"
"-- true"
msgstr ""
"SELECT tint '[1@2012-01-01, 1@2012-01-04)' &lt;= tint '[2@2012-01-03, 2@2012-01-05)'\n"
"-- true"

#. Tag: varname
#: manipulating_temporal_types.xml:996
#, no-c-format
msgid "&gt;="
msgstr "&gt;="

#. Tag: para
#: manipulating_temporal_types.xml:997
#, no-c-format
msgid "Is the first temporal value greater than or equal to the second one?"
msgstr "¿El primer valor temporal es mayor o igual que el segundo?"

#. Tag: varname
#: manipulating_temporal_types.xml:998
#, no-c-format
msgid "ttype &gt;= ttype: boolean"
msgstr "ttype &gt;= ttype: boolean"

#. Tag: programlisting
#: manipulating_temporal_types.xml:999
#, no-c-format
msgid ""
"SELECT tint '[1@2012-01-01, 1@2012-01-04)' &gt;= tint '[2@2012-01-03, 2@2012-01-05)'\n"
"-- false"
msgstr ""
"SELECT tint '[1@2012-01-01, 1@2012-01-04)' &gt;= tint '[2@2012-01-03, 2@2012-01-05)'\n"
"-- false"

#. Tag: title
#: manipulating_temporal_types.xml:1005
#, no-c-format
msgid "Ever and Always Comparison Operators"
msgstr "Operadores de comparación siempre y alguna vez"

#. Tag: para
#: manipulating_temporal_types.xml:1006
#, no-c-format
msgid ""
"A possible generalization of the traditional comparison operators "
"(<varname>=</varname>, <varname>&lt;&gt;</varname>, <varname>&lt;</varname>,"
" <varname>&lt;=</varname>, etc.) to temporal types, is to determine whether "
"the comparison is ever or always true. In this case, the result is a Boolean"
" value. MobilityDB provides operators to test whether the comparison of a "
"temporal value and a value of the base type is ever or always true. These "
"operators are denoted by prefixing the traditional comparison operators "
"with, respectively, <varname>?</varname> (ever) and <varname>%</varname> "
"(always). Some examples are <varname>?=</varname>, "
"<varname>%&lt;&gt;</varname>, or <varname>?&lt;=</varname>. Ever/always "
"equality and non-equality are available for all temporal types, while "
"ever/always inequalities are only available for temporal types whose base "
"type has a total order defined, that is, <varname>tint</varname>, "
"<varname>tfloat</varname>, or <varname>ttext</varname>. The ever and always "
"comparisons are inverse operators: for example, <varname>?=</varname> is the"
" inverse of <varname>%&lt;&gt;</varname>, and <varname>?&gt;</varname> is "
"the inverse of <varname>%&lt;=</varname>."
msgstr ""
"Una posible generalización de los operadores de comparación tradicionales "
"(<varname>=</varname>, <varname>&lt;&gt;</varname>, <varname>&lt;</varname>,"
" <varname>&lt;=</varname>, etc.) a tipos temporales, es determinar si la "
"comparación es alguna vez o siempre verdadera. En este caso, el resultado es"
" un valor booleano. MobilityDB proporciona operadores para probar si la "
"comparación de un valor temporal y un valor del tipo base es alguna vez o "
"siempre verdadera. Estos operadores se indican anteponiendo los operadores "
"de comparación tradicionales con, respectivamente, <varname>?</varname> "
"(alguna vez) y<varname>%</varname> (siempre). Algunos ejemplos son "
"<varname>?=</varname>, <varname>%&lt;&gt;</varname>, o "
"<varname>?&lt;=</varname>. La igualdad y la no igualdad alguna vez/siempre  "
"están disponibles para todos los tipos temporales, mientras que las "
"desigualdades alguna vez/siempre solo están disponibles para los tipos "
"temporales cuyo tipo base tiene un orden total definido, es "
"decir,<varname>tint</varname>, <varname>tfloat</varname>, o "
"<varname>ttext</varname>. Las comparaciones alguna vez y siempre son "
"operadores inversos: por ejemplo,<varname>?=</varname> es el inverso de "
"<varname>%&lt;&gt;</varname>, y <varname>?&gt;</varname> es el inverso de "
"<varname>%&lt;=</varname>."

#. Tag: varname
#: manipulating_temporal_types.xml:1009
#, no-c-format
msgid "<varname>?=</varname>"
msgstr "<varname>?=</varname>"

#. Tag: para
#: manipulating_temporal_types.xml:1010
#, no-c-format
msgid "Is the temporal value ever equal to the value?"
msgstr "¿Es el valor temporal alguna vez igual al valor?"

#. Tag: varname
#: manipulating_temporal_types.xml:1011
#, no-c-format
msgid "ttype ?= base: bool"
msgstr "ttype ?= base: bool"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1013
#, no-c-format
msgid ""
"SELECT tfloat '[1@2012-01-01, 3@2012-01-04)' ?= 2;\n"
"-- true\n"
"SELECT tfloat '[1@2012-01-01, 3@2012-01-04)' ?= 3;\n"
"-- true\n"
"SELECT tgeompoint '[Point(0 0)@2012-01-01, Point(2 2)@2012-01-04)' ?=\n"
"geometry 'Point(1 1)';\n"
"-- true"
msgstr ""
"SELECT tfloat '[1@2012-01-01, 3@2012-01-04)' ?= 2;\n"
"-- true\n"
"SELECT tfloat '[1@2012-01-01, 3@2012-01-04)' ?= 3;\n"
"-- true\n"
"SELECT tgeompoint '[Point(0 0)@2012-01-01, Point(2 2)@2012-01-04)' ?=\n"
"geometry 'Point(1 1)';\n"
"-- true"

#. Tag: varname
#: manipulating_temporal_types.xml:1017
#, no-c-format
msgid "?&lt;&gt;"
msgstr "?&lt;&gt;"

#. Tag: para
#: manipulating_temporal_types.xml:1018
#, no-c-format
msgid "Is the temporal value ever different from the value?"
msgstr "¿Es el valor temporal alguna vez diferente del valor?"

#. Tag: varname
#: manipulating_temporal_types.xml:1019
#, no-c-format
msgid "ttype ?&lt;&gt; base: bool"
msgstr "ttype ?&lt;&gt; base: bool"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1020
#, no-c-format
msgid ""
"SELECT tfloat '[1@2012-01-01, 3@2012-01-04)' ?&lt;&gt; 2;\n"
"-- false\n"
"SELECT tfloat '[2@2012-01-01, 2@2012-01-04)' ?&lt;&gt; 2;\n"
"-- true\n"
"SELECT tgeompoint '[Point(1 1)@2012-01-01, Point(1 1)@2012-01-04)' ?&lt;&gt;\n"
"geometry 'Point(1 1)';\n"
"-- true"
msgstr ""
"SELECT tfloat '[1@2012-01-01, 3@2012-01-04)' ?&lt;&gt; 2;\n"
"-- false\n"
"SELECT tfloat '[2@2012-01-01, 2@2012-01-04)' ?&lt;&gt; 2;\n"
"-- true\n"
"SELECT tgeompoint '[Point(1 1)@2012-01-01, Point(1 1)@2012-01-04)' ?&lt;&gt;\n"
"geometry 'Point(1 1)';\n"
"-- true"

#. Tag: varname
#: manipulating_temporal_types.xml:1024
#, no-c-format
msgid "?&lt;"
msgstr "?&lt;"

#. Tag: para
#: manipulating_temporal_types.xml:1025
#, no-c-format
msgid "Is the temporal value ever less than the value?"
msgstr "¿Es el valor temporal alguna vez menor que el valor?"

#. Tag: varname
#: manipulating_temporal_types.xml:1026
#, no-c-format
msgid "tnumber ?&lt; number: bool"
msgstr "tnumber ?&lt; number: bool"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1027
#, no-c-format
msgid ""
"SELECT tfloat '[1@2012-01-01, 4@2012-01-04)' ?&lt; 2;\n"
"-- \"{[t@2012-01-01, f@2012-01-02, f@2012-01-04)}\"\n"
"SELECT tint '[2@2012-01-01, 2@2012-01-05)' ?&lt; tfloat '[1@2012-01-03, 3@2012-01-05)';\n"
"-- \"{[f@2012-01-03, f@2012-01-04], (t@2012-01-04, t@2012-01-05)}\""
msgstr ""
"SELECT tfloat '[1@2012-01-01, 4@2012-01-04)' ?&lt; 2;\n"
"-- \"{[t@2012-01-01, f@2012-01-02, f@2012-01-04)}\"\n"
"SELECT tint '[2@2012-01-01, 2@2012-01-05)' ?&lt; tfloat '[1@2012-01-03, 3@2012-01-05)';\n"
"-- \"{[f@2012-01-03, f@2012-01-04], (t@2012-01-04, t@2012-01-05)}\""

#. Tag: varname
#: manipulating_temporal_types.xml:1031
#, no-c-format
msgid "?&gt;"
msgstr "?&gt;"

#. Tag: para
#: manipulating_temporal_types.xml:1032
#, no-c-format
msgid "Is the temporal value ever greater than the value?"
msgstr "¿Es el valor temporal alguna vez mayor que el valor?"

#. Tag: varname
#: manipulating_temporal_types.xml:1033
#, no-c-format
msgid "tnumber ?&gt; number: bool"
msgstr "tnumber ?&gt; number: bool"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1034
#, no-c-format
msgid ""
"SELECT tint '[1@2012-01-03, 1@2012-01-05)' ?&gt; 1;\n"
"-- \"[f@2012-01-03, f@2012-01-05)\""
msgstr ""
"SELECT tint '[1@2012-01-03, 1@2012-01-05)' ?&gt; 1;\n"
"-- \"[f@2012-01-03, f@2012-01-05)\""

#. Tag: varname
#: manipulating_temporal_types.xml:1038
#, no-c-format
msgid "?&lt;="
msgstr "?&lt;="

#. Tag: para
#: manipulating_temporal_types.xml:1039
#, no-c-format
msgid "Is the temporal value ever less than or equal to the value?"
msgstr "¿Es el valor temporal alguna vez menor o igual que el valor?"

#. Tag: varname
#: manipulating_temporal_types.xml:1040
#, no-c-format
msgid "tnumber ?&lt;= number: bool"
msgstr "tnumber ?&lt;= number: bool"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1041
#, no-c-format
msgid ""
"SELECT tint '[1@2012-01-01, 1@2012-01-05)' ?&lt;= tfloat '{2@2012-01-03, 3@2012-01-04}';\n"
"-- \"{t@2012-01-03, t@2012-01-04}\""
msgstr ""
"SELECT tint '[1@2012-01-01, 1@2012-01-05)' ?&lt;= tfloat '{2@2012-01-03, 3@2012-01-04}';\n"
"-- \"{t@2012-01-03, t@2012-01-04}\""

#. Tag: varname
#: manipulating_temporal_types.xml:1045
#, no-c-format
msgid "?&gt;="
msgstr "?&gt;="

#. Tag: para
#: manipulating_temporal_types.xml:1046
#, no-c-format
msgid "Is the temporal value ever greater than or equal to the value?"
msgstr "¿Es el valor temporal alguna vez mayor o igual que el valor?"

#. Tag: varname
#: manipulating_temporal_types.xml:1047
#, no-c-format
msgid "tnumber ?&gt;= number: bool"
msgstr "tnumber ?&gt;= number: bool"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1048
#, no-c-format
msgid ""
"SELECT 'AAA'::text ?&gt; ttext '{[AAA@2012-01-01, AAA@2012-01-03),\n"
"[BBB@2012-01-04, BBB@2012-01-05)}';\n"
"-- \"{[f@2012-01-01, f@2012-01-03), [t@2012-01-04, t@2012-01-05)}\""
msgstr ""
"SELECT 'AAA'::text ?&gt; ttext '{[AAA@2012-01-01, AAA@2012-01-03),\n"
"[BBB@2012-01-04, BBB@2012-01-05)}';\n"
"-- \"{[f@2012-01-01, f@2012-01-03), [t@2012-01-04, t@2012-01-05)}\""

#. Tag: varname
#: manipulating_temporal_types.xml:1052
#, no-c-format
msgid "<varname>%=</varname>"
msgstr "<varname>%=</varname>"

#. Tag: para
#: manipulating_temporal_types.xml:1053
#, no-c-format
msgid "Is the temporal value always equal to the value?"
msgstr "¿Es el valor temporal siempre igual que el valor?"

#. Tag: varname
#: manipulating_temporal_types.xml:1054
#, no-c-format
msgid "ttype %= base: bool"
msgstr "ttype %= base: bool"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1056
#, no-c-format
msgid ""
"SELECT tfloat '[1@2012-01-01, 3@2012-01-04)' %= 2;\n"
"-- true\n"
"SELECT tfloat '[1@2012-01-01, 3@2012-01-04)' %= 3;\n"
"-- true\n"
"SELECT tgeompoint '[Point(0 0)@2012-01-01, Point(2 2)@2012-01-04)' %=\n"
"geometry 'Point(1 1)';\n"
"-- true"
msgstr ""
"SELECT tfloat '[1@2012-01-01, 3@2012-01-04)' %= 2;\n"
"-- true\n"
"SELECT tfloat '[1@2012-01-01, 3@2012-01-04)' %= 3;\n"
"-- true\n"
"SELECT tgeompoint '[Point(0 0)@2012-01-01, Point(2 2)@2012-01-04)' %=\n"
"geometry 'Point(1 1)';\n"
"-- true"

#. Tag: varname
#: manipulating_temporal_types.xml:1060
#, no-c-format
msgid "%&lt;&gt;"
msgstr "%&lt;&gt;"

#. Tag: para
#: manipulating_temporal_types.xml:1061
#, no-c-format
msgid "Is the temporal value always different to the value?"
msgstr "¿Es el valor temporal siempre diferente que el valor?"

#. Tag: varname
#: manipulating_temporal_types.xml:1062
#, no-c-format
msgid "ttype %&lt;&gt; base: bool"
msgstr "ttype %&lt;&gt; base: bool"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1063
#, no-c-format
msgid ""
"SELECT tfloat '[1@2012-01-01, 3@2012-01-04)' %&lt;&gt; 2;\n"
"-- false\n"
"SELECT tfloat '[2@2012-01-01, 2@2012-01-04)' %&lt;&gt; 2;\n"
"-- true\n"
"SELECT tgeompoint '[Point(1 1)@2012-01-01, Point(1 1)@2012-01-04)' %&lt;&gt;\n"
"geometry 'Point(1 1)';\n"
"-- true"
msgstr ""
"SELECT tfloat '[1@2012-01-01, 3@2012-01-04)' %&lt;&gt; 2;\n"
"-- false\n"
"SELECT tfloat '[2@2012-01-01, 2@2012-01-04)' %&lt;&gt; 2;\n"
"-- true\n"
"SELECT tgeompoint '[Point(1 1)@2012-01-01, Point(1 1)@2012-01-04)' %&lt;&gt;\n"
"geometry 'Point(1 1)';\n"
"-- true"

#. Tag: varname
#: manipulating_temporal_types.xml:1067
#, no-c-format
msgid "%&lt;"
msgstr "%&lt;"

#. Tag: para
#: manipulating_temporal_types.xml:1068
#, no-c-format
msgid "Is the temporal value always less than the value?"
msgstr "¿Es el valor temporal siempre menor que el valor?"

#. Tag: varname
#: manipulating_temporal_types.xml:1069
#, no-c-format
msgid "tnumber %&lt; number: bool"
msgstr "tnumber %&lt; number: bool"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1070
#, no-c-format
msgid ""
"SELECT tfloat '[1@2012-01-01, 4@2012-01-04)' %&lt; 2;\n"
"-- \"{[t@2012-01-01, f@2012-01-02, f@2012-01-04)}\"\n"
"SELECT tint '[2@2012-01-01, 2@2012-01-05)' %&lt; tfloat '[1@2012-01-03, 3@2012-01-05)';\n"
"-- \"{[f@2012-01-03, f@2012-01-04], (t@2012-01-04, t@2012-01-05)}\""
msgstr ""
"SELECT tfloat '[1@2012-01-01, 4@2012-01-04)' %&lt; 2;\n"
"-- \"{[t@2012-01-01, f@2012-01-02, f@2012-01-04)}\"\n"
"SELECT tint '[2@2012-01-01, 2@2012-01-05)' %&lt; tfloat '[1@2012-01-03, 3@2012-01-05)';\n"
"-- \"{[f@2012-01-03, f@2012-01-04], (t@2012-01-04, t@2012-01-05)}\""

#. Tag: varname
#: manipulating_temporal_types.xml:1074
#, no-c-format
msgid "%&gt;"
msgstr "%&gt;"

#. Tag: para
#: manipulating_temporal_types.xml:1075
#, no-c-format
msgid "Is the temporal value always greater than the value?"
msgstr "¿Es el valor temporal siempre mayor que el valor?"

#. Tag: varname
#: manipulating_temporal_types.xml:1076
#, no-c-format
msgid "tnumber %&gt; number: bool"
msgstr "tnumber %&gt; number: bool"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1077
#, no-c-format
msgid ""
"SELECT tint '[1@2012-01-03, 1@2012-01-05)' %&gt; 1;\n"
"-- \"[f@2012-01-03, f@2012-01-05)\""
msgstr ""
"SELECT tint '[1@2012-01-03, 1@2012-01-05)' %&gt; 1;\n"
"-- \"[f@2012-01-03, f@2012-01-05)\""

#. Tag: varname
#: manipulating_temporal_types.xml:1081
#, no-c-format
msgid "%&lt;="
msgstr "%&lt;="

#. Tag: para
#: manipulating_temporal_types.xml:1082
#, no-c-format
msgid "Is the temporal value always less than or equal to the value?"
msgstr "¿Es el valor temporal siempre menor o igual que el valor?"

#. Tag: varname
#: manipulating_temporal_types.xml:1083
#, no-c-format
msgid "tnumber %&lt;= number: bool"
msgstr "tnumber %&lt;= number: bool"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1084
#, no-c-format
msgid ""
"SELECT tint '[1@2012-01-01, 1@2012-01-05)' %&lt;= tfloat '{2@2012-01-03, 3@2012-01-04}';\n"
"-- \"{t@2012-01-03, t@2012-01-04}\""
msgstr ""
"SELECT tint '[1@2012-01-01, 1@2012-01-05)' %&lt;= tfloat '{2@2012-01-03, 3@2012-01-04}';\n"
"-- \"{t@2012-01-03, t@2012-01-04}\""

#. Tag: varname
#: manipulating_temporal_types.xml:1088
#, no-c-format
msgid "%&gt;="
msgstr "%&gt;="

#. Tag: para
#: manipulating_temporal_types.xml:1089
#, no-c-format
msgid "Is the temporal value always greater than or equal to the value?"
msgstr "¿Es el valor temporal siempre mayor o igual que el valor?"

#. Tag: varname
#: manipulating_temporal_types.xml:1090
#, no-c-format
msgid "tnumber %&gt;= number: bool"
msgstr "tnumber %&gt;= number: bool"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1091
#, no-c-format
msgid ""
"SELECT 'AAA'::text %&gt; ttext '{[AAA@2012-01-01, AAA@2012-01-03),\n"
"[BBB@2012-01-04, BBB@2012-01-05)}';\n"
"-- \"{[f@2012-01-01, f@2012-01-03), [t@2012-01-04, t@2012-01-05)}\""
msgstr ""
"SELECT 'AAA'::text %&gt; ttext '{[AAA@2012-01-01, AAA@2012-01-03),\n"
"[BBB@2012-01-04, BBB@2012-01-05)}';\n"
"-- \"{[f@2012-01-01, f@2012-01-03), [t@2012-01-04, t@2012-01-05)}\""

#. Tag: title
#: manipulating_temporal_types.xml:1097
#, no-c-format
msgid "Temporal Comparison Operators"
msgstr "Operadores de comparación temporal"

#. Tag: para
#: manipulating_temporal_types.xml:1098
#, no-c-format
msgid ""
"Another possible generalization of the traditional comparison operators "
"(<varname>=</varname>, <varname>&lt;&gt;</varname>, <varname>&lt;</varname>,"
" <varname>&lt;=</varname>, etc.) to temporal types, is to determine whether "
"the comparison is true or false at each instant. In this case, the result is"
" a temporal Boolean. The temporal comparison operators are denoted by "
"prefixing the traditional comparison operators with <varname>#</varname>. "
"Some examples are <varname>#=</varname> or <varname>#&lt;=</varname>. "
"Temporal equality and non-equality are available for all temporal types, "
"while temporal inequalities are only available for temporal types whose base"
" type has a total order defined, that is, <varname>tint</varname>, "
"<varname>tfloat</varname>, or <varname>ttext</varname>."
msgstr ""
"Otra posible generalización de los operadores de comparación tradicionales "
"(<varname>=</varname>, <varname>&lt;&gt;</varname>, <varname>&lt;</varname>,"
" <varname>&lt;=</varname>, etc.) a tipos temporales, es determinar si la "
"comparación es verdadera o falsa en cada instante. En este caso, el "
"resultado es un booleano temporal. Los operadores de comparación temporal se"
" indican anteponiendo los operadores de comparación tradicionales con "
"<varname>#</varname>. Algunos ejemplos son <varname>#=</varname> o "
"<varname>#&lt;=</varname>. La igualdad y no igualdad temporal están "
"disponibles para todos los tipos temporales, mientras que las desigualdades "
"temporales solo están disponibles para los tipos temporales cuyo tipo base "
"tiene un orden total definido, es decir, <varname>tint</varname>, "
"<varname>tfloat</varname>, o <varname>ttext</varname>."

#. Tag: varname
#: manipulating_temporal_types.xml:1102
#, no-c-format
msgid "<varname>#=</varname>"
msgstr "<varname>#=</varname>"

#. Tag: para
#: manipulating_temporal_types.xml:1103
#, no-c-format
msgid "Temporal equal"
msgstr "Igual temporal"

#. Tag: varname
#: manipulating_temporal_types.xml:1104
#, no-c-format
msgid "{base, ttype} #= {base, ttype}: tbool"
msgstr "{base, ttype} #= {base, ttype}: tbool"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1105
#, no-c-format
msgid ""
"SELECT tfloat '[1@2012-01-01, 2@2012-01-04)' #= 3;\n"
"-- \"{[f@2012-01-01, f@2012-01-04)}\"\n"
"SELECT tfloat '[1@2012-01-01, 4@2012-01-04)' #= tint '[1@2012-01-01, 1@2012-01-04)';\n"
"-- \"{[t@2012-01-01], (f@2012-01-01, f@2012-01-04)}\"\n"
"SELECT tfloat '[1@2012-01-01, 4@2012-01-04)' #= tfloat '[4@2012-01-02, 1@2012-01-05)';\n"
"-- \"{[f@2012-01-02, t@2012-01-03], (f@2012-01-03, f@2012-01-04)}\"\n"
"SELECT tgeompoint '[Point(0 0)@2012-01-01, Point(2 2)@2012-01-03)' #=\n"
"geometry 'Point(1 1)';\n"
"-- \"{[f@2012-01-01, t@2012-01-02], (f@2012-01-02, f@2012-01-03)}\"\n"
"SELECT tgeompoint '[Point(0 0)@2012-01-01, Point(2 2)@2012-01-03)' #=\n"
"tgeompoint '[Point(0 2)@2012-01-01, Point(2 0)@2012-01-03)';\n"
"-- \"{[f@2012-01-01], (t@2012-01-01, t@2012-01-03)}\""
msgstr ""
"SELECT tfloat '[1@2012-01-01, 2@2012-01-04)' #= 3;\n"
"-- \"{[f@2012-01-01, f@2012-01-04)}\"\n"
"SELECT tfloat '[1@2012-01-01, 4@2012-01-04)' #= tint '[1@2012-01-01, 1@2012-01-04)';\n"
"-- \"{[t@2012-01-01], (f@2012-01-01, f@2012-01-04)}\"\n"
"SELECT tfloat '[1@2012-01-01, 4@2012-01-04)' #= tfloat '[4@2012-01-02, 1@2012-01-05)';\n"
"-- \"{[f@2012-01-02, t@2012-01-03], (f@2012-01-03, f@2012-01-04)}\"\n"
"SELECT tgeompoint '[Point(0 0)@2012-01-01, Point(2 2)@2012-01-03)' #=\n"
"geometry 'Point(1 1)';\n"
"-- \"{[f@2012-01-01, t@2012-01-02], (f@2012-01-02, f@2012-01-03)}\"\n"
"SELECT tgeompoint '[Point(0 0)@2012-01-01, Point(2 2)@2012-01-03)' #=\n"
"tgeompoint '[Point(0 2)@2012-01-01, Point(2 0)@2012-01-03)';\n"
"-- \"{[f@2012-01-01], (t@2012-01-01, t@2012-01-03)}\""

#. Tag: varname
#: manipulating_temporal_types.xml:1109
#, no-c-format
msgid "#&lt;&gt;"
msgstr "#&lt;&gt;"

#. Tag: para
#: manipulating_temporal_types.xml:1110
#, no-c-format
msgid "Temporal different"
msgstr "Diferente temporal "

#. Tag: varname
#: manipulating_temporal_types.xml:1111
#, no-c-format
msgid "{base, ttype} #&lt;&gt; {base, ttype}: tbool"
msgstr "{base, ttype} #&lt;&gt; {base, ttype}: tbool"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1112
#, no-c-format
msgid ""
"SELECT tfloat '[1@2012-01-01, 4@2012-01-04)' #&lt;&gt; 2;\n"
"-- \"{[t@2012-01-01, f@2012-01-02], (t@2012-01-02, 2012-01-04)}\"\n"
"SELECT tfloat '[1@2012-01-01, 4@2012-01-04)' #&lt;&gt; tint '[2@2012-01-02, 2@2012-01-05)';\n"
"-- \"{[f@2012-01-02], (t@2012-01-02, t@2012-01-04)}\""
msgstr ""
"SELECT tfloat '[1@2012-01-01, 4@2012-01-04)' #&lt;&gt; 2;\n"
"-- \"{[t@2012-01-01, f@2012-01-02], (t@2012-01-02, 2012-01-04)}\"\n"
"SELECT tfloat '[1@2012-01-01, 4@2012-01-04)' #&lt;&gt; tint '[2@2012-01-02, 2@2012-01-05)';\n"
"-- \"{[f@2012-01-02], (t@2012-01-02, t@2012-01-04)}\""

#. Tag: varname
#: manipulating_temporal_types.xml:1116
#, no-c-format
msgid "#&lt;"
msgstr "#&lt;"

#. Tag: para
#: manipulating_temporal_types.xml:1117
#, no-c-format
msgid "Temporal less than"
msgstr "Menor que temporal "

#. Tag: varname
#: manipulating_temporal_types.xml:1118
#, no-c-format
msgid "{base, torder} #&lt; {base, torder}: tbool"
msgstr "{base, torder} #&lt; {base, torder}: tbool"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1119
#, no-c-format
msgid ""
"SELECT tfloat '[1@2012-01-01, 4@2012-01-04)' #&lt; 2;\n"
"-- \"{[t@2012-01-01, f@2012-01-02, f@2012-01-04)}\"\n"
"SELECT tint '[2@2012-01-01, 2@2012-01-05)' #&lt; tfloat '[1@2012-01-03, 3@2012-01-05)';\n"
"-- \"{[f@2012-01-03, f@2012-01-04], (t@2012-01-04, t@2012-01-05)}\""
msgstr ""
"SELECT tfloat '[1@2012-01-01, 4@2012-01-04)' #&lt; 2;\n"
"-- \"{[t@2012-01-01, f@2012-01-02, f@2012-01-04)}\"\n"
"SELECT tint '[2@2012-01-01, 2@2012-01-05)' #&lt; tfloat '[1@2012-01-03, 3@2012-01-05)';\n"
"-- \"{[f@2012-01-03, f@2012-01-04], (t@2012-01-04, t@2012-01-05)}\""

#. Tag: varname
#: manipulating_temporal_types.xml:1123
#, no-c-format
msgid "#&gt;"
msgstr "#&gt;"

#. Tag: para
#: manipulating_temporal_types.xml:1124
#, no-c-format
msgid "Temporal greater than"
msgstr "Mayor que temporal "

#. Tag: varname
#: manipulating_temporal_types.xml:1125
#, no-c-format
msgid "{base, torder} #&gt; {base, torder}: tbool"
msgstr "{base, torder} #&gt; {base, torder}: tbool"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1126
#, no-c-format
msgid ""
"SELECT 1 #&gt; tint '[1@2012-01-03, 1@2012-01-05)';\n"
"-- \"[f@2012-01-03, f@2012-01-05)\""
msgstr ""
"SELECT 1 #&gt; tint '[1@2012-01-03, 1@2012-01-05)';\n"
"-- \"[f@2012-01-03, f@2012-01-05)\""

#. Tag: varname
#: manipulating_temporal_types.xml:1130
#, no-c-format
msgid "#&lt;="
msgstr "#&lt;="

#. Tag: para
#: manipulating_temporal_types.xml:1131
#, no-c-format
msgid "Temporal less than or equal to"
msgstr "Menor o igual que temporal "

#. Tag: varname
#: manipulating_temporal_types.xml:1132
#, no-c-format
msgid "{base, torder} #&lt;= {base, torder}: tbool"
msgstr "{base, torder} #&lt;= {base, torder}: tbool"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1133
#, no-c-format
msgid ""
"SELECT tint '[1@2012-01-01, 1@2012-01-05)' #&lt;= tfloat '{2@2012-01-03, 3@2012-01-04}';\n"
"-- \"{t@2012-01-03, t@2012-01-04}\""
msgstr ""
"SELECT tint '[1@2012-01-01, 1@2012-01-05)' #&lt;= tfloat '{2@2012-01-03, 3@2012-01-04}';\n"
"-- \"{t@2012-01-03, t@2012-01-04}\""

#. Tag: varname
#: manipulating_temporal_types.xml:1137
#, no-c-format
msgid "#&gt;="
msgstr "#&gt;="

#. Tag: para
#: manipulating_temporal_types.xml:1138
#, no-c-format
msgid "Temporal greater than or equal to"
msgstr "Mayor o igual que temporal "

#. Tag: varname
#: manipulating_temporal_types.xml:1139
#, no-c-format
msgid "{base, torder} #&gt;= {base, torder}: tbool"
msgstr "{base, torder} #&gt;= {base, torder}: tbool"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1140
#, no-c-format
msgid ""
"SELECT 'AAA'::text #&gt; ttext '{[AAA@2012-01-01, AAA@2012-01-03),\n"
"[BBB@2012-01-04, BBB@2012-01-05)}';\n"
"-- \"{[f@2012-01-01, f@2012-01-03), [t@2012-01-04, t@2012-01-05)}\""
msgstr ""
"SELECT 'AAA'::text #&gt; ttext '{[AAA@2012-01-01, AAA@2012-01-03),\n"
"[BBB@2012-01-04, BBB@2012-01-05)}';\n"
"-- \"{[f@2012-01-01, f@2012-01-03), [t@2012-01-04, t@2012-01-05)}\""

#. Tag: title
#: manipulating_temporal_types.xml:1146
#, no-c-format
msgid "Mathematical Functions and Operators"
msgstr "Funciones y operadores matemáticos "

#. Tag: varname
#: manipulating_temporal_types.xml:1150
#, no-c-format
msgid "<varname>+</varname>"
msgstr "<varname>+</varname>"

#. Tag: para
#: manipulating_temporal_types.xml:1151
#, no-c-format
msgid "Temporal addition"
msgstr "Adición temporal"

#. Tag: varname
#: manipulating_temporal_types.xml:1152
#, no-c-format
msgid "{number, tnumber} + {number, tnumber}: tnumber"
msgstr "{number, tnumber} + {number, tnumber}: tnumber"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1153
#, no-c-format
msgid ""
"SELECT tint '[2@2012-01-01, 2@2012-01-04)' + 1.5;\n"
"-- \"[3.5@2012-01-01, 3.5@2012-01-04)\"\n"
"SELECT tint '[2@2012-01-01, 2@2012-01-04)' + tfloat '[1@2012-01-01, 4@2012-01-04)';\n"
"-- \"[3@2012-01-01, 6@2012-01-04)\"\n"
"SELECT tfloat '[1@2012-01-01, 4@2012-01-04)' +\n"
"tfloat '{[1@2012-01-01, 2@2012-01-02), [1@2012-01-02, 2@2012-01-04)}';\n"
"-- \"{[2@2012-01-01, 4@2012-01-04), [3@2012-01-02, 6@2012-01-04)}\""
msgstr ""
"SELECT tint '[2@2012-01-01, 2@2012-01-04)' + 1.5;\n"
"-- \"[3.5@2012-01-01, 3.5@2012-01-04)\"\n"
"SELECT tint '[2@2012-01-01, 2@2012-01-04)' + tfloat '[1@2012-01-01, 4@2012-01-04)';\n"
"-- \"[3@2012-01-01, 6@2012-01-04)\"\n"
"SELECT tfloat '[1@2012-01-01, 4@2012-01-04)' +\n"
"tfloat '{[1@2012-01-01, 2@2012-01-02), [1@2012-01-02, 2@2012-01-04)}';\n"
"-- \"{[2@2012-01-01, 4@2012-01-04), [3@2012-01-02, 6@2012-01-04)}\""

#. Tag: varname
#: manipulating_temporal_types.xml:1157
#, no-c-format
msgid "<varname>-</varname>"
msgstr "<varname>-</varname>"

#. Tag: para
#: manipulating_temporal_types.xml:1158
#, no-c-format
msgid "Temporal subtraction"
msgstr "Resta temporal"

#. Tag: varname
#: manipulating_temporal_types.xml:1159
#, no-c-format
msgid "{number, tnumber} - {number, tnumber}: tnumber"
msgstr "{number, tnumber} - {number, tnumber}: tnumber"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1160
#, no-c-format
msgid ""
"SELECT tint '[1@2012-01-01, 1@2012-01-04)' - tint '[2@2012-01-03, 2@2012-01-05)';\n"
"-- \"[-1@2012-01-03, -1@2012-01-04)\"\n"
"SELECT tfloat '[3@2012-01-01, 6@2012-01-04)' - tint '[2@2012-01-01, 2@2012-01-04)';\n"
"-- \"[1@2012-01-01, 4@2012-01-04)\""
msgstr ""
"SELECT tint '[1@2012-01-01, 1@2012-01-04)' - tint '[2@2012-01-03, 2@2012-01-05)';\n"
"-- \"[-1@2012-01-03, -1@2012-01-04)\"\n"
"SELECT tfloat '[3@2012-01-01, 6@2012-01-04)' - tint '[2@2012-01-01, 2@2012-01-04)';\n"
"-- \"[1@2012-01-01, 4@2012-01-04)\""

#. Tag: varname
#: manipulating_temporal_types.xml:1164
#, no-c-format
msgid "<varname>*</varname>"
msgstr "<varname>*</varname>"

#. Tag: para
#: manipulating_temporal_types.xml:1165
#, no-c-format
msgid "Temporal multiplication"
msgstr "Multiplicación temporal "

#. Tag: varname
#: manipulating_temporal_types.xml:1166
#, no-c-format
msgid "{number, tnumber} * {number, tnumber}: tnumber"
msgstr "{number, tnumber} * {number, tnumber}: tnumber"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1167
#, no-c-format
msgid ""
"SELECT tfloat '[1@2012-01-01, 4@2012-01-04)' * 2;\n"
"-- \"[2@2012-01-01, 8@2012-01-04)\"\n"
"SELECT tfloat '[1@2012-01-01, 4@2012-01-04)' * tint '[2@2012-01-01, 2@2012-01-04)';\n"
"-- \"[2@2012-01-01, 8@2012-01-04)\"\n"
"SELECT tfloat '[1@2012-01-01, 3@2012-01-03)' * '[3@2012-01-01, 1@2012-01-03)'\n"
"-- \"{[3@2012-01-01, 4@2012-01-02, 3@2012-01-03)}\""
msgstr ""
"SELECT tfloat '[1@2012-01-01, 4@2012-01-04)' * 2;\n"
"-- \"[2@2012-01-01, 8@2012-01-04)\"\n"
"SELECT tfloat '[1@2012-01-01, 4@2012-01-04)' * tint '[2@2012-01-01, 2@2012-01-04)';\n"
"-- \"[2@2012-01-01, 8@2012-01-04)\"\n"
"SELECT tfloat '[1@2012-01-01, 3@2012-01-03)' * '[3@2012-01-01, 1@2012-01-03)'\n"
"-- \"{[3@2012-01-01, 4@2012-01-02, 3@2012-01-03)}\""

#. Tag: varname
#: manipulating_temporal_types.xml:1171
#, no-c-format
msgid "<varname>/</varname>"
msgstr "<varname>/</varname>"

#. Tag: para
#: manipulating_temporal_types.xml:1172
#, no-c-format
msgid "Temporal division"
msgstr "División temporal"

#. Tag: varname
#: manipulating_temporal_types.xml:1173
#, no-c-format
msgid "{number, tnumber} / {number, tnumber}: tnumber"
msgstr "{number, tnumber} / {number, tnumber}: tnumber"

#. Tag: para
#: manipulating_temporal_types.xml:1174
#, no-c-format
msgid ""
"The function will raise an error if the denominator will ever be equal to "
"zero during the common timespan of the arguments."
msgstr ""
"La función genera un error si el denominador es alguna igual a cero durante "
"el intervalo de tiempo común de los argumentos."

#. Tag: programlisting
#: manipulating_temporal_types.xml:1175
#, no-c-format
msgid ""
"SELECT 2 / tfloat '[1@2012-01-01, 3@2012-01-04)';\n"
"-- \"[2@2012-01-01, 1@2012-01-02 12:00:00+00, 0.666666666666667@2012-01-04)\"\n"
"SELECT tfloat '[1@2012-01-01, 5@2012-01-05)' / '[5@2012-01-01, 1@2012-01-05)'\n"
"-- \"{[0.2@2012-01-01, 1@2012-01-03,2012-01-03, 5@2012-01-03,2012-01-05)}\"\n"
"select 2 / tfloat '[-1@2000-01-01, 1@2000-01-02]'\n"
"-- ERROR:  Division by zero\n"
"select tfloat '[-1@2000-01-04, 1@2000-01-05]' / tfloat '[-1@2000-01-01, 1@2000-01-05]'\n"
"-- \"[-2@2000-01-04, 1@2000-01-05]\""
msgstr ""
"SELECT 2 / tfloat '[1@2012-01-01, 3@2012-01-04)';\n"
"-- \"[2@2012-01-01, 1@2012-01-02 12:00:00+00, 0.666666666666667@2012-01-04)\"\n"
"SELECT tfloat '[1@2012-01-01, 5@2012-01-05)' / '[5@2012-01-01, 1@2012-01-05)'\n"
"-- \"{[0.2@2012-01-01, 1@2012-01-03,2012-01-03, 5@2012-01-03,2012-01-05)}\"\n"
"select 2 / tfloat '[-1@2000-01-01, 1@2000-01-02]'\n"
"-- ERROR:  Division by zero\n"
"select tfloat '[-1@2000-01-04, 1@2000-01-05]' / tfloat '[-1@2000-01-01, 1@2000-01-05]'\n"
"-- \"[-2@2000-01-04, 1@2000-01-05]\""

#. Tag: varname
#: manipulating_temporal_types.xml:1179
#, no-c-format
msgid "round"
msgstr "round"

#. Tag: para
#: manipulating_temporal_types.xml:1180
#, no-c-format
msgid "Round to n decimal places"
msgstr "Redondear a n posiciones decimales "

#. Tag: varname
#: manipulating_temporal_types.xml:1181
#, no-c-format
msgid "round(tfloat, integer): tfloat"
msgstr "round(tfloat, integer): tfloat"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1182
#, no-c-format
msgid ""
"SELECT round(tfloat '[0.785398163397448@2000-01-01, 2.35619449019234@2000-01-02]', 2);\n"
"-- \"[0.79@2000-01-01, 2.36@2000-01-02]\""
msgstr ""
"SELECT round(tfloat '[0.785398163397448@2000-01-01, 2.35619449019234@2000-01-02]', 2);\n"
"-- \"[0.79@2000-01-01, 2.36@2000-01-02]\""

#. Tag: varname
#: manipulating_temporal_types.xml:1186
#, no-c-format
msgid "degrees"
msgstr "degrees"

#. Tag: para
#: manipulating_temporal_types.xml:1187
#, no-c-format
msgid "Convert from radians to degrees"
msgstr "Convertir de radianes a grados"

#. Tag: varname
#: manipulating_temporal_types.xml:1188
#, no-c-format
msgid "degrees(tfloat): tfloat"
msgstr "degrees(tfloat): tfloat"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1189
#, no-c-format
msgid ""
"SELECT degrees(tfloat '[0.785398163397448@2000-01-01, 2.35619449019234@2000-01-02]');\n"
"-- \"[45@2000-01-01, 135@2000-01-02]\""
msgstr ""
"SELECT degrees(tfloat '[0.785398163397448@2000-01-01, 2.35619449019234@2000-01-02]');\n"
"-- \"[45@2000-01-01, 135@2000-01-02]\""

#. Tag: title
#: manipulating_temporal_types.xml:1195
#, no-c-format
msgid "Boolean Operators"
msgstr "Operadores booleanos"

#. Tag: varname
#: manipulating_temporal_types.xml:1198
#, no-c-format
msgid "&amp;"
msgstr "&amp;"

#. Tag: para
#: manipulating_temporal_types.xml:1199 manipulating_temporal_types.xml:1534
#, no-c-format
msgid "Temporal and"
msgstr "Y temporal"

#. Tag: varname
#: manipulating_temporal_types.xml:1200
#, no-c-format
msgid "{bool, tbool} &amp; {bool, tbool}: tbool"
msgstr "{bool, tbool} &amp; {bool, tbool}: tbool"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1201
#, no-c-format
msgid ""
"SELECT tbool '[true@2012-01-03, true@2012-01-05)' &amp;\n"
"tbool '[false@2012-01-03, false@2012-01-05)';\n"
"-- \"[f@2012-01-03, f@2012-01-05)\"\n"
"SELECT tbool '[true@2012-01-03, true@2012-01-05)' &amp;\n"
"tbool '{[false@2012-01-03, false@2012-01-04),\n"
"[true@2012-01-04, true@2012-01-05)}';\n"
"-- \"{[f@2012-01-03, t@2012-01-04, t@2012-01-05)}\""
msgstr ""
"SELECT tbool '[true@2012-01-03, true@2012-01-05)' &amp;\n"
"tbool '[false@2012-01-03, false@2012-01-05)';\n"
"-- \"[f@2012-01-03, f@2012-01-05)\"\n"
"SELECT tbool '[true@2012-01-03, true@2012-01-05)' &amp;\n"
"tbool '{[false@2012-01-03, false@2012-01-04),\n"
"[true@2012-01-04, true@2012-01-05)}';\n"
"-- \"{[f@2012-01-03, t@2012-01-04, t@2012-01-05)}\""

#. Tag: varname
#: manipulating_temporal_types.xml:1205
#, no-c-format
msgid "<varname>|</varname>"
msgstr "<varname>|</varname>"

#. Tag: para
#: manipulating_temporal_types.xml:1206 manipulating_temporal_types.xml:1541
#, no-c-format
msgid "Temporal or"
msgstr "O temporal"

#. Tag: varname
#: manipulating_temporal_types.xml:1207
#, no-c-format
msgid "{bool, tbool} | {bool, tbool}: tbool"
msgstr "{bool, tbool} | {bool, tbool}: tbool"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1208
#, no-c-format
msgid ""
"SELECT tbool '[true@2012-01-03, true@2012-01-05)' |\n"
"tbool '[false@2012-01-03, false@2012-01-05)';\n"
"-- \"[t@2012-01-03, t@2012-01-05)\""
msgstr ""
"SELECT tbool '[true@2012-01-03, true@2012-01-05)' |\n"
"tbool '[false@2012-01-03, false@2012-01-05)';\n"
"-- \"[t@2012-01-03, t@2012-01-05)\""

#. Tag: varname
#: manipulating_temporal_types.xml:1212
#, no-c-format
msgid "<varname>~</varname>"
msgstr "<varname>~</varname>"

#. Tag: para
#: manipulating_temporal_types.xml:1213
#, no-c-format
msgid "Temporal not"
msgstr "No temporal"

#. Tag: varname
#: manipulating_temporal_types.xml:1214
#, no-c-format
msgid "~ tbool: tbool"
msgstr "~ tbool: tbool"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1215
#, no-c-format
msgid ""
"SELECT ~ tbool '[true@2012-01-03, true@2012-01-05)';\n"
"-- \"[f@2012-01-03, f@2012-01-05)\""
msgstr ""
"SELECT ~ tbool '[true@2012-01-03, true@2012-01-05)';\n"
"-- \"[f@2012-01-03, f@2012-01-05)\""

#. Tag: title
#: manipulating_temporal_types.xml:1221
#, no-c-format
msgid "Text Functions and Operators"
msgstr "Funciones y operadores de texto"

#. Tag: varname
#: manipulating_temporal_types.xml:1225
#, no-c-format
msgid "<varname>||</varname>"
msgstr "<varname>||</varname>"

#. Tag: para
#: manipulating_temporal_types.xml:1226
#, no-c-format
msgid "Temporal text concatenation"
msgstr "Concatenación de texto temporal"

#. Tag: varname
#: manipulating_temporal_types.xml:1227
#, no-c-format
msgid "{text, ttext} || {text, ttext}: ttext"
msgstr "{text, ttext} || {text, ttext}: ttext"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1228
#, no-c-format
msgid ""
"SELECT ttext '[AA@2012-01-01, AA@2012-01-04)' || text 'B';\n"
"-- \"[\"AAB\"@2012-01-01, \"AAB\"@2012-01-04)\"\n"
"SELECT ttext '[AA@2012-01-01, AA@2012-01-04)' || ttext '[BB@2012-01-02, BB@2012-01-05)';\n"
"-- \"[\"AABB\"@2012-01-02, \"AABB\"@2012-01-04)\"\n"
"SELECT ttext '[A@2012-01-01, B@2012-01-03, C@2012-01-04]' ||\n"
"ttext '{[D@2012-01-01, D@2012-01-02), [E@2012-01-02, E@2012-01-04)}';\n"
"-- \"{[\"DA\"@2012-01-01, \"EA\"@2012-01-02, \"EB\"@2012-01-03, \"EB\"@2012-01-04)}\""
msgstr ""
"SELECT ttext '[AA@2012-01-01, AA@2012-01-04)' || text 'B';\n"
"-- \"[\"AAB\"@2012-01-01, \"AAB\"@2012-01-04)\"\n"
"SELECT ttext '[AA@2012-01-01, AA@2012-01-04)' || ttext '[BB@2012-01-02, BB@2012-01-05)';\n"
"-- \"[\"AABB\"@2012-01-02, \"AABB\"@2012-01-04)\"\n"
"SELECT ttext '[A@2012-01-01, B@2012-01-03, C@2012-01-04]' ||\n"
"ttext '{[D@2012-01-01, D@2012-01-02), [E@2012-01-02, E@2012-01-04)}';\n"
"-- \"{[\"DA\"@2012-01-01, \"EA\"@2012-01-02, \"EB\"@2012-01-03, \"EB\"@2012-01-04)}\""

#. Tag: varname
#: manipulating_temporal_types.xml:1232
#, no-c-format
msgid "upper"
msgstr "upper"

#. Tag: para
#: manipulating_temporal_types.xml:1233
#, no-c-format
msgid "Transform to uppercase"
msgstr "Transformar a mayúsculas"

#. Tag: varname
#: manipulating_temporal_types.xml:1234
#, no-c-format
msgid "upper(ttext): ttext"
msgstr "upper(ttext): ttext"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1235
#, no-c-format
msgid ""
"SELECT upper(ttext '[AA@2000-01-01, bb@2000-01-02]');\n"
"-- \"[\"AA\"@2000-01-01, \"BB\"@2000-01-02]\""
msgstr ""
"SELECT upper(ttext '[AA@2000-01-01, bb@2000-01-02]');\n"
"-- \"[\"AA\"@2000-01-01, \"BB\"@2000-01-02]\""

#. Tag: varname
#: manipulating_temporal_types.xml:1239
#, no-c-format
msgid "lower"
msgstr "lower"

#. Tag: para
#: manipulating_temporal_types.xml:1240
#, no-c-format
msgid "Transform to lowercase"
msgstr "Transformar a minúsculas"

#. Tag: varname
#: manipulating_temporal_types.xml:1241
#, no-c-format
msgid "lower(ttext): ttext"
msgstr "lower(ttext): ttext"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1242
#, no-c-format
msgid ""
"SELECT lower(ttext '[AA@2000-01-01, bb@2000-01-02]');\n"
"-- \"[\"aa\"@2000-01-01, \"bb\"@2000-01-02]\""
msgstr ""
"SELECT lower(ttext '[AA@2000-01-01, bb@2000-01-02]');\n"
"-- \"[\"aa\"@2000-01-01, \"bb\"@2000-01-02]\""

#. Tag: title
#: manipulating_temporal_types.xml:1248
#, no-c-format
msgid "Bounding Box Operators"
msgstr "Operadores de cuadro delimitador"

#. Tag: para
#: manipulating_temporal_types.xml:1249
#, no-c-format
msgid ""
"These operators test whether the bounding boxes of their arguments satisfy "
"the predicate and result in a Boolean value. As stated in <xref "
"linkend=\"temporal_types\"/>, the bounding box associated to a temporal type"
" depends on the base type: It is the <varname>period</varname> type for the "
"<varname>tbool</varname> and <varname>ttext</varname> types, the "
"<varname>tbox</varname> type for the <varname>tint</varname> and "
"<varname>tfloat</varname> types, and the <varname>stbox</varname> type for "
"the <varname>tgeompoint</varname> and <varname>tgeogpoint</varname> types. "
"Furthermore, as seen in <xref linkend=\"casting_box_types\"/>, many "
"PostgreSQL, PostGIS, or MobilityDB types can be cast to the "
"<varname>tbox</varname> and <varname>stbox</varname> types. For example, "
"numeric values and ranges can be casted to <varname>tbox</varname>, "
"<varname>geometry</varname> and <varname>geography</varname> values can be "
"casted to <varname>stbox</varname>, and time types and temporal types can be"
" cast to <varname>tbox</varname> and <varname>stbox</varname> types."
msgstr ""
"Estos operadores prueban si los cuadros delimitadores de sus argumentos "
"satisfacen el predicado y dan como resultado un valor booleano. Como se "
"indica en <xref linkend=\"temporal_types\"/>, el cuadro delimitador asociado"
" a un tipo temporal depende del tipo base: es el tipo "
"<varname>period</varname> para los tipos <varname>tbool</varname> y "
"<varname>ttext</varname>, el tipo <varname>tbox</varname> para los tipos "
"<varname>tint</varname> y <varname>tfloat</varname>, y el tipo "
"<varname>stbox</varname> para los tipos <varname>tgeompoint</varname> "
"y<varname>tgeogpoint</varname>. Además, como se dijo en <xref "
"linkend=\"casting_box_types\"/>, muchos tipos PostgreSQL, PostGIS o "
"MobilityDB se pueden convertir a los tipos <varname>tbox</varname> "
"y<varname>stbox</varname>. Por ejemplo, los valores numéricos y los rangos "
"se pueden convertir a <varname>tbox</varname>,  valores de "
"<varname>geometry</varname> y <varname>geography</varname> se pueden "
"convertir a <varname>stbox</varname>, y los tipos de tiempo y tipos "
"temporales se pueden convertir a los tipos <varname>tbox</varname> and "
"<varname>stbox</varname>."

#. Tag: para
#: manipulating_temporal_types.xml:1252
#, no-c-format
msgid ""
"A first set of operators consider the topological relationships between the "
"bounding boxes. There are five topological operators: overlaps "
"(<varname>&amp;&amp;</varname>), contains (<varname>@&gt;</varname>), "
"contained (<varname>&lt;@</varname>), same (<varname>~=</varname>), and "
"adjacent (<varname>-|-</varname>). The arguments of these operators can be a"
" base type, a box, or a temporal type and the operators verify the "
"topological relationship taking into account the value and/or the time "
"dimension depending on the type of the arguments."
msgstr ""
"Un primer conjunto de operadores considera las relaciones topológicas entre "
"los cuadros delimitadores. Hay cinco operadores topológicos: superposicion "
"(<varname>&amp;&amp;</varname>), contiene (<varname>@&gt;</varname>), es "
"contenido (<varname>&lt;@</varname>), mismo (<varname>~=</varname>), y "
"adyacente (<varname>-|-</varname>). Los argumentos de estos operadores "
"pueden ser un tipo base, una cuadro delimitador o un tipo temporal y los "
"operadores verifican la relación topológica teniendo en cuenta el valor y/o "
"la dimensión temporal según el tipo de los argumentos."

#. Tag: para
#: manipulating_temporal_types.xml:1254
#, no-c-format
msgid ""
"Another set of operators consider the relative position of the bounding "
"boxes. The operators <varname>&lt;&lt;</varname>, "
"<varname>&gt;&gt;</varname>, <varname>&amp;&lt;</varname>, and "
"<varname>&amp;&gt;</varname> consider the value dimension for "
"<varname>tint</varname> and <varname>tfloat</varname> types and the X "
"coordinates for the <varname>tgeompoint</varname> and "
"<varname>tgeogpoint</varname> types, the operators "
"<varname>&lt;&lt;|</varname>, <varname>|&gt;&gt;</varname>, "
"<varname>&amp;&lt;|</varname>, and <varname>|&amp;&gt;</varname> consider "
"the Y coordinates for the <varname>tgeompoint</varname> and "
"<varname>tgeogpoint</varname> types, the operators "
"<varname>&lt;&lt;/</varname>, <varname>/&gt;&gt;</varname>, "
"<varname>&amp;&lt;/</varname>, and <varname>/&amp;&gt;</varname> consider "
"the Z coordinates for the <varname>tgeompoint</varname> and "
"<varname>tgeogpoint</varname> types, and the operators "
"<varname>&lt;&lt;#</varname>, <varname>#&gt;&gt;</varname>, "
"<varname>#&amp;&lt;</varname>, and <varname>#&amp;&gt;</varname> consider "
"the time dimension for all temporal types."
msgstr ""
"Otro conjunto de operadores considera la posición relativa de los cuadros "
"delimitadores. Los operadores <varname>&lt;&lt;</varname>, "
"<varname>&gt;&gt;</varname>, <varname>&amp;&lt;</varname>, y "
"<varname>&amp;&gt;</varname> consideran la dimensión de valor para los tipos"
" <varname>tint</varname> and <varname>tfloat</varname> y las coordenadas X "
"para los tipos <varname>tgeompoint</varname> y "
"<varname>tgeogpoint</varname>, los operadores <varname>&lt;&lt;|</varname>, "
"<varname>|&gt;&gt;</varname>, <varname>&amp;&lt;|</varname>, y "
"<varname>|&amp;&gt;</varname> consideran las coordenadas Y para los tipos "
"<varname>tgeompoint</varname> y <varname>tgeogpoint</varname>, los "
"operadores <varname>&lt;&lt;/</varname>, <varname>/&gt;&gt;</varname>, "
"<varname>&amp;&lt;/</varname>, y <varname>/&amp;&gt;</varname> consideran "
"las coordenadas Z para los tipos <varname>tgeompoint</varname> y "
"<varname>tgeogpoint</varname>, y los operadores "
"<varname>&lt;&lt;#</varname>, <varname>#&gt;&gt;</varname>, "
"<varname>#&amp;&lt;</varname>, y <varname>#&amp;&gt;</varname> consideran la"
" dimensión tiempo para todos los tipos temporales."

#. Tag: para
#: manipulating_temporal_types.xml:1256
#, no-c-format
msgid ""
"We refer to <xref linkend=\"box_topo_operators\"/> and <xref "
"linkend=\"box_relpos_operators\"/> for the bounding box operators."
msgstr ""
"Refiérase a <xref linkend=\"box_topo_operators\"/> y <xref "
"linkend=\"box_relpos_operators\"/> para los operadores de cuadro "
"delimitador."

#. Tag: title
#: manipulating_temporal_types.xml:1260
#, no-c-format
msgid "Distance Operators"
msgstr "Operadores de distancia"

#. Tag: para
#: manipulating_temporal_types.xml:1261
#, no-c-format
msgid ""
"There are two distance operators. The first one computes the distance "
"between either a temporal point and a geometry or between two temporal "
"points at their nearest point of approach, which is a float. This is the "
"same as the function <varname>nearestApproachDistance</varname> discussed "
"before but as an operator it can be used for doing nearest neightbor "
"searches using a GiST index (see <xref "
"linkend=\"indexing_temporal_types\"/>)."
msgstr ""
"Hay dos operadores de distancia. El primero calcula la distancia entre un "
"punto temporal y una geometría o entre dos puntos temporales en su punto de "
"aproximación más cercano, que es un número flotante. Esto es lo mismo que la"
" función<varname>nearestApproachDistance</varname> discutido antes, pero "
"como operador se puede utilizar para realizar una búsqueda de vecino más "
"cercano utilizando un índice GiST (ver <xref "
"linkend=\"indexing_temporal_types\"/>)."

#. Tag: para
#: manipulating_temporal_types.xml:1263
#, no-c-format
msgid ""
"On the other hand, the temporal distance operator computes the distance at "
"each instant of the intersection of the temporal extents of their arguments "
"and results in a temporal float. Computing temporal distance is useful in "
"many mobility applications. For example, a moving cluster (also known as "
"convoy or flock) is defined as a set of objects that move close to each "
"other for a long time interval. This requires to compute temporal distance "
"between two moving objects."
msgstr ""
"Por otro lado, el operador de distancia temporal calcula la distancia en "
"cada instante de la intersección de las extensiones temporales de sus "
"argumentos y da como resultado un número flotante temporal. Calcular la "
"distancia temporal es útil en muchas aplicaciones de movilidad. Por ejemplo,"
" un grupo en movimiento (también conocido como convoy o bandada) se define "
"como un conjunto de objetos que se mueven cerca unos de otros durante un "
"intervalo de tiempo prolongado. Esto requiere calcular la distancia temporal"
" entre dos objetos en movimiento."

#. Tag: para
#: manipulating_temporal_types.xml:1265
#, no-c-format
msgid ""
"The temporal distance operator accepts a geometry/geography restricted to a "
"point or a temporal point as arguments. Notice that the temporal types only "
"consider linear interpolation between values, while the distance is a root "
"of a quadratic function. Therefore, the temporal distance operator gives a "
"linear approximation of the actual distance value for temporal sequence "
"points. In this case, the arguments are synchronized in the time dimension, "
"and for each of the composing line segments of the arguments, the spatial "
"distance between the start point, the end point, and the nearest point of "
"approach is computed, as shown in the examples below."
msgstr ""
"El operador de distancia temporal acepta una geometría/geografía restringida"
" a un punto o un punto temporal como argumentos. Observe que los tipos "
"temporales solo consideran la interpolación lineal entre valores, mientras "
"que la distancia es una raíz de una función cuadrática. Por lo tanto, el "
"operador de distancia temporal proporciona una aproximación lineal del valor"
" de distancia real para los puntos de secuencia temporal. En este caso, los "
"argumentos se sincronizan en la dimensión de tiempo, y para cada uno de los "
"segmentos de línea que componen los argumentos, se calcula la distancia "
"espacial entre el punto inicial, el punto final y el punto de aproximación "
"más cercano, como se muestra en la ejemplos a continuación."

#. Tag: varname
#: manipulating_temporal_types.xml:1269
#, no-c-format
msgid "<varname>|=|</varname>"
msgstr "<varname>|=|</varname>"

#. Tag: varname
#: manipulating_temporal_types.xml:1271
#, no-c-format
msgid "{geometry, tgeompoint} |=| {geometry, tgeompoint}: float"
msgstr "{geometry, tgeompoint} |=| {geometry, tgeompoint}: float"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1272
#, no-c-format
msgid ""
"SELECT tgeompoint '[Point(0 0)@2012-01-02, Point(1 1)@2012-01-04, Point(0 0)@2012-01-06)'\n"
"|=| geometry 'Linestring(2 2,2 1,3 1)';\n"
"-- \"1\"\n"
"SELECT tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03, Point(0 0)@2012-01-05)'\n"
"|=| tgeompoint '[Point(2 0)@2012-01-02, Point(1 1)@2012-01-04, Point(2 2)@2012-01-06)';\n"
"-- \"0.5\""
msgstr ""
"SELECT tgeompoint '[Point(0 0)@2012-01-02, Point(1 1)@2012-01-04, Point(0 0)@2012-01-06)'\n"
"|=| geometry 'Linestring(2 2,2 1,3 1)';\n"
"-- \"1\"\n"
"SELECT tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03, Point(0 0)@2012-01-05)'\n"
"|=| tgeompoint '[Point(2 0)@2012-01-02, Point(1 1)@2012-01-04, Point(2 2)@2012-01-06)';\n"
"-- \"0.5\""

#. Tag: varname
#: manipulating_temporal_types.xml:1276
#, no-c-format
msgid "&lt;-&gt;"
msgstr "&lt;-&gt;"

#. Tag: para
#: manipulating_temporal_types.xml:1277
#, no-c-format
msgid "Get the temporal distance &Z_support; &geography_support;"
msgstr "Obtener la distancia temporal &Z_support; &geography_support;"

#. Tag: varname
#: manipulating_temporal_types.xml:1278
#, no-c-format
msgid "{point, tpoint} &lt;-&gt; {point, tpoint}: tfloat"
msgstr "{point, tpoint} &lt;-&gt; {point, tpoint}: tfloat"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1279
#, no-c-format
msgid ""
"SELECT tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)' &lt;-&gt;\n"
"geometry 'Point(0 1)';\n"
"-- \"[1@2012-01-01, 0.707106781186548@2012-01-02, 1@2012-01-03)\"\n"
"SELECT tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)' &lt;-&gt;\n"
"tgeompoint '[Point(0 1)@2012-01-01, Point(1 0)@2012-01-03)';\n"
"-- \"[1@2012-01-01, 0@2012-01-02, 1@2012-01-03)\"\n"
"SELECT tgeompoint '[Point(0 1)@2012-01-01, Point(0 0)@2012-01-03)' &lt;-&gt;\n"
"tgeompoint '[Point(0 0)@2012-01-01, Point(1 0)@2012-01-03)';\n"
"-- \"[1@2012-01-01, 0.707106781186548@2012-01-02, 1@2012-01-03)\"\n"
"SELECT tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-02)' &lt;-&gt;\n"
"tgeompoint '[Point(0 1)@2012-01-01, Point(1 2)@2012-01-02)';\n"
"-- \"[1@2012-01-01,1@2012-01-02)\""
msgstr ""
"SELECT tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)' &lt;-&gt;\n"
"geometry 'Point(0 1)';\n"
"-- \"[1@2012-01-01, 0.707106781186548@2012-01-02, 1@2012-01-03)\"\n"
"SELECT tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)' &lt;-&gt;\n"
"tgeompoint '[Point(0 1)@2012-01-01, Point(1 0)@2012-01-03)';\n"
"-- \"[1@2012-01-01, 0@2012-01-02, 1@2012-01-03)\"\n"
"SELECT tgeompoint '[Point(0 1)@2012-01-01, Point(0 0)@2012-01-03)' &lt;-&gt;\n"
"tgeompoint '[Point(0 0)@2012-01-01, Point(1 0)@2012-01-03)';\n"
"-- \"[1@2012-01-01, 0.707106781186548@2012-01-02, 1@2012-01-03)\"\n"
"SELECT tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-02)' &lt;-&gt;\n"
"tgeompoint '[Point(0 1)@2012-01-01, Point(1 2)@2012-01-02)';\n"
"-- \"[1@2012-01-01,1@2012-01-02)\""

#. Tag: title
#: manipulating_temporal_types.xml:1285
#, no-c-format
msgid "Topological Relationships for Temporal Points"
msgstr "Relaciones topológicas para puntos temporales"

#. Tag: para
#: manipulating_temporal_types.xml:1287
#, no-c-format
msgid ""
"The topological relationships such as <varname>ST_Intersects</varname> and "
"<varname>ST_Relate</varname> can be generalized for temporal points. The "
"arguments of these generalized functions are either a temporal point or a "
"base type (that is, a geometry or a geography), but these functions do not "
"allow a base type in both arguments. Furthermore, both arguments must be of "
"the same base type, that is, these functions do not allow to have a temporal"
" geometry point (or a geometry) and a temporal geography point (or a "
"geography) as arguments."
msgstr ""
"Las relaciones topológicas como <varname>ST_Intersects</varname> y "
"<varname>ST_Relate</varname> pueden ser generalizadas a los puntos "
"temporales. Los argumentos de estas funciones generalizadas son un punto "
"temporal o un tipo base (es decir, una geometría o una geografía), pero "
"estas funciones no permiten un tipo base en ambos argumentos. Además, ambos "
"argumentos deben ser del mismo tipo base, es decir, estas funciones no "
"permiten tener un punto de geometría temporal (o una geometría) y un punto "
"de geografía temporal (o una geografía) como argumentos."

#. Tag: para
#: manipulating_temporal_types.xml:1289
#, no-c-format
msgid "There are two versions of the temporal topological relationships:"
msgstr "Hay dos versiones de las relaciones topológicas temporales:"

#. Tag: para
#: manipulating_temporal_types.xml:1292
#, no-c-format
msgid ""
"The first version applies the traditional topological function to the union "
"of all values taken by the temporal point (which is a "
"<varname>geometry</varname> or <varname>geography</varname>) and returns a "
"<varname>boolean</varname> or a <varname>text</varname>. Examples are the "
"<varname>intersects</varname> and <varname>relate</varname> functions."
msgstr ""
"La primera versión aplica la función topológica tradicional a la unión de "
"todos los valores tomados por el punto temporal (que es una "
"<varname>geometry</varname> or <varname>geography</varname>) y resulta en un"
" <varname>boolean</varname> o un <varname>text</varname>. Ejemplos son las "
"funciones <varname>intersects</varname> y <varname>relate</varname>."

#. Tag: para
#: manipulating_temporal_types.xml:1296
#, no-c-format
msgid ""
"The second version is defined with the temporal semantics, that is, the "
"traditional topological function is computed at each instant and results in "
"a <varname>tbool</varname> or a <varname>ttext</varname>. Examples are the "
"<varname>tintersects</varname> and <varname>trelate</varname> functions."
msgstr ""
"La segunda versión se define con la semántica temporal, es decir, la función"
" topológica tradicional se calcula en cada instante y da como resultado un "
"<varname>tbool</varname> o un<varname>ttext</varname>. Ejemplos son las "
"funciones <varname>tintersects</varname> y  <varname>trelate</varname>."

#. Tag: para
#: manipulating_temporal_types.xml:1300
#, no-c-format
msgid ""
"All spatial relationships in the two versions are defined for temporal "
"geometry points, while only four of them are defined for temporal geography "
"points, namely, <varname>covers</varname>, <varname>coveredby</varname>, "
"<varname>intersects</varname>, and <varname>dwithin</varname>, and the "
"corresponding temporal versions."
msgstr ""
"Todas las relaciones espaciales en las dos versiones están definidas para "
"puntos de geometría temporal, mientras que solo cuatro de ellas están "
"definidas para puntos de geografía temporal, a saber, "
"<varname>covers</varname>, <varname>coveredby</varname>, "
"<varname>intersects</varname>, y<varname>dwithin</varname>, y las "
"correspondientes versiones temporales."

#. Tag: para
#: manipulating_temporal_types.xml:1302
#, no-c-format
msgid ""
"The semantics conveyed by the first version of the relationships varies depending on the relationship and the type of the arguments. For example, the following query <programlisting>\n"
"SELECT intersects(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',\n"
"tgeompoint '[Point(0 1)@2012-01-01, Point(1 1)@2012-01-03)');\n"
"                        </programlisting> tests whether the temporal point ever intersected the geometry, since the query is conceptually equivalent to the following one. <programlisting>\n"
"SELECT ST_Intersects(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',\n"
"geometry 'Linestring(0 1,1 1)');\n"
"                        </programlisting> where the second geometry is obtained by applying the <varname>trajectory</varname> function to the temporal point. On the other hand, the query <programlisting>\n"
"SELECT contains(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',\n"
"tgeompoint '[Point(0 1)@2012-01-01, Point(1 1)@2012-01-03)');\n"
"                        </programlisting> tests whether the geometry always contains the temporal point. Finally, the following query <programlisting>\n"
"SELECT intersects(tgeompoint '[Point(0 1)@2012-01-01, Point(1 0)@2012-01-03)',\n"
"tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)');\n"
"                        </programlisting> tests whether the temporal points may intersect, since the query above is conceptually equivalent to the following one"
msgstr ""
"La semántica de la primera versión de las relaciones varía según la relación y el tipo de argumentos. Por ejemplo, la siguiente consulta<programlisting>\n"
"SELECT intersects(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',\n"
"tgeompoint '[Point(0 1)@2012-01-01, Point(1 1)@2012-01-03)');\n"
"                        </programlisting> comprueba si el punto temporal se cruzó alguna vez con la geometría, ya que la consulta es conceptualmente equivalente a la siguiente.<programlisting>\n"
"SELECT ST_Intersects(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',\n"
"geometry 'Linestring(0 1,1 1)');\n"
"                        </programlisting> donde la segunda geometría se obtiene aplicando la función <varname>trajectory</varname> al punto temporal. Por otro lado, la consulta <programlisting>\n"
"SELECT contains(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',\n"
"tgeompoint '[Point(0 1)@2012-01-01, Point(1 1)@2012-01-03)');\n"
"                        </programlisting> comprueba si la geometría siempre contiene el punto temporal. Finalmente, la siguiente consulta\n"
"SELECT intersects(tgeompoint '[Point(0 1)@2012-01-01, Point(1 0)@2012-01-03)',\n"
"tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)');\n"
"                        </programlisting> prueba si los puntos temporales pueden cruzarse, ya que la consulta anterior es conceptualmente equivalente a la siguiente"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1311
#, no-c-format
msgid "SELECT ST_Intersects('Linestring(0 1,1 0)', 'Linestring(0 0,1 1)');"
msgstr "SELECT ST_Intersects('Linestring(0 1,1 0)', 'Linestring(0 0,1 1)');"

#. Tag: para
#: manipulating_temporal_types.xml:1314
#, no-c-format
msgid ""
"The first versions of the relationships are typically used in combination with a spatio-temporal index when computing the temporal relationships. For example, the following query <programlisting>\n"
"SELECT T.TripId, R.RegionId, tintersects(T.Trip, R.Geom)\n"
"FROM Trips T, Regions R\n"
"WHERE intersects(T.Trip, R.Geom)\n"
"                        </programlisting> which verifies whether a trip <varname>T</varname> (which is a temporal point) intersects a region <varname>R</varname> (which is a geometry), will benefit rom a spatio-temporal index on the column <varname>T.Trip</varname> since the <varname>intersects</varname> function will automatically perform the bounding box comparison <varname>T.Trip &amp;&amp; R.Geom</varname>. This is further explained later in this document."
msgstr ""
"Las primeras versiones de las relaciones se utilizan normalmente en combinación con un índice espacio-temporal al calcular las relaciones temporales. Por ejemplo, la siguiente consulta <programlisting>\n"
"SELECT T.TripId, R.RegionId, tintersects(T.Trip, R.Geom)\n"
"FROM Trips T, Regions R\n"
"WHERE intersects(T.Trip, R.Geom)\n"
"                        </programlisting> que verifica si un viaje <varname>T</varname> (que es un punto temporal) se cruza con una región <varname>R</varname> (que es una geometría), se beneficiará de un índice espacio-temporal en la columna <varname>T.Trip</varname> dado que la función <varname>intersects</varname> realiza automáticamente la comparación del cuadro delimitador<varname>T.Trip &amp;&amp; R.Geom</varname>. Esto se explica más adelante en este documento."

#. Tag: para
#: manipulating_temporal_types.xml:1319
#, no-c-format
msgid ""
"Three topological relationships available in PostGIS are not provided in the"
" temporal version."
msgstr ""
"Tres relaciones topológicas disponibles en PostGIS no se proporcionan en la "
"versión temporal."

#. Tag: para
#: manipulating_temporal_types.xml:1322
#, no-c-format
msgid ""
"<varname>tcontainsproperly</varname> since it would always be equal to "
"<varname>tcontains</varname>: <varname>ST_Contains</varname> returns true if"
" and only if no points of B lie in the exterior of A, and at least one point"
" of the interior of B lies in the interior of A. "
"<varname>ST_ContainsProperly</varname> returns true if B intersects the "
"interior of A but not the boundary (or exterior)."
msgstr ""
"<varname>tcontainsproperly</varname> ya que siempre sería igual a "
"<varname>tcontains</varname>: <varname>ST_Contains</varname> devuelve "
"verdadero si y solo si ningún punto de B se encuentra en el exterior de A, y"
" al menos un punto del interior de B se encuentra en el interior de A. "
"<varname>ST_ContainsProperly</varname> devuelve verdadero si B cruza el "
"interior de A pero no el límite (o exterior)."

#. Tag: para
#: manipulating_temporal_types.xml:1326
#, no-c-format
msgid ""
"<varname>tcrosses</varname> since it would always returns false: "
"<varname>ST_Crosses</varname> returns true if the supplied geometries have "
"some, but not all, interior points in common."
msgstr ""
"<varname>tcrosses</varname> ya que siempre devolvería "
"falso:<varname>ST_Crosses</varname> devuelve verdadero si las geometrías "
"tienen algunos puntos interiores en común, pero no todos."

#. Tag: para
#: manipulating_temporal_types.xml:1330
#, no-c-format
msgid ""
"<varname>toverlaps</varname> since it would always returns false: "
"<varname>ST_Overlaps</varname> returns true if the geometries share space, "
"are of the same dimension, but are not completely contained by each other."
msgstr ""
"<varname>toverlaps</varname> ya que siempre devolvería "
"falso:<varname>ST_Overlaps</varname> devuelve verdadero si las geometrías "
"comparten espacio, son de la misma dimensión, pero no están completamente "
"contenidas entre sí."

#. Tag: para
#: manipulating_temporal_types.xml:1335
#, no-c-format
msgid ""
"Similarly, only a few temporal topological relationships are meaningful when"
" the two arguments are temporal points. Therefore, the relationships "
"supported for two temporal geometry points are <varname>tdisjoint</varname>,"
" <varname>tequals</varname>, <varname>tintersects</varname>, "
"<varname>tdwithin</varname>, and <varname>trelate</varname> (with 2 and 3 "
"arguments), while only <varname>tintersects</varname> and "
"<varname>tdwithin</varname> are supported for two temporal geography points."
msgstr ""
"De manera similar, solo unas pocas relaciones topológicas temporales son "
"significativas cuando los dos argumentos son puntos temporales. Por lo "
"tanto, las relaciones admitidas para dos puntos de geometría temporal son "
"<varname>tdisjoint</varname>, <varname>tequals</varname>, "
"<varname>tintersects</varname>, <varname>tdwithin</varname>, "
"y<varname>trelate</varname> (con 2 y 3 argumentos), mientras que solo "
"<varname>tintersects</varname> y<varname>tdwithin</varname> son disponibles "
"con dos puntos geográficos temporales."

#. Tag: para
#: manipulating_temporal_types.xml:1338
#, no-c-format
msgid ""
"The <varname>relate</varname> and the <varname>trelate</varname> functions "
"have two forms with either two or three arguments. The two-argument forms "
"consider the spatial relationship between the interior, the boundary, and "
"the exterior of the arguments and return a <varname>text</varname> or a "
"<varname>ttext</varname> value representing the maximum intersection matrix "
"pattern. This pattern is defined using the Dimensionally Extended 9 "
"Intersection Model or DE-9IM (see the PostGIS documentation for more "
"details). The three-argument forms determine whether the first two arguments"
" satisfy the intersection matrix pattern given as third argument (a "
"<varname>text</varname> value) and return a Boolean or a temporal Boolean."
msgstr ""
"Las funciones<varname>relate</varname> y <varname>trelate</varname> tienen "
"dos formas con dos o tres argumentos. Las formas de dos argumentos "
"consideran la relación espacial entre el interior, el límite y el exterior "
"de los argumentos y devuelven un valor <varname>text</varname> o "
"<varname>ttext</varname> que representa el patrón de matriz de intersección "
"máxima. Este patrón se define mediante el modelo de 9 intersecciones "
"dimensionalmente extendido o DE-9IM (consulte la documentación de PostGIS "
"para obtener más detalles). Las formas de tres argumentos determinan si los "
"dos primeros argumentos satisfacen el patrón de matriz de intersección dado "
"como tercer argumento (un valor <varname>text</varname>) y devuelve un "
"booleano o un booleano temporal."

#. Tag: title
#: manipulating_temporal_types.xml:1341
#, no-c-format
msgid "Possible Spatial Relationships"
msgstr "Relaciones espaciales posibles "

#. Tag: varname
#: manipulating_temporal_types.xml:1344
#, no-c-format
msgid "contains"
msgstr "contains"

#. Tag: para
#: manipulating_temporal_types.xml:1345
#, no-c-format
msgid "May contain"
msgstr "Puede contener"

#. Tag: varname
#: manipulating_temporal_types.xml:1346
#, no-c-format
msgid "contains({geo, tgeompoint}, {geo, tgeompoint}): boolean"
msgstr "contains({geo, tgeompoint}, {geo, tgeompoint}): boolean"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1347
#, no-c-format
msgid ""
"SELECT contains(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',\n"
"tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)');\n"
"-- true"
msgstr ""
"SELECT contains(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',\n"
"tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)');\n"
"-- true"

#. Tag: varname
#: manipulating_temporal_types.xml:1351
#, no-c-format
msgid "containsproperly"
msgstr "containsproperly"

#. Tag: para
#: manipulating_temporal_types.xml:1352
#, no-c-format
msgid "May contain properly"
msgstr "Puede contener estrictamente"

#. Tag: varname
#: manipulating_temporal_types.xml:1353
#, no-c-format
msgid "containsproperly({geo, tgeompoint}, {geo, tgeompoint}): boolean"
msgstr "containsproperly({geo, tgeompoint}, {geo, tgeompoint}): boolean"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1354
#, no-c-format
msgid ""
"SELECT containsproperly(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',\n"
"tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)');\n"
"-- false"
msgstr ""
"SELECT containsproperly(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',\n"
"tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)');\n"
"-- false"

#. Tag: varname
#: manipulating_temporal_types.xml:1358
#, no-c-format
msgid "covers"
msgstr "covers"

#. Tag: para
#: manipulating_temporal_types.xml:1359
#, no-c-format
msgid "May cover"
msgstr "Puede cubrir"

#. Tag: varname
#: manipulating_temporal_types.xml:1360
#, no-c-format
msgid "covers({geo, tpoint}, {geo, tpoint}): boolean"
msgstr "covers({geo, tpoint}, {geo, tpoint}): boolean"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1361
#, no-c-format
msgid ""
"SELECT covers(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',\n"
"tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)');\n"
"-- true"
msgstr ""
"SELECT covers(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',\n"
"tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)');\n"
"-- true"

#. Tag: varname
#: manipulating_temporal_types.xml:1365
#, no-c-format
msgid "coveredby"
msgstr "coveredby"

#. Tag: para
#: manipulating_temporal_types.xml:1366
#, no-c-format
msgid "May be covered by"
msgstr "Puede estar cubierto por"

#. Tag: varname
#: manipulating_temporal_types.xml:1367
#, no-c-format
msgid "coveredby({geo, tpoint}, {geo, tpoint}): boolean"
msgstr "coveredby({geo, tpoint}, {geo, tpoint}): boolean"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1368
#, no-c-format
msgid ""
"SELECT coveredby(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',\n"
"tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)');\n"
"-- false"
msgstr ""
"SELECT coveredby(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',\n"
"tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)');\n"
"-- false"

#. Tag: varname
#: manipulating_temporal_types.xml:1372
#, no-c-format
msgid "crosses"
msgstr "crosses"

#. Tag: para
#: manipulating_temporal_types.xml:1373
#, no-c-format
msgid "May cross"
msgstr "Puede cruzar"

#. Tag: varname
#: manipulating_temporal_types.xml:1374
#, no-c-format
msgid "crosses({geo, tgeompoint}, {geo, tgeompoint}): boolean"
msgstr "crosses({geo, tgeompoint}, {geo, tgeompoint}): boolean"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1375
#, no-c-format
msgid ""
"SELECT crosses(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',\n"
"tgeompoint '[Point(0 0)@2012-01-01, Point(2 2)@2012-01-03)');\n"
"-- true"
msgstr ""
"SELECT crosses(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',\n"
"tgeompoint '[Point(0 0)@2012-01-01, Point(2 2)@2012-01-03)');\n"
"-- true"

#. Tag: varname
#: manipulating_temporal_types.xml:1379
#, no-c-format
msgid "disjoint"
msgstr "disjoint"

#. Tag: para
#: manipulating_temporal_types.xml:1380
#, no-c-format
msgid "May be disjoint"
msgstr "Puede ser disjunto"

#. Tag: varname
#: manipulating_temporal_types.xml:1381
#, no-c-format
msgid "disjoint({geo, tgeompoint}, {geo, tgeompoint}): boolean"
msgstr "disjoint({geo, tgeompoint}, {geo, tgeompoint}): boolean"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1382
#, no-c-format
msgid ""
"SELECT disjoint(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',\n"
"tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)');\n"
"-- false"
msgstr ""
"SELECT disjoint(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',\n"
"tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)');\n"
"-- false"

#. Tag: varname
#: manipulating_temporal_types.xml:1386
#, no-c-format
msgid "equals"
msgstr "equals"

#. Tag: para
#: manipulating_temporal_types.xml:1387
#, no-c-format
msgid "May be equal"
msgstr "Puede ser igual"

#. Tag: varname
#: manipulating_temporal_types.xml:1388
#, no-c-format
msgid "equals({geo, tgeompoint}, {geo, tgeompoint}): boolean"
msgstr "equals({geo, tgeompoint}, {geo, tgeompoint}): boolean"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1389
#, no-c-format
msgid ""
"SELECT equals(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',\n"
"tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)');\n"
"-- false"
msgstr ""
"SELECT equals(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',\n"
"tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)');\n"
"-- false"

#. Tag: varname
#: manipulating_temporal_types.xml:1393
#, no-c-format
msgid "intersects"
msgstr "intersects"

#. Tag: para
#: manipulating_temporal_types.xml:1394
#, no-c-format
msgid "May intersect &Z_support;"
msgstr "Puede cruzarse &Z_support;"

#. Tag: varname
#: manipulating_temporal_types.xml:1395
#, no-c-format
msgid "intersects({geo, tpoint}, {geo, tpoint}): boolean"
msgstr "intersects({geo, tpoint}, {geo, tpoint}): boolean"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1396
#, no-c-format
msgid ""
"SELECT intersects(geometry 'Polygon((0 0 0,0 1 0,1 1 0,1 0 0,0 0 0))',\n"
"tgeompoint '[Point(0 0 1)@2012-01-01, Point(1 1 1)@2012-01-03)');\n"
"-- false\n"
"SELECT intersects(geometry 'Polygon((0 0 0,0 1 1,1 1 1,1 0 0,0 0 0))',\n"
"tgeompoint '[Point(0 0 1)@2012-01-01, Point(1 1 1)@2012-01-03)');\n"
"-- true"
msgstr ""
"SELECT intersects(geometry 'Polygon((0 0 0,0 1 0,1 1 0,1 0 0,0 0 0))',\n"
"tgeompoint '[Point(0 0 1)@2012-01-01, Point(1 1 1)@2012-01-03)');\n"
"-- false\n"
"SELECT intersects(geometry 'Polygon((0 0 0,0 1 1,1 1 1,1 0 0,0 0 0))',\n"
"tgeompoint '[Point(0 0 1)@2012-01-01, Point(1 1 1)@2012-01-03)');\n"
"-- true"

#. Tag: varname
#: manipulating_temporal_types.xml:1400
#, no-c-format
msgid "overlaps"
msgstr "overlaps"

#. Tag: para
#: manipulating_temporal_types.xml:1401
#, no-c-format
msgid "May overlap"
msgstr "Puede superponerse"

#. Tag: varname
#: manipulating_temporal_types.xml:1402
#, no-c-format
msgid "overlaps({geo, tgeompoint}, {geo, tgeompoint}): boolean"
msgstr "overlaps({geo, tgeompoint}, {geo, tgeompoint}): boolean"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1403
#, no-c-format
msgid ""
"SELECT overlaps(geometry 'Linestring(1 1,3 3)',\n"
"tgeompoint '[Point(0 0)@2012-01-01, Point(2 2)@2012-01-03)');\n"
"-- true"
msgstr ""
"SELECT overlaps(geometry 'Linestring(1 1,3 3)',\n"
"tgeompoint '[Point(0 0)@2012-01-01, Point(2 2)@2012-01-03)');\n"
"-- true"

#. Tag: varname
#: manipulating_temporal_types.xml:1407
#, no-c-format
msgid "touches"
msgstr "touches"

#. Tag: para
#: manipulating_temporal_types.xml:1408
#, no-c-format
msgid "May touch"
msgstr "Puede tocar"

#. Tag: varname
#: manipulating_temporal_types.xml:1409
#, no-c-format
msgid "touches({geo, tgeompoint}, {geo, tgeompoint}): boolean"
msgstr "touches({geo, tgeompoint}, {geo, tgeompoint}): boolean"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1410
#, no-c-format
msgid ""
"SELECT touches(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',\n"
"tgeompoint '[Point(0 0)@2012-01-01, Point(0 1)@2012-01-03)');\n"
"-- true"
msgstr ""
"SELECT touches(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',\n"
"tgeompoint '[Point(0 0)@2012-01-01, Point(0 1)@2012-01-03)');\n"
"-- true"

#. Tag: varname
#: manipulating_temporal_types.xml:1414
#, no-c-format
msgid "within"
msgstr "within"

#. Tag: para
#: manipulating_temporal_types.xml:1415
#, no-c-format
msgid "May be within"
msgstr "Puede estar dentro"

#. Tag: varname
#: manipulating_temporal_types.xml:1416
#, no-c-format
msgid "within({geo, tgeompoint}, {geo, tgeompoint}): boolean"
msgstr "within({geo, tgeompoint}, {geo, tgeompoint}): boolean"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1417
#, no-c-format
msgid ""
"SELECT within(geometry 'LineString(1 1,2 2)',\n"
"tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-03)');\n"
"-- true"
msgstr ""
"SELECT within(geometry 'LineString(1 1,2 2)',\n"
"tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-03)');\n"
"-- true"

#. Tag: varname
#: manipulating_temporal_types.xml:1421
#, no-c-format
msgid "dwithin"
msgstr "dwithin"

#. Tag: para
#: manipulating_temporal_types.xml:1422
#, no-c-format
msgid "May be at distance within &Z_support;"
msgstr "Puede estar a distancia de &Z_support;"

#. Tag: varname
#: manipulating_temporal_types.xml:1423
#, no-c-format
msgid "dwithin({geo, tpoint}, {geo, tpoint}, double): boolean"
msgstr "dwithin({geo, tpoint}, {geo, tpoint}, double): boolean"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1424
#, no-c-format
msgid ""
"SELECT dwithin(geometry 'Polygon((0 0 0,0 1 1,1 1 1,1 0 0,0 0 0))',\n"
"tgeompoint 'Point(0 2 1)@2000-01-01,Point(2 2 1)@2000-01-02', 1)\n"
"-- true\n"
"SELECT dwithin(geometry 'Polygon((0 0 0,0 1 1,1 1 1,1 0 0,0 0 0))',\n"
"tgeompoint 'Point(0 2 2)@2000-01-01,Point(2 2 2)@2000-01-02', 1)\n"
"--        false"
msgstr ""
"SELECT dwithin(geometry 'Polygon((0 0 0,0 1 1,1 1 1,1 0 0,0 0 0))',\n"
"tgeompoint 'Point(0 2 1)@2000-01-01,Point(2 2 1)@2000-01-02', 1)\n"
"-- true\n"
"SELECT dwithin(geometry 'Polygon((0 0 0,0 1 1,1 1 1,1 0 0,0 0 0))',\n"
"tgeompoint 'Point(0 2 2)@2000-01-01,Point(2 2 2)@2000-01-02', 1)\n"
"--        false"

#. Tag: varname
#: manipulating_temporal_types.xml:1428
#, no-c-format
msgid "relate"
msgstr "relate"

#. Tag: para
#: manipulating_temporal_types.xml:1429
#, no-c-format
msgid "May relate"
msgstr "Puede estar relacionado"

#. Tag: varname
#: manipulating_temporal_types.xml:1430
#, no-c-format
msgid "relate({geo, tgeompoint}, {geo, tgeompoint}): text"
msgstr "relate({geo, tgeompoint}, {geo, tgeompoint}): text"

#. Tag: varname
#: manipulating_temporal_types.xml:1431
#, no-c-format
msgid "relate({geo, tgeompoint}, {geo, tgeompoint}, text): boolean"
msgstr "relate({geo, tgeompoint}, {geo, tgeompoint}, text): boolean"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1432
#, no-c-format
msgid ""
"SELECT relate(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',\n"
"tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)');\n"
"-- \"1F2F01FF2\"\n"
"SELECT relate(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',\n"
"tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)','1F2F01FF2');\n"
"-- true"
msgstr ""
"SELECT relate(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',\n"
"tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)');\n"
"-- \"1F2F01FF2\"\n"
"SELECT relate(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',\n"
"tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)','1F2F01FF2');\n"
"-- true"

#. Tag: title
#: manipulating_temporal_types.xml:1438
#, no-c-format
msgid "Temporal Spatial Relationships"
msgstr "Relaciones espaciales temporales"

#. Tag: varname
#: manipulating_temporal_types.xml:1441
#, no-c-format
msgid "tcontains"
msgstr "tcontains"

#. Tag: para
#: manipulating_temporal_types.xml:1442
#, no-c-format
msgid "Temporal contains"
msgstr "Contiene temporal"

#. Tag: varname
#: manipulating_temporal_types.xml:1443
#, no-c-format
msgid "tcontains({geo, tgeompoint}, {geo, tgeompoint}): tbool"
msgstr "tcontains({geo, tgeompoint}, {geo, tgeompoint}): tbool"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1444
#, no-c-format
msgid ""
"SELECT tcontains(geometry 'Polygon((1 1,1 2,2 2,2 1,1 1))',\n"
"tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-04)');\n"
"-- \"{[f@2012-01-01, f@2012-01-02], (t@2012-01-02, f@2012-01-03, f@2012-01-04)}\""
msgstr ""
"SELECT tcontains(geometry 'Polygon((1 1,1 2,2 2,2 1,1 1))',\n"
"tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-04)');\n"
"-- \"{[f@2012-01-01, f@2012-01-02], (t@2012-01-02, f@2012-01-03, f@2012-01-04)}\""

#. Tag: varname
#: manipulating_temporal_types.xml:1448
#, no-c-format
msgid "tcovers"
msgstr "tcovers"

#. Tag: para
#: manipulating_temporal_types.xml:1449
#, no-c-format
msgid "Temporal covers &geography_support;"
msgstr "Cubrir temporal &geography_support;"

#. Tag: varname
#: manipulating_temporal_types.xml:1450
#, no-c-format
msgid "tcovers({geo, tpoint}, {geo, tpoint}): tbool"
msgstr "tcovers({geo, tpoint}, {geo, tpoint}): tbool"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1451
#, no-c-format
msgid ""
"SELECT tcovers(geometry 'Polygon((1 1,1 2,2 2,2 1,1 1))',\n"
"tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-04)');\n"
"-- \"{[f@2012-01-01, t@2012-01-02, t@2012-01-03], (f@2012-01-03, f@2012-01-04]}\""
msgstr ""
"SELECT tcovers(geometry 'Polygon((1 1,1 2,2 2,2 1,1 1))',\n"
"tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-04)');\n"
"-- \"{[f@2012-01-01, t@2012-01-02, t@2012-01-03], (f@2012-01-03, f@2012-01-04]}\""

#. Tag: varname
#: manipulating_temporal_types.xml:1455
#, no-c-format
msgid "tcoveredby"
msgstr "tcoveredby"

#. Tag: para
#: manipulating_temporal_types.xml:1456
#, no-c-format
msgid "Temporal covered by &geography_support;"
msgstr "Cubierto por temporal &geography_support;"

#. Tag: varname
#: manipulating_temporal_types.xml:1457
#, no-c-format
msgid "tcoveredby({geo, tpoint}, {geo, tpoint}): tbool"
msgstr "tcoveredby({geo, tpoint}, {geo, tpoint}): tbool"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1458
#, no-c-format
msgid ""
"SELECT tcoveredby(geometry 'Point(1 1)',\n"
"tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-04)');\n"
"-- \"{[f@2012-01-01, t@2012-01-02], (f@2012-01-02, f@2012-01-04)}\""
msgstr ""
"SELECT tcoveredby(geometry 'Point(1 1)',\n"
"tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-04)');\n"
"-- \"{[f@2012-01-01, t@2012-01-02], (f@2012-01-02, f@2012-01-04)}\""

#. Tag: varname
#: manipulating_temporal_types.xml:1462
#, no-c-format
msgid "tdisjoint"
msgstr "tdisjoint"

#. Tag: para
#: manipulating_temporal_types.xml:1463
#, no-c-format
msgid "Temporal disjoint &Z_support; &geography_support;"
msgstr "Disjunto temporal &Z_support; &geography_support;"

#. Tag: varname
#: manipulating_temporal_types.xml:1464
#, no-c-format
msgid "tdisjoint({geo, tgeompoint}, {geo, tgeompoint}): tbool"
msgstr "tdisjoint({geo, tgeompoint}, {geo, tgeompoint}): tbool"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1465
#, no-c-format
msgid ""
"SELECT tdisjoint(geometry 'Polygon((1 1,1 2,2 2,2 1,1 1))',\n"
"tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-04)');\n"
"-- \"{[t@2012-01-01, f@2012-01-02, f@2012-01-03], (t@2012-01-03, t@2012-01-04]}\"\n"
"SELECT tdisjoint(tgeompoint '[Point(0 3)@2012-01-01, Point(3 0)@2012-01-05)',\n"
"tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-05)');\n"
"-- \"{[t@2012-01-01, f@2012-01-03], (t@2012-01-03, t@2012-01-05)}\""
msgstr ""
"SELECT tdisjoint(geometry 'Polygon((1 1,1 2,2 2,2 1,1 1))',\n"
"tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-04)');\n"
"-- \"{[t@2012-01-01, f@2012-01-02, f@2012-01-03], (t@2012-01-03, t@2012-01-04]}\"\n"
"SELECT tdisjoint(tgeompoint '[Point(0 3)@2012-01-01, Point(3 0)@2012-01-05)',\n"
"tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-05)');\n"
"-- \"{[t@2012-01-01, f@2012-01-03], (t@2012-01-03, t@2012-01-05)}\""

#. Tag: varname
#: manipulating_temporal_types.xml:1469
#, no-c-format
msgid "tequals"
msgstr "tequals"

#. Tag: para
#: manipulating_temporal_types.xml:1470
#, no-c-format
msgid "Temporal equals &Z_support; &geography_support;"
msgstr "Igual temporal &Z_support; &geography_support;"

#. Tag: varname
#: manipulating_temporal_types.xml:1471
#, no-c-format
msgid "tequals({point, tgeompoint}, {point, tgeompoint}): tbool"
msgstr "tequals({point, tgeompoint}, {point, tgeompoint}): tbool"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1472
#, no-c-format
msgid ""
"SELECT tequals(geometry 'Point(1 1)',\n"
"tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-04)');\n"
"-- \"{[f@2012-01-01, t@2012-01-02], (f@2012-01-02, f@2012-01-04]}\"\n"
"SELECT tequals(tgeompoint '[Point(0 3)@2012-01-01, Point(3 0)@2012-01-05)',\n"
"tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-05)');\n"
"-- \"{[f@2012-01-01, t@2012-01-03], (f@2012-01-03, f@2012-01-05)}\""
msgstr ""
"SELECT tequals(geometry 'Point(1 1)',\n"
"tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-04)');\n"
"-- \"{[f@2012-01-01, t@2012-01-02], (f@2012-01-02, f@2012-01-04]}\"\n"
"SELECT tequals(tgeompoint '[Point(0 3)@2012-01-01, Point(3 0)@2012-01-05)',\n"
"tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-05)');\n"
"-- \"{[f@2012-01-01, t@2012-01-03], (f@2012-01-03, f@2012-01-05)}\""

#. Tag: varname
#: manipulating_temporal_types.xml:1476
#, no-c-format
msgid "tintersects"
msgstr "tintersects"

#. Tag: para
#: manipulating_temporal_types.xml:1477
#, no-c-format
msgid "Temporal intersects &Z_support; &geography_support;"
msgstr "Intersección temporal &Z_support; &geography_support;"

#. Tag: varname
#: manipulating_temporal_types.xml:1478
#, no-c-format
msgid "tintersects({geo, tpoint}, {geo, tpoint}): tbool"
msgstr "tintersects({geo, tpoint}, {geo, tpoint}): tbool"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1479
#, no-c-format
msgid ""
"SELECT tintersects(geometry 'MultiPoint(1 1,2 2)',\n"
"tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-04)');\n"
"-- \"{[f@2012-01-01, t@2012-01-02], (f@2012-01-02, t@2012-01-03],\n"
"(f@2012-01-03, f@2012-01-04]}\"\n"
"SELECT tintersects(tgeompoint '[Point(0 3)@2012-01-01, Point(3 0)@2012-01-05)',\n"
"tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-05)');\n"
"-- \"{[f@2012-01-01, t@2012-01-03], (f@2012-01-03, f@2012-01-05)}\""
msgstr ""
"SELECT tintersects(geometry 'MultiPoint(1 1,2 2)',\n"
"tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-04)');\n"
"-- \"{[f@2012-01-01, t@2012-01-02], (f@2012-01-02, t@2012-01-03],\n"
"(f@2012-01-03, f@2012-01-04]}\"\n"
"SELECT tintersects(tgeompoint '[Point(0 3)@2012-01-01, Point(3 0)@2012-01-05)',\n"
"tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-05)');\n"
"-- \"{[f@2012-01-01, t@2012-01-03], (f@2012-01-03, f@2012-01-05)}\""

#. Tag: varname
#: manipulating_temporal_types.xml:1483
#, no-c-format
msgid "ttouches"
msgstr "ttouches"

#. Tag: para
#: manipulating_temporal_types.xml:1484
#, no-c-format
msgid "Temporal touches"
msgstr "Toca temporal"

#. Tag: varname
#: manipulating_temporal_types.xml:1485
#, no-c-format
msgid "ttouches({geo, tgeompoint}, {geo, tgeompoint}): tbool"
msgstr "ttouches({geo, tgeompoint}, {geo, tgeompoint}): tbool"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1486
#, no-c-format
msgid ""
"SELECT ttouches(geometry 'Polygon((1 0,1 2,2 2,2 0,1 0))',\n"
"tgeompoint '[Point(0 0)@2012-01-01, Point(3 0)@2012-01-04)');\n"
"-- \"{[f@2012-01-01, t@2012-01-02, t@2012-01-03], (f@2012-01-03, f@2012-01-04]}\""
msgstr ""
"SELECT ttouches(geometry 'Polygon((1 0,1 2,2 2,2 0,1 0))',\n"
"tgeompoint '[Point(0 0)@2012-01-01, Point(3 0)@2012-01-04)');\n"
"-- \"{[f@2012-01-01, t@2012-01-02, t@2012-01-03], (f@2012-01-03, f@2012-01-04]}\""

#. Tag: varname
#: manipulating_temporal_types.xml:1490
#, no-c-format
msgid "twithin"
msgstr "twithin"

#. Tag: para
#: manipulating_temporal_types.xml:1491
#, no-c-format
msgid "Temporal within"
msgstr "Dentro temporal "

#. Tag: varname
#: manipulating_temporal_types.xml:1492
#, no-c-format
msgid "twithin({geo, tgeompoint}, {geo, tgeompoint}): tbool"
msgstr "twithin({geo, tgeompoint}, {geo, tgeompoint}): tbool"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1493
#, no-c-format
msgid ""
"SELECT twithin(geometry 'Point(1 1)',\n"
"tgeompoint '[Point(0 0)@2012-01-01, Point(2 2)@2012-01-03)');\n"
"-- \"{[f@2012-01-01, t@2012-01-02], (f@2012-01-02, f@2012-01-03]}\""
msgstr ""
"SELECT twithin(geometry 'Point(1 1)',\n"
"tgeompoint '[Point(0 0)@2012-01-01, Point(2 2)@2012-01-03)');\n"
"-- \"{[f@2012-01-01, t@2012-01-02], (f@2012-01-02, f@2012-01-03]}\""

#. Tag: varname
#: manipulating_temporal_types.xml:1497
#, no-c-format
msgid "tdwithin"
msgstr "tdwithin"

#. Tag: para
#: manipulating_temporal_types.xml:1498
#, no-c-format
msgid "Temporal distance within &Z_support; &geography_support;"
msgstr "Estar a distancia de temporal &Z_support; &geography_support;"

#. Tag: varname
#: manipulating_temporal_types.xml:1499
#, no-c-format
msgid "tdwithin({geo, tpoint}, {geo, tpoint}, double): tbool"
msgstr "tdwithin({geo, tpoint}, {geo, tpoint}, double): tbool"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1500
#, no-c-format
msgid ""
"SELECT tdwithin(geometry 'Polygon((1 1,1 2,2 2,2 1,1 1))',\n"
"tgeompoint '[Point(0 0)@2012-01-01, Point(3 0)@2012-01-04)', 1);\n"
"-- \"{[f@2012-01-01, t@2012-01-02, t@2012-01-03], (f@2012-01-03, f@2012-01-04)}\"\n"
"SELECT tdwithin(tgeompoint '[Point(1 0)@2000-01-01, Point(1 4)@2000-01-05]',\n"
"tgeompoint 'Interp=Stepwise;[Point(1 2)@2000-01-01, Point(1 3)@2000-01-05]', 1);\n"
"-- \"{[f@2000-01-01, t@2000-01-02, t@2000-01-04], (f@2000-01-04, t@2000-01-05]}\""
msgstr ""
"SELECT tdwithin(geometry 'Polygon((1 1,1 2,2 2,2 1,1 1))',\n"
"tgeompoint '[Point(0 0)@2012-01-01, Point(3 0)@2012-01-04)', 1);\n"
"-- \"{[f@2012-01-01, t@2012-01-02, t@2012-01-03], (f@2012-01-03, f@2012-01-04)}\"\n"
"SELECT tdwithin(tgeompoint '[Point(1 0)@2000-01-01, Point(1 4)@2000-01-05]',\n"
"tgeompoint 'Interp=Stepwise;[Point(1 2)@2000-01-01, Point(1 3)@2000-01-05]', 1);\n"
"-- \"{[f@2000-01-01, t@2000-01-02, t@2000-01-04], (f@2000-01-04, t@2000-01-05]}\""

#. Tag: varname
#: manipulating_temporal_types.xml:1504 manipulating_temporal_types.xml:1526
#, no-c-format
msgid "trelate"
msgstr "trelate"

#. Tag: para
#: manipulating_temporal_types.xml:1505
#, no-c-format
msgid "Temporal relate"
msgstr "Relacionar temporal"

#. Tag: varname
#: manipulating_temporal_types.xml:1506
#, no-c-format
msgid "trelate({geo, tgeompoint}, {geo, tgeompoint}, text): tbool"
msgstr "trelate({geo, tgeompoint}, {geo, tgeompoint}, text): tbool"

#. Tag: varname
#: manipulating_temporal_types.xml:1507
#, no-c-format
msgid "trelate({geo, tgeompoint}, {geo, tgeompoint}): ttext"
msgstr "trelate({geo, tgeompoint}, {geo, tgeompoint}): ttext"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1508
#, no-c-format
msgid ""
"SELECT trelate(geometry 'Polygon((1 0,1 2,2 2,2 0,1 0))',\n"
"tgeompoint '[Point(0 0)@2012-01-01, Point(3 0)@2012-01-04)');\n"
"-- \"{[FF2FF10F2@2012-01-01, FF20F1FF2@2012-01-02, FF20F1FF2@2012-01-03],\n"
"(FF2FF10F2@2012-01-03, FF2FF10F2@2012-01-04]}\"\n"
"SELECT trelate(geometry 'Polygon((1 0,1 2,2 2,2 0,1 0))',\n"
"tgeompoint '[Point(0 0)@2012-01-01, Point(3 0)@2012-01-04)', 'FF20F1FF2');\n"
"-- \"{[f@2012-01-01, t@2012-01-02, t@2012-01-03], (f@2012-01-03, f@2012-01-04]}\"\n"
"2012-01-04)}\""
msgstr ""
"SELECT trelate(geometry 'Polygon((1 0,1 2,2 2,2 0,1 0))',\n"
"tgeompoint '[Point(0 0)@2012-01-01, Point(3 0)@2012-01-04)');\n"
"-- \"{[FF2FF10F2@2012-01-01, FF20F1FF2@2012-01-02, FF20F1FF2@2012-01-03],\n"
"(FF2FF10F2@2012-01-03, FF2FF10F2@2012-01-04]}\"\n"
"SELECT trelate(geometry 'Polygon((1 0,1 2,2 2,2 0,1 0))',\n"
"tgeompoint '[Point(0 0)@2012-01-01, Point(3 0)@2012-01-04)', 'FF20F1FF2');\n"
"-- \"{[f@2012-01-01, t@2012-01-02, t@2012-01-03], (f@2012-01-03, f@2012-01-04]}\"\n"
"2012-01-04)}\""

#. Tag: title
#: manipulating_temporal_types.xml:1515
#, no-c-format
msgid "Aggregate Functions for Temporal Types"
msgstr "Funciones agregadas para tipos temporales"

#. Tag: para
#: manipulating_temporal_types.xml:1517
#, no-c-format
msgid ""
"The temporal aggregate functions generalize the traditional aggregate "
"functions. Their semantics is that they compute the value of the function at"
" every instant t in the union of the temporal extents of the values to "
"aggregate."
msgstr ""
"Las funciones agregadas temporales generalizan las funciones agregadas "
"tradicionales. Su semántica es que calculan el valor de la función en cada "
"instante en la unión de las extensiones temporales de los valores a agregar."

#. Tag: para
#: manipulating_temporal_types.xml:1519
#, no-c-format
msgid ""
"For all temporal types, the function <varname>tcount</varname> generalize "
"the traditional function <varname>count</varname>. The temporal count can be"
" used to compute at each point in time the number of available or reporting "
"objects (for example, number of cars in an area). For Boolean types, the "
"functions <varname>tand</varname> and <varname>tor</varname> generalize the "
"traditional functions <varname>and</varname> and <varname>or</varname>. For "
"numeric types, two types of temporal aggregate functions are available. The "
"functions <varname>tmin</varname>, <varname>tmax</varname>, "
"<varname>tsum</varname>, and <varname>tavg</varname> generalize the "
"traditional functions <varname>min</varname>, <varname>max</varname>, "
"<varname>sum</varname>, and <varname>avg</varname>. Furthermore, the "
"functions <varname>wmin</varname>, <varname>wmax</varname>, "
"<varname>wcount</varname>, <varname>wsum</varname>, and "
"<varname>wavg</varname> are window (or cumulative) versions of the "
"traditional functions that, given a time interval w, compute the value of "
"the function at an instant t by considering the values during the interval "
"[t-w, t]. All window aggregate functions are available for temporal "
"integers, while for temporal floats only window minimum and maximum are "
"meaningful. For temporal text, the functions Finally, for temporal points "
"the function <varname>tcentroid</varname>, generalizes the corresponding "
"function <varname>ST_Centroid</varname> provided by PostGIS. For example, "
"given set of objects that move together (that is, a convoy or a flock) the "
"temporal centroid will produce a temporal point that represents at each "
"instant the geometric center (or the center of mass) of all the moving "
"objects."
msgstr ""
"Para todos los tipos temporales, la función <varname>tcount</varname> "
"generaliza la función traditional <varname>count</varname>. El conteo "
"temporal se puede utilizar para calcular en cada momento el número de "
"objetos disponibles o que reportan (por ejemplo, el número de coches en un "
"área). Para los tipos booleanos, las funciones <varname>tand</varname> "
"y<varname>tor</varname> generalizan las funciones traditionales "
"<varname>and</varname> y <varname>or</varname>. Para los tipos numéricos, "
"están disponibles dos tipos de funciones agregadas temporales. Las funciones"
" <varname>tmin</varname>, <varname>tmax</varname>, <varname>tsum</varname>, "
"y <varname>tavg</varname> generalizan las funciones traditionales "
"<varname>min</varname>, <varname>max</varname>, <varname>sum</varname>, y "
"<varname>avg</varname>. Además, las funciones <varname>wmin</varname>, "
"<varname>wmax</varname>, <varname>wcount</varname>, <varname>wsum</varname>,"
" y <varname>wavg</varname> son versiones de ventana (o acumulativas) de las "
"funciones tradicionales que, dado un intervalo de tiempo w, calculan el "
"valor de la función en un instante t considerando los valores durante el "
"intervalo [t-w, t]. Todas las funciones agregadas de ventana están "
"disponibles para enteros temporales, mientras que para flotantes temporales "
"solo son significativos el mínimo y el máximo de ventana. Para el texto "
"temporal, las funciones <varname>tmin</varname> y <varname> tmax</varname> "
"están disponibles. Finalmente, para puntos temporales la función "
"<varname>tcentroid</varname>, generaliza la función correspondiente "
"<varname>ST_Centroid</varname> proporcionada por PostGIS. Por ejemplo, dado "
"un conjunto de objetos que se mueven juntos (es decir, un convoy o una "
"bandada), el centroide temporal producirá un punto temporal que representa "
"en cada instante el centro geométrico (o el centro de masa) de todos los "
"objetos en movimiento."

#. Tag: para
#: manipulating_temporal_types.xml:1521
#, no-c-format
msgid ""
"In addition to the above, function <varname>extent</varname> returns a "
"bounding box that encloses a set of temporal values. Depending on the base "
"type, the result of this function can be a <varname>period</varname>, a "
"<varname>tbox</varname> or an <varname>stbox</varname>. This function is an "
"&ldquo;aggregate&rdquo; function in SQL terminology since it operates on "
"lists of data, in the same way the SUM() and AVG() functions do."
msgstr ""
"Además de lo anterior, la función<varname>extent</varname> devuelve un "
"cuadro delimitador que engloba un conjunto de valores temporales. "
"Dependiendo del tipo de base, el resultado de esta función puede ser un "
"<varname>period</varname>, un <varname>tbox</varname> o un "
"<varname>stbox</varname>. Esta función es una funcion aggregada en "
"terminología SQL, ya que opera en listas de datos, de la misma manera que lo"
" hacen las funciones <varname>SUM</varname> y <varname>AVG</varname>."

#. Tag: para
#: manipulating_temporal_types.xml:1523
#, no-c-format
msgid ""
"In the examples that follow, we suppose the tables "
"<varname>Department</varname> and <varname>Trip</varname> contain the two "
"tuples introduced in <xref linkend=\"examples_temporal_types\"/>."
msgstr ""
"En los ejemplos que siguen, suponemos que las tablas "
"<varname>Department</varname> y <varname>Trip</varname> contienen las dos "
"tuplas introducidas en <xref linkend=\"examples_temporal_types\"/>."

#. Tag: para
#: manipulating_temporal_types.xml:1527
#, no-c-format
msgid "Temporal count"
msgstr "Conteo temporal"

#. Tag: varname
#: manipulating_temporal_types.xml:1528
#, no-c-format
msgid "tcount(ttype): {tinti, tints}"
msgstr "tcount(ttype): {tinti, tints}"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1529
#, no-c-format
msgid ""
"SELECT tcount(NoEmps) FROM Department;\n"
"-- \"{[1@2012-01-01, 2@2012-02-01, 1@2012-08-01, 1@2012-10-01)}\""
msgstr ""
"SELECT tcount(NoEmps) FROM Department;\n"
"-- \"{[1@2012-01-01, 2@2012-02-01, 1@2012-08-01, 1@2012-10-01)}\""

#. Tag: varname
#: manipulating_temporal_types.xml:1533
#, no-c-format
msgid "tand"
msgstr "tand"

#. Tag: varname
#: manipulating_temporal_types.xml:1535
#, no-c-format
msgid "tand(tbool): tbool"
msgstr "tand(tbool): tbool"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1536
#, no-c-format
msgid ""
"SELECT tand(NoEmps #&gt; 6) FROM Department;\n"
"-- \"{[t@2012-01-01, f@2012-04-01, f@2012-10-01)}\""
msgstr ""
"SELECT tand(NoEmps #&gt; 6) FROM Department;\n"
"-- \"{[t@2012-01-01, f@2012-04-01, f@2012-10-01)}\""

#. Tag: varname
#: manipulating_temporal_types.xml:1540
#, no-c-format
msgid "<varname>tor</varname>"
msgstr "<varname>tor</varname>"

#. Tag: varname
#: manipulating_temporal_types.xml:1542
#, no-c-format
msgid "tor(tbool): tbool"
msgstr "tor(tbool): tbool"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1543
#, no-c-format
msgid ""
"SELECT tor(NoEmps #&gt; 6) FROM Department;\n"
"-- \"{[t@2012-01-01, f@2012-08-01, f@2012-10-01)}\""
msgstr ""
"SELECT tor(NoEmps #&gt; 6) FROM Department;\n"
"-- \"{[t@2012-01-01, f@2012-08-01, f@2012-10-01)}\""

#. Tag: varname
#: manipulating_temporal_types.xml:1547
#, no-c-format
msgid "tmin"
msgstr "tmin"

#. Tag: para
#: manipulating_temporal_types.xml:1548
#, no-c-format
msgid "Temporal minimum"
msgstr "Mínimo temporal"

#. Tag: varname
#: manipulating_temporal_types.xml:1549
#, no-c-format
msgid "tmin(ttype): {ttypei, ttypes}"
msgstr "tmin(ttype): {ttypei, ttypes}"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1550
#, no-c-format
msgid ""
"SELECT tmin(NoEmps) FROM Department;\n"
"-- \"{[10@2012-01-01, 4@2012-02-01, 6@2012-06-01, 6@2012-10-01)}\""
msgstr ""
"SELECT tmin(NoEmps) FROM Department;\n"
"-- \"{[10@2012-01-01, 4@2012-02-01, 6@2012-06-01, 6@2012-10-01)}\""

#. Tag: varname
#: manipulating_temporal_types.xml:1554
#, no-c-format
msgid "tmax"
msgstr "tmax"

#. Tag: para
#: manipulating_temporal_types.xml:1555
#, no-c-format
msgid "Temporal maximum"
msgstr "Máximo temporal"

#. Tag: varname
#: manipulating_temporal_types.xml:1556
#, no-c-format
msgid "tmax(ttype): {ttypei, ttypes}"
msgstr "tmax(ttype): {ttypei, ttypes}"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1557
#, no-c-format
msgid ""
"SELECT tmax(NoEmps) FROM Department;\n"
"-- \"{[10@2012-01-01, 12@2012-04-01, 6@2012-08-01, 6@2012-10-01)}\""
msgstr ""
"SELECT tmax(NoEmps) FROM Department;\n"
"-- \"{[10@2012-01-01, 12@2012-04-01, 6@2012-08-01, 6@2012-10-01)}\""

#. Tag: varname
#: manipulating_temporal_types.xml:1561
#, no-c-format
msgid "tsum"
msgstr "tsum"

#. Tag: para
#: manipulating_temporal_types.xml:1562
#, no-c-format
msgid "Temporal sum"
msgstr "Suma temporal"

#. Tag: varname
#: manipulating_temporal_types.xml:1563
#, no-c-format
msgid "tsum(tnumber): {tnumi, tnums}"
msgstr "tsum(tnumber): {tnumi, tnums}"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1564
#, no-c-format
msgid ""
"SELECT tsum(NoEmps) FROM Department;\n"
"-- \"{[10@2012-01-01, 14@2012-02-01, 16@2012-04-01, 18@2012-06-01, 6@2012-08-01,\n"
"6@2012-10-01)}\""
msgstr ""
"SELECT tsum(NoEmps) FROM Department;\n"
"-- \"{[10@2012-01-01, 14@2012-02-01, 16@2012-04-01, 18@2012-06-01, 6@2012-08-01,\n"
"6@2012-10-01)}\""

#. Tag: varname
#: manipulating_temporal_types.xml:1568
#, no-c-format
msgid "tavg"
msgstr "tavg"

#. Tag: para
#: manipulating_temporal_types.xml:1569
#, no-c-format
msgid "Temporal average"
msgstr "Promedio temporal"

#. Tag: varname
#: manipulating_temporal_types.xml:1570
#, no-c-format
msgid "tavg(tnumber): {tfloati, tfloats}"
msgstr "tavg(tnumber): {tfloati, tfloats}"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1571
#, no-c-format
msgid ""
"SELECT tavg(NoEmps) FROM Department;\n"
"-- \"{[10@2012-01-01, 10@2012-02-01), [7@2012-02-01, 7@2012-04-01),\n"
"[8@2012-04-01, 8@2012-06-01), [9@2012-06-01, 9@2012-08-01),\n"
"[6@2012-08-01, 6@2012-10-01)\""
msgstr ""
"SELECT tavg(NoEmps) FROM Department;\n"
"-- \"{[10@2012-01-01, 10@2012-02-01), [7@2012-02-01, 7@2012-04-01),\n"
"[8@2012-04-01, 8@2012-06-01), [9@2012-06-01, 9@2012-08-01),\n"
"[6@2012-08-01, 6@2012-10-01)\""

#. Tag: varname
#: manipulating_temporal_types.xml:1575
#, no-c-format
msgid "wmin"
msgstr "wmin"

#. Tag: para
#: manipulating_temporal_types.xml:1576
#, no-c-format
msgid "Window minimum"
msgstr "Mínimo de ventana"

#. Tag: varname
#: manipulating_temporal_types.xml:1577
#, no-c-format
msgid "wmin(tnumber, interval): {tnumi, tnums}"
msgstr "wmin(tnumber, interval): {tnumi, tnums}"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1578
#, no-c-format
msgid ""
"SELECT wmin(NoEmps, interval '2 days') FROM Department;\n"
"-- \"{[10@2012-01-01, 4@2012-04-01, 6@2012-06-03, 6@2012-10-03)}\""
msgstr ""
"SELECT wmin(NoEmps, interval '2 days') FROM Department;\n"
"-- \"{[10@2012-01-01, 4@2012-04-01, 6@2012-06-03, 6@2012-10-03)}\""

#. Tag: varname
#: manipulating_temporal_types.xml:1582
#, no-c-format
msgid "wmax"
msgstr "wmax"

#. Tag: para
#: manipulating_temporal_types.xml:1583
#, no-c-format
msgid "Window maximum"
msgstr "Máximo de ventana"

#. Tag: varname
#: manipulating_temporal_types.xml:1584
#, no-c-format
msgid "wmax(tnumber, interval): {tnumi, tnums}"
msgstr "wmax(tnumber, interval): {tnumi, tnums}"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1585
#, no-c-format
msgid ""
"SELECT wmax(NoEmps, interval '2 days') FROM Department;\n"
"-- \"{[10@2012-01-01, 12@2012-04-01, 6@2012-08-03, 6@2012-10-03)}\""
msgstr ""
"SELECT wmax(NoEmps, interval '2 days') FROM Department;\n"
"-- \"{[10@2012-01-01, 12@2012-04-01, 6@2012-08-03, 6@2012-10-03)}\""

#. Tag: varname
#: manipulating_temporal_types.xml:1589
#, no-c-format
msgid "wcount"
msgstr "wcount"

#. Tag: para
#: manipulating_temporal_types.xml:1590
#, no-c-format
msgid "Window count"
msgstr "Conteo de ventana"

#. Tag: varname
#: manipulating_temporal_types.xml:1591
#, no-c-format
msgid "wcount(tnumber, interval): {tinti, tints}"
msgstr "wcount(tnumber, interval): {tinti, tints}"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1592
#, no-c-format
msgid ""
"SELECT wcount(NoEmps, interval '2 days') FROM Department;\n"
"-- \"{[1@2012-01-01, 2@2012-02-01, 3@2012-04-01, 2@2012-04-03, 3@2012-06-01, 2@2012-06-03,\n"
"1@2012-08-03, 1@2012-10-03)}\""
msgstr ""
"SELECT wcount(NoEmps, interval '2 days') FROM Department;\n"
"-- \"{[1@2012-01-01, 2@2012-02-01, 3@2012-04-01, 2@2012-04-03, 3@2012-06-01, 2@2012-06-03,\n"
"1@2012-08-03, 1@2012-10-03)}\""

#. Tag: varname
#: manipulating_temporal_types.xml:1596
#, no-c-format
msgid "wsum"
msgstr "wsum"

#. Tag: para
#: manipulating_temporal_types.xml:1597
#, no-c-format
msgid "Window sum"
msgstr "Suma de ventana"

#. Tag: varname
#: manipulating_temporal_types.xml:1598
#, no-c-format
msgid "wsum(tint, interval): {tinti, tints}"
msgstr "wsum(tint, interval): {tinti, tints}"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1599
#, no-c-format
msgid ""
"SELECT wsum(NoEmps, interval '2 days') FROM Department;\n"
"-- \"{[10@2012-01-01, 14@2012-02-01, 26@2012-04-01, 16@2012-04-03, 22@2012-06-01,\n"
"18@2012-06-03, 6@2012-08-03, 6@2012-10-03)}\""
msgstr ""
"SELECT wsum(NoEmps, interval '2 days') FROM Department;\n"
"-- \"{[10@2012-01-01, 14@2012-02-01, 26@2012-04-01, 16@2012-04-03, 22@2012-06-01,\n"
"18@2012-06-03, 6@2012-08-03, 6@2012-10-03)}\""

#. Tag: varname
#: manipulating_temporal_types.xml:1603
#, no-c-format
msgid "wavg"
msgstr "wavg"

#. Tag: para
#: manipulating_temporal_types.xml:1604
#, no-c-format
msgid "Window average"
msgstr "Promedio de ventana"

#. Tag: varname
#: manipulating_temporal_types.xml:1605
#, no-c-format
msgid "wavg(tint, interval): {tfloati, tfloats}"
msgstr "wavg(tint, interval): {tfloati, tfloats}"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1606
#, no-c-format
msgid ""
"SELECT wavg(NoEmps, interval '2 days') FROM Department;\n"
"-- \"{[10@2012-01-01, 10@2012-02-01), [7@2012-02-01, 7@2012-04-01),\n"
"[8.66666666666667@2012-04-01, 8.66666666666667@2012-04-03),\n"
"[8@2012-04-03, 8@2012-06-01),\n"
"[7.33333333333333@2012-06-01, 7.33333333333333@2012-06-03),\n"
"[9@2012-06-03, 9@2012-08-03), [6@2012-08-03, 6@2012-10-03)}\""
msgstr ""
"SELECT wavg(NoEmps, interval '2 days') FROM Department;\n"
"-- \"{[10@2012-01-01, 10@2012-02-01), [7@2012-02-01, 7@2012-04-01),\n"
"[8.66666666666667@2012-04-01, 8.66666666666667@2012-04-03),\n"
"[8@2012-04-03, 8@2012-06-01),\n"
"[7.33333333333333@2012-06-01, 7.33333333333333@2012-06-03),\n"
"[9@2012-06-03, 9@2012-08-03), [6@2012-08-03, 6@2012-10-03)}\""

#. Tag: varname
#: manipulating_temporal_types.xml:1610
#, no-c-format
msgid "tcentroid"
msgstr "tcentroid"

#. Tag: para
#: manipulating_temporal_types.xml:1611
#, no-c-format
msgid "Temporal centroid"
msgstr "Centroide temporal"

#. Tag: varname
#: manipulating_temporal_types.xml:1612
#, no-c-format
msgid "tcentroid(tgeompoint): tgeompoint"
msgstr "tcentroid(tgeompoint): tgeompoint"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1613
#, no-c-format
msgid ""
"SELECT tcentroid(Trip) FROM Trips;\n"
"-- \"{[POINT(0 0)@2012-01-01 08:00:00+00, POINT(1 0)@2012-01-01 08:05:00+00),\n"
"[POINT(0.5 0)@2012-01-01 08:05:00+00, POINT(1.5 0.5)@2012-01-01 08:10:00+00,\n"
"POINT(2 1.5)@2012-01-01 08:15:00+00),\n"
"[POINT(2 2)@2012-01-01 08:15:00+00, POINT(3 3)@2012-01-01 08:20:00+00)}\""
msgstr ""
"SELECT tcentroid(Trip) FROM Trips;\n"
"-- \"{[POINT(0 0)@2012-01-01 08:00:00+00, POINT(1 0)@2012-01-01 08:05:00+00),\n"
"[POINT(0.5 0)@2012-01-01 08:05:00+00, POINT(1.5 0.5)@2012-01-01 08:10:00+00,\n"
"POINT(2 1.5)@2012-01-01 08:15:00+00),\n"
"[POINT(2 2)@2012-01-01 08:15:00+00, POINT(3 3)@2012-01-01 08:20:00+00)}\""

#. Tag: varname
#: manipulating_temporal_types.xml:1617
#, no-c-format
msgid "extent"
msgstr "extent"

#. Tag: para
#: manipulating_temporal_types.xml:1618
#, no-c-format
msgid "Bounding box extent"
msgstr ""
"Extensión del cuadro delimitador\n"
"\n"
" "

#. Tag: varname
#: manipulating_temporal_types.xml:1619
#, no-c-format
msgid "extent(temp): {period, tbox, stbox}"
msgstr "extent(temp): {period, tbox, stbox}"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1620
#, no-c-format
msgid ""
"SELECT extent(noEmps) FROM Department;\n"
"-- \"TBOX((4,2012-01-01 00:00:00+01),(12,2012-10-01 00:00:00+02))\"\n"
"SELECT extent(Trip) FROM Trips;\n"
"-- \"STBOX T((0,0,2012-01-01 08:00:00+01),(3,3,2012-01-01 08:20:00+01))\""
msgstr ""
"SELECT extent(noEmps) FROM Department;\n"
"-- \"TBOX((4,2012-01-01 00:00:00+01),(12,2012-10-01 00:00:00+02))\"\n"
"SELECT extent(Trip) FROM Trips;\n"
"-- \"STBOX T((0,0,2012-01-01 08:00:00+01),(3,3,2012-01-01 08:20:00+01))\""

#. Tag: title
#: manipulating_temporal_types.xml:1627
#, no-c-format
msgid "Utility Functions"
msgstr "Funciones de utilidad"

#. Tag: varname
#: manipulating_temporal_types.xml:1630
#, no-c-format
msgid "mobilitydb_version"
msgstr "mobilitydb_version"

#. Tag: para
#: manipulating_temporal_types.xml:1631
#, no-c-format
msgid "Version of the MobilityDB extension"
msgstr "Versión de la extensión MobilityDB"

#. Tag: varname
#: manipulating_temporal_types.xml:1632
#, no-c-format
msgid "mobilitydb_version(): text"
msgstr "mobilitydb_version(): text"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1633
#, no-c-format
msgid ""
"SELECT mobilitydb_version();\n"
"-- \"MobilityDB 1.0\""
msgstr ""
"SELECT mobilitydb_version();\n"
"-- \"MobilityDB 1.0\""

#. Tag: varname
#: manipulating_temporal_types.xml:1637
#, no-c-format
msgid "mobilitydb_full_version"
msgstr "mobilitydb_full_version"

#. Tag: para
#: manipulating_temporal_types.xml:1638
#, no-c-format
msgid "Versions of the MobilityDB extension and its dependencies"
msgstr "Versión de la extensión MobilityDB y de sus dependencias"

#. Tag: varname
#: manipulating_temporal_types.xml:1639
#, no-c-format
msgid "mobilitydb_full_version(): text"
msgstr "mobilitydb_full_version(): text"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1640
#, no-c-format
msgid ""
"SELECT mobilitydb_full_version();\n"
"-- \"MobilityDB 1.0 PostgreSQL 12.3 PostGIS 2.5\""
msgstr ""
"SELECT mobilitydb_full_version();\n"
"-- \"MobilityDB 1.0 PostgreSQL 12.3 PostGIS 2.5\""

#. Tag: title
#: manipulating_temporal_types.xml:1646
#, no-c-format
msgid "Indexing of Temporal Types"
msgstr "Indexación de tipos temporales"

#. Tag: para
#: manipulating_temporal_types.xml:1647
#, no-c-format
msgid ""
"GiST and SP-GiST indexes can be created for table columns of temporal types."
" The GiST index implements an R-tree for temporal alphanumeric types and for"
" temporal point types. The SP-GiST index implements a Quad-tree for temporal"
" alphanumeric types and an Oct-tree for temporal point types. Examples of "
"index creation are as follows:"
msgstr ""
"Se pueden crear índices GiST y SP-GiST para columnas de tabla de tipos "
"temporales. El índice GiST implementa un árbol R para tipos alfanuméricos "
"temporales y para tipos de puntos temporales. El índice SP-GiST implementa "
"un árbol cuádruple para tipos alfanuméricos temporales y un árbol óctuple "
"para tipos de puntos temporales. Ejemplos de creación de índices son los "
"siguientes:"

#. Tag: programlisting
#: manipulating_temporal_types.xml:1648
#, no-c-format
msgid ""
"CREATE INDEX Department_NoEmps_Gist_Idx ON Department USING Gist(NoEmps);\n"
"CREATE INDEX Trips_Trip_SPGist_Idx ON Trips USING SPGist(Trip);"
msgstr ""
"CREATE INDEX Department_NoEmps_Gist_Idx ON Department USING Gist(NoEmps);\n"
"CREATE INDEX Trips_Trip_SPGist_Idx ON Trips USING SPGist(Trip);"

#. Tag: para
#: manipulating_temporal_types.xml:1651
#, no-c-format
msgid ""
"The GiST and SP-GiST indexes store the bounding box for the temporal types. "
"As explained in <xref linkend=\"temporal_types\"/>, these are"
msgstr ""
"Los índices GiST y SP-GiST almacenan el cuadro delimitador para los tipos "
"temporales. Como se explica en <xref linkend=\"temporal_types\"/>, estos son"

#. Tag: para
#: manipulating_temporal_types.xml:1654
#, no-c-format
msgid ""
"the period <varname>period</varname> type for the <varname>tbool</varname> "
"and <varname>ttext</varname> types,"
msgstr ""
"el tipo <varname>period</varname> para los tipos <varname>tbool</varname> y "
"<varname>ttext</varname>,"

#. Tag: para
#: manipulating_temporal_types.xml:1658
#, no-c-format
msgid ""
"the <varname>tbox</varname> type for the <varname>tint</varname> and "
"<varname>tfloat</varname> types,"
msgstr ""
"el tipo <varname>tbox</varname> par los tipos <varname>tint</varname> "
"y<varname>tfloat</varname>,"

#. Tag: para
#: manipulating_temporal_types.xml:1662
#, no-c-format
msgid ""
"the <varname>stbox</varname> type for the <varname>tgeompoint</varname> and "
"<varname>tgeogpoint</varname> types."
msgstr ""
"el tipo <varname>stbox</varname> para los tipos "
"<varname>tgeompoint</varname> y <varname>tgeogpoint</varname>."

#. Tag: para
#: manipulating_temporal_types.xml:1667
#, no-c-format
msgid ""
"A GiST or SP-GiST index can accelerate queries involving the following "
"operators (see <xref linkend=\"operators_temporal_types\"/> for more "
"information):"
msgstr ""
"Un índice GiST o SP-GiST puede acelerar las consultas que involucran a los "
"siguientes operadores (consulte <xref linkend=\"operators_temporal_types\"/>"
" para obtener más información):"

#. Tag: para
#: manipulating_temporal_types.xml:1670
#, no-c-format
msgid ""
"<varname>&lt;&lt;</varname>, <varname>&amp;&lt;</varname>, "
"<varname>&amp;&gt;</varname>, <varname>&gt;&gt;</varname>, which only "
"consider the value dimension in temporal alphanumeric types,"
msgstr ""
"<varname>&lt;&lt;</varname>, <varname>&amp;&lt;</varname>, "
"<varname>&amp;&gt;</varname>, <varname>&gt;&gt;</varname>, que solo "
"consideran la dimensión de valores en tipos alfanuméricos temporales,"

#. Tag: para
#: manipulating_temporal_types.xml:1674
#, no-c-format
msgid ""
"<varname>&lt;&lt;</varname>, <varname>&amp;&lt;</varname>, "
"<varname>&amp;&gt;</varname>, <varname>&gt;&gt;</varname>, "
"<varname>&lt;&lt;|</varname>, <varname>&amp;&lt;|</varname>, "
"<varname>|&amp;&gt;</varname>, <varname>|&gt;&gt;</varname>, "
"<varname>&amp;&lt;/</varname>, <varname>&lt;&lt;/</varname>, "
"<varname>/&gt;&gt;</varname>, and <varname>/&amp;&gt;</varname>, which only "
"consider the spatial dimension in temporal point types,"
msgstr ""
"<varname>&lt;&lt;</varname>, <varname>&amp;&lt;</varname>, "
"<varname>&amp;&gt;</varname>, <varname>&gt;&gt;</varname>, "
"<varname>&lt;&lt;|</varname>, <varname>&amp;&lt;|</varname>, "
"<varname>|&amp;&gt;</varname>, <varname>|&gt;&gt;</varname>, "
"<varname>&amp;&lt;/</varname>, <varname>&lt;&lt;/</varname>, "
"<varname>/&gt;&gt;</varname>, and <varname>/&amp;&gt;</varname>, que solo "
"consideran la dimensión espacial en tipos de puntos temporales,"

#. Tag: para
#: manipulating_temporal_types.xml:1678
#, no-c-format
msgid ""
"<varname>&amp;&lt;#</varname>, <varname>&lt;&lt;#</varname>, "
"<varname>#&gt;&gt;</varname>, <varname>#&amp;&gt;</varname>, which only "
"consider the time dimension for all temporal types,"
msgstr ""
"<varname>&amp;&lt;#</varname>, <varname>&lt;&lt;#</varname>, "
"<varname>#&gt;&gt;</varname>, <varname>#&amp;&gt;</varname>, que solo "
"consideran la dimensión temporal para todos los tipos temporales,"

#. Tag: para
#: manipulating_temporal_types.xml:1682
#, no-c-format
msgid ""
"<varname>&amp;&amp;</varname>, <varname>@&gt;</varname>, "
"<varname>&lt;@</varname>, and <varname>~=</varname>, which consider as many "
"dimensions as they are shared by the indexed column and the query argument. "
"These operators work on bounding boxes (that is, <varname>period</varname>, "
"<varname>tbox</varname>, or <varname>stbox</varname>), not the entire "
"values."
msgstr ""
"<varname>&amp;&amp;</varname>, <varname>@&gt;</varname>, "
"<varname>&lt;@</varname> y <varname>~=</varname>, que consideran tantas "
"dimensiones como compartan la columna indexada y el argumento de consulta. "
"Estos operadores trabajan en cuadros delimitadores (es "
"decir,<varname>period</varname>, <varname>tbox</varname>, o "
"<varname>stbox</varname>), no los valores completos."

#. Tag: para
#: manipulating_temporal_types.xml:1687
#, no-c-format
msgid ""
"In addition, a GiST index can accelerate nearest neighbor queries involving "
"the <varname>|=|</varname> operator."
msgstr ""
"Además, un índice GiST puede acelerar las consultas de vecinos más cercanos "
"que involucran el operador <varname>|=|</varname>."

#. Tag: para
#: manipulating_temporal_types.xml:1689
#, no-c-format
msgid ""
"For example, given the index defined above on the "
"<varname>Department</varname> table and a query that involves a condition "
"with the <varname>&amp;&amp;</varname> (overlaps) operator, if the right "
"argument is a temporal float then both the value and the time dimensions are"
" considered for filtering the tuples of the relation, while if the right "
"argument is a float value, a float range, or a time type, then either the "
"value or the time dimension will be used for filtering the tuples of the "
"relation. Furthermore, a bounding box can be constructed from a value/range "
"and/or a timestamp/period, which can be used for filtering the tuples of the"
" relation. Examples of queries using the index on the "
"<varname>Department</varname> table defined above are given next."
msgstr ""
"Por ejemplo, dado el índice definido anteriormente en la tabla "
"<varname>Department</varname> y una consulta que implica una condición con "
"el operador <varname>&amp;&amp;</varname> (superposición), si el argumento "
"derecho es un flotante temporal, entonces se consideran tanto el valor como "
"las dimensiones de tiempo para filtrar las tuplas de la relación, mientras "
"que si el argumento derecho es un valor flotante, un rango flotante o un "
"tipo de tiempo, entonces el valor o la dimensión de tiempo se utilizará para"
" filtrar las tuplas de la relación. Además, se puede construir un cuadro "
"delimitador a partir de un valor/rango y/o una marca de tiempo/período, que "
"se puede usar para filtrar las tuplas de la relación. Ejemplos de consultas "
"que utilizan el índice en la tabla <varname>Department</varname> definida "
"anteriormente se dan a continuación."

#. Tag: programlisting
#: manipulating_temporal_types.xml:1690
#, no-c-format
msgid ""
"SELECT * FROM Department WHERE NoEmps &amp;&amp; 5;\n"
"SELECT * FROM Department WHERE NoEmps &amp;&amp; intrange '[1, 5)';\n"
"SELECT * FROM Department WHERE NoEmps &amp;&amp; timestamptz '2012-04-01';\n"
"SELECT * FROM Department WHERE NoEmps &amp;&amp; period '[2012-04-01, 2012-05-01)';\n"
"SELECT * FROM Department WHERE NoEmps &amp;&amp;\n"
"tbox(intrange '[1, 5)', period '[2012-04-01, 2012-05-01)');\n"
"SELECT * FROM Department WHERE NoEmps &amp;&amp;\n"
"tfloat '{[1@2012-01-01, 1@2012-02-01), [5@2012-04-01, 5@2012-05-01)}';"
msgstr ""
"SELECT * FROM Department WHERE NoEmps &amp;&amp; 5;\n"
"SELECT * FROM Department WHERE NoEmps &amp;&amp; intrange '[1, 5)';\n"
"SELECT * FROM Department WHERE NoEmps &amp;&amp; timestamptz '2012-04-01';\n"
"SELECT * FROM Department WHERE NoEmps &amp;&amp; period '[2012-04-01, 2012-05-01)';\n"
"SELECT * FROM Department WHERE NoEmps &amp;&amp;\n"
"tbox(intrange '[1, 5)', period '[2012-04-01, 2012-05-01)');\n"
"SELECT * FROM Department WHERE NoEmps &amp;&amp;\n"
"tfloat '{[1@2012-01-01, 1@2012-02-01), [5@2012-04-01, 5@2012-05-01)}';"

#. Tag: para
#: manipulating_temporal_types.xml:1693
#, no-c-format
msgid ""
"Similarly, examples of queries using the index on the "
"<varname>Trips</varname> table defined above are given next."
msgstr ""
"Del mismo modo, los ejemplos de consultas que utilizan el índice en la tabla"
" <varname>Trips</varname> definida anteriormente se dan a continuación."

#. Tag: programlisting
#: manipulating_temporal_types.xml:1694
#, no-c-format
msgid ""
"SELECT * FROM Trips WHERE Trip &amp;&amp; geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))';\n"
"SELECT * FROM Trips WHERE Trip &amp;&amp; timestamptz '2001-01-01';\n"
"SELECT * FROM Trips WHERE Trip &amp;&amp; period '[2001-01-01, 2001-01-05)';\n"
"SELECT * FROM Trips WHERE Trip &amp;&amp;\n"
"stbox(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))', period '[2001-01-01, 2001-01-05]');\n"
"SELECT * FROM Trips WHERE Trip &amp;&amp;\n"
"tgeompoint '{[Point(0 0)@2001-01-01, Point(1 1)@2001-01-02, Point(1 1)@2001-01-05)}';"
msgstr ""
"SELECT * FROM Trips WHERE Trip &amp;&amp; geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))';\n"
"SELECT * FROM Trips WHERE Trip &amp;&amp; timestamptz '2001-01-01';\n"
"SELECT * FROM Trips WHERE Trip &amp;&amp; period '[2001-01-01, 2001-01-05)';\n"
"SELECT * FROM Trips WHERE Trip &amp;&amp;\n"
"stbox(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))', period '[2001-01-01, 2001-01-05]');\n"
"SELECT * FROM Trips WHERE Trip &amp;&amp;\n"
"tgeompoint '{[Point(0 0)@2001-01-01, Point(1 1)@2001-01-02, Point(1 1)@2001-01-05)}';"

#. Tag: para
#: manipulating_temporal_types.xml:1697
#, no-c-format
msgid ""
"Finally, B-tree indexes can be created for table columns of all temporal "
"types. For this index type, the only useful operation is equality. There is "
"a B-tree sort ordering defined for values of temporal types, with "
"corresponding <varname>&lt;</varname>, <varname>&lt;=</varname>, "
"<varname>&gt;</varname>, <varname>&gt;=</varname> and operators, but the "
"ordering is rather arbitrary and not usually useful in the real world. "
"B-tree support for temporal types is primarily meant to allow sorting "
"internally in queries, rather than creation of actual indexes."
msgstr ""
"Finalmente, se pueden crear índices de árbol B para columnas de tabla de "
"todos los tipos temporales. Para este tipo de índice, la única operación "
"útil es la igualdad. Hay un orden de clasificación de árbol B definido para "
"valores de tipos temporales, con los correspondientes operadores "
"<varname>&lt;</varname>, <varname>&lt;=</varname>, <varname>&gt;</varname>, "
"y <varname>&gt;=</varname>, pero el orden es bastante arbitrario y no suele "
"ser útil en el mundo real. El soporte de árbol B para tipos temporales está "
"destinado principalmente a permitir la clasificación interna en consultas, "
"en lugar de la creación de índices reales."

#. Tag: para
#: manipulating_temporal_types.xml:1699
#, no-c-format
msgid ""
"In order to speed up several of the functions in <xref "
"linkend=\"manipulating_temporal_types\"/>, a bounding box comparison that "
"make uses of the available indexes can be added in the "
"<varname>WHERE</varname> clause of queries. For example, this would be "
"typically the case for the functions that project the temporal types to the "
"value/spatial and/or time dimensions. This will filter out the tuples with "
"an index as shown in the following query."
msgstr ""
"Para acelerar varias de las funciones en <xref "
"linkend=\"manipulating_temporal_types\"/>, se puede agregar una comparación "
"de cuadro delimitador que hace uso de los índices disponibles en la cláusula"
" <varname>WHERE</varname> de las consultas. Por ejemplo, este sería "
"típicamente el caso de las funciones que proyectan los tipos temporales a "
"las dimensiones de valor/espacio y/o tiempo. Esto filtrará las tuplas con un"
" índice como se muestra en la siguiente consulta."

#. Tag: programlisting
#: manipulating_temporal_types.xml:1700
#, no-c-format
msgid ""
"SELECT atPeriod(T.Trip, period(2001-01-01, 2001-01-02))\n"
"FROM Trips T\n"
"-- Bouding box index filtering\n"
"WHERE T.Trip &amp;&amp; period(2001-01-01, 2001-01-02)"
msgstr ""
"SELECT atPeriod(T.Trip, period(2001-01-01, 2001-01-02))\n"
"FROM Trips T\n"
"-- Bouding box index filtering\n"
"WHERE T.Trip &amp;&amp; period(2001-01-01, 2001-01-02)"

#. Tag: para
#: manipulating_temporal_types.xml:1703
#, no-c-format
msgid ""
"In the case of temporal points, all spatial relationships with the "
"&ldquo;ever&rdquo; semantics (see <xref "
"linkend=\"topological_relationships_temporal_points\"/>), excepted "
"<varname>disjoint</varname>and <varname>relate</varname>, will automatically"
" include a bounding box comparison that will make use of any indexes that "
"are available on the temporal points. For this reason, the first version of "
"the relationships is typically used for filtering the tuples with the help "
"of an index when computing the temporal relationships as shown in the "
"following query."
msgstr ""
"En el caso de los puntos temporales, todas las relaciones espaciales con la "
"semántica posible (ver <xref "
"linkend=\"topological_relationships_temporal_points\"/>), "
"exceptuadas<varname>disjoint</varname>y <varname>relate</varname>, incluirá "
"automáticamente una comparación de cuadro delimitador que hará uso de "
"cualquier índice que esté disponible en los puntos temporales. Por esta "
"razón, la primera versión de las relaciones se usa típicamente para filtrar "
"las tuplas con la ayuda de un índice al calcular las relaciones temporales "
"como se muestra en la siguiente consulta."

#. Tag: programlisting
#: manipulating_temporal_types.xml:1704
#, no-c-format
msgid ""
"SELECT tintersects(T.Trip, R.Geom)\n"
"FROM Trips T, Regions R\n"
"-- Bouding box index filtering\n"
"WHERE intersects(T.Trip, R.Geom);"
msgstr ""
"SELECT tintersects(T.Trip, R.Geom)\n"
"FROM Trips T, Regions R\n"
"-- Filtro de índice de cuadro delimitador\n"
"WHERE intersects(T.Trip, R.Geom);"

#. Tag: title
#: manipulating_temporal_types.xml:1709
#, no-c-format
msgid "Statistics and Selectivity for Temporal Types"
msgstr "Estadística y selectividad para tipos temporales"

#. Tag: title
#: manipulating_temporal_types.xml:1711
#, no-c-format
msgid "Statistics Collection"
msgstr "Colecta de estadísticas"

#. Tag: para
#: manipulating_temporal_types.xml:1712
#, no-c-format
msgid ""
"The PostgreSQL planner relies on statistical information about the contents "
"of tables in order to generate the most efficient execution plan for "
"queries. These statistics include a list of some of the most common values "
"in each column and a histogram showing the approximate data distribution in "
"each column. For large tables, a random sample of the table contents is "
"taken, rather than examining every row. This enables large tables to be "
"analyzed in a small amount of time. The statistical information is gathered "
"by the <varname>ANALYZE</varname> command and stored in the "
"<varname>pg_statistic</varname> catalog table. Since different kinds of "
"statistics may be appropriate for different kinds of data, the table only "
"stores very general statistics (such as number of null values) in dedicated "
"columns. Everything else is stored in five &ldquo;slots&rdquo;, which are "
"couples of array columns that store the statistics for a column of an "
"arbitrary type."
msgstr ""
"El planificador de PostgreSQL se basa en información estadística sobre el "
"contenido de las tablas para generar el plan de ejecución más eficiente para"
" las consultas. Estas estadísticas incluyen una lista de algunos de los "
"valores más comunes en cada columna y un histograma que muestra la "
"distribución de datos aproximada en cada columna. Para tablas grandes, se "
"toma una muestra aleatoria del contenido de la tabla, en lugar de examinar "
"cada fila. Esto permite analizar tablas grandes en poco tiempo. La "
"información estadística es recopilada por el comando "
"<varname>ANALYZE</varname> y es almacenada en la tabla de catálogo "
"<varname>pg_statistic</varname>. Dado que diferentes tipos de estadísticas "
"pueden ser apropiados para diferentes tipos de datos, la tabla solo almacena"
" estadísticas muy generales (como el número de valores nulos) en columnas "
"dedicadas. Todo lo demás se almacena en cinco &ldquo;slots&rdquo;, que son "
"pares de columnas de matriz que almacenan las estadísticas de una columna de"
" un tipo arbitrario."

#. Tag: para
#: manipulating_temporal_types.xml:1714
#, no-c-format
msgid ""
"The statistics collected for time types and temporal types are based on "
"those collected by PostgreSQL for scalar types and range types. For scalar "
"types, like <varname>float</varname>, the following statistics are "
"collected:"
msgstr ""
"Las estadísticas recopiladas para tipos de tiempo y tipos temporales se "
"basan en las recopiladas por PostgreSQL para tipos escalares y tipos de "
"rango. Para tipos escalares, como <varname>float</varname>, se recopilan las"
" siguientes estadísticas:"

#. Tag: para
#: manipulating_temporal_types.xml:1717
#, no-c-format
msgid "fraction of null values,"
msgstr "fracción de valores nulos,"

#. Tag: para
#: manipulating_temporal_types.xml:1720
#, no-c-format
msgid "average width, in bytes, of non-null values,"
msgstr "ancho promedio, en bytes, de valores no nulos,"

#. Tag: para
#: manipulating_temporal_types.xml:1723
#, no-c-format
msgid "number of different non-null values,"
msgstr "número de diferentes valores no nulos,"

#. Tag: para
#: manipulating_temporal_types.xml:1726
#, no-c-format
msgid "array of most common values and array of their frequencies,"
msgstr "matriz de los valores más comunes y matriz de sus frecuencias,"

#. Tag: para
#: manipulating_temporal_types.xml:1729
#, no-c-format
msgid "histogram of values, where the most common values are excluded,"
msgstr "histograma de valores, donde se excluyen los valores más comunes,"

#. Tag: para
#: manipulating_temporal_types.xml:1732
#, no-c-format
msgid "correlation between physical and logical row ordering."
msgstr "correlación entre el orden de filas físico y lógico."

#. Tag: para
#: manipulating_temporal_types.xml:1737
#, no-c-format
msgid ""
"For range types, like <varname>tstzrange</varname>, three additional "
"histograms are collected:"
msgstr ""
"Para los tipos de rango, como <varname>tstzrange</varname>, se recopilan "
"tres histogramas adicionales:"

#. Tag: para
#: manipulating_temporal_types.xml:1740
#, no-c-format
msgid "length histogram of non-empty ranges,"
msgstr "histograma de longitud de rangos no vacíos,"

#. Tag: para
#: manipulating_temporal_types.xml:1743
#, no-c-format
msgid "histograms of lower and upper bounds."
msgstr "histogramas de límites superior e inferior."

#. Tag: para
#: manipulating_temporal_types.xml:1748
#, no-c-format
msgid ""
"For geometries, in addition to (1)&#x2013;(3), the following statistics are "
"collected:"
msgstr ""
"Para geometrías, además de (1)&#x2013;(3), se recopilan las siguientes "
"estadísticas:"

#. Tag: para
#: manipulating_temporal_types.xml:1751
#, no-c-format
msgid ""
"number of dimensions of the values, N-dimensional bounding box, number of "
"rows in the table, number of rows in the sample, number of non-null values,"
msgstr ""
"número de dimensiones de los valores, cuadro delimitador N-dimensional, "
"número de filas en la tabla, número de filas en la muestra, número de "
"valores no nulos,"

#. Tag: para
#: manipulating_temporal_types.xml:1754
#, no-c-format
msgid ""
"N-dimensional histogram that divides the bounding box into a number of cells"
" and keeps the proportion of values that intersects with each cell."
msgstr ""
"Histograma N-dimensional que divide el cuadro delimitador en varias celdas y"
" mantiene la proporción de valores que se cruzan con cada celda."

#. Tag: para
#: manipulating_temporal_types.xml:1759
#, no-c-format
msgid ""
"The statistics collected for the new time types "
"<varname>timestampset</varname>, <varname>period</varname>, and "
"<varname>periodset</varname> replicate those collected by PostgreSQL for the"
" <varname>tstzrange</varname>. This is clear for the "
"<varname>period</varname> type, which is equivalent to "
"<varname>tszrange</varname>, excepted that periods cannot be empty. For the "
"<varname>timestampset</varname> and the <varname>periodset</varname> types, "
"a value is converted into its bounding box which is a "
"<varname>period</varname>, then the <varname>period</varname> statistics are"
" collected."
msgstr ""
"Las estadísticas recopiladas para los nuevos tipos de tiempo "
"<varname>timestampset</varname>, <varname>period</varname>, y "
"<varname>periodset</varname> replican las recopiladas por PostgreSQL para "
"<varname>tstzrange</varname>. Esto es claro para el tipo "
"<varname>period</varname>, que es equivalente a <varname>tszrange</varname>,"
" excepto que los períodos no pueden estar vacíos. Para los tipos "
"<varname>timestampset</varname> y <varname>periodset</varname>, un valor se "
"convierte en su cuadro delimitador que es un <varname>period</varname>, y "
"luego se recopilan las estadísticas del <varname>period</varname>."

#. Tag: para
#: manipulating_temporal_types.xml:1761
#, no-c-format
msgid ""
"The statistics collected for temporal types depend on their duration and "
"their base type. In addition to statistics (1)&#x2013;(3) that are collected"
" for all temporal types, statistics are collected for the value dimension "
"and the time dimension independently. More precisely, the following "
"statistics are collected for the time dimension:"
msgstr ""
"Las estadísticas recopiladas para los tipos temporales dependen de su "
"duración y su tipo base. Además de las estadísticas (1)&#x2013;(3) que se "
"recopilan para todos los tipos temporales, las estadísticas se recopilan "
"para la dimensión de valor y la dimensión de tiempo de forma independiente. "
"Más precisamente, se recopilan las siguientes estadísticas para la dimensión"
" de tiempo:"

#. Tag: para
#: manipulating_temporal_types.xml:1764
#, no-c-format
msgid ""
"For temporal instant values, the statistics (4)&#x2013;(6) are collected for"
" the timestamps."
msgstr ""
"Para valores instantáneos temporales, las estadísticas (4)&#x2013;(6) se "
"recopilan para las marcas de tiempo."

#. Tag: para
#: manipulating_temporal_types.xml:1768
#, no-c-format
msgid ""
"For all other durations, the statistics (7)&#x2013;(8) are collected for the"
" (bounding box) periods."
msgstr ""
"Para todas las demás duraciones, las estadísticas (7)&#x2013;(8) se "
"recopilan para los períodos delimitadores."

#. Tag: para
#: manipulating_temporal_types.xml:1773
#, no-c-format
msgid "The following statistics are collected for the value dimension:"
msgstr ""
"Las siguientes estadísticas se recopilan para la dimensión de valores:"

#. Tag: para
#: manipulating_temporal_types.xml:1776
#, no-c-format
msgid ""
"For temporal types with stepwise interpolation (that is, temporal types "
"whose base type is <varname>tbool</varname>, <varname>ttext</varname>, or "
"<varname>tint</varname>):"
msgstr ""
"Para tipos temporales con interpolación escalonada (es decir, tipos "
"temporales cuyo tipo base es<varname>tbool</varname>, "
"<varname>ttext</varname>, o <varname>tint</varname>):"

#. Tag: para
#: manipulating_temporal_types.xml:1779
#, no-c-format
msgid ""
"For the instant duration, the statistics (4)&#x2013;(6) are collected for "
"the values."
msgstr ""
"Para la duración instantánea, las estadísticas (4)&#x2013;(6) se recopilan "
"para los valores."

#. Tag: para
#: manipulating_temporal_types.xml:1783
#, no-c-format
msgid ""
"For all other durations, the statistics (7)&#x2013;(8) are collected for the"
" values."
msgstr ""
"Para todas las demás duraciones, las estadísticas  (7)&#x2013;(8) se "
"recopilan para los valores."

#. Tag: para
#: manipulating_temporal_types.xml:1790
#, no-c-format
msgid "For temporal float types (that is, <varname>tfloat</varname>):"
msgstr ""
"Para tipos temporales flotantes (es decir, <varname>tfloat</varname>):"

#. Tag: para
#: manipulating_temporal_types.xml:1793
#, no-c-format
msgid ""
"For instant values, the statistics (4)&#x2013;(6) are collected for the "
"values."
msgstr ""
"Para valores instantáneos, las estadísticas (4)&#x2013;(6) se recopilan para"
" los valores."

#. Tag: para
#: manipulating_temporal_types.xml:1796
#, no-c-format
msgid ""
"For all other durations, the statistics (7)&#x2013;(8) are collected for the"
" (bounding) value ranges."
msgstr ""
"Para todas las demás duraciones, las estadísticas (7)&#x2013;(8) se "
"recopilan por los rangos delimitadores de valores."

#. Tag: para
#: manipulating_temporal_types.xml:1803
#, no-c-format
msgid ""
"For temporal point types (that is, <varname>tgeompoint</varname> and "
"<varname>tgeogpoint</varname>) the statistics (9)&#x2013;(10) are collected "
"for the points."
msgstr ""
"Para tipos de puntos temporales (es decir, <varname>tgeompoint</varname> "
"y<varname>tgeogpoint</varname>) las estadísticas (9)&#x2013;(10) se compilan"
" para los puntos."

#. Tag: title
#: manipulating_temporal_types.xml:1810
#, no-c-format
msgid "Selectivity Estimation of Operators"
msgstr "Estimación de la selectividad de los operadores"

#. Tag: para
#: manipulating_temporal_types.xml:1811
#, no-c-format
msgid ""
"Boolean operators in PostgreSQL can be associated with two selectivity "
"functions, which compute how likely a value of a given type will match a "
"given criterion. These selectivity functions rely on the statistics "
"collected. There are two types of selectivity functions. The restriction "
"selectivity functions try to estimate the percentage of the rows in a table "
"that satisfy a <varname>WHERE</varname>-clause condition of the form "
"<varname>column OP constant</varname>. The join selectivity functions try to"
" estimate the percentage of the rows in a table that satisfy a "
"<varname>WHERE</varname>-clause condition of the form "
"<varname>table1.column1 OP table2.column2</varname>."
msgstr ""
"Los operadores booleanos en PostgreSQL se pueden asociar con dos funciones "
"de selectividad, que calculan la probabilidad de que un valor de un tipo "
"dado coincida con un criterio dado. Estas funciones de selectividad se basan"
" en las estadísticas recopiladas. Hay dos tipos de funciones de "
"selectividad. Las funciones de selectividad de restricción intentan estimar "
"el porcentaje de filas en una tabla que satisfacen una condición en la "
"cláusula <varname>WHERE</varname>-de la forma <varname>column OP "
"constant</varname>.Las funciones de selectividad de unión intentan estimar "
"el porcentaje de filas en una tabla que satisfacen una condición en la "
"cláusula <varname>WHERE</varname> de la forma <varname>table1.column1 OP "
"table2.column2</varname>."

#. Tag: para
#: manipulating_temporal_types.xml:1813
#, no-c-format
msgid ""
"MobilityDB defines 23 classes of Boolean operators (such as "
"<varname>=</varname>, <varname>&lt;</varname>, "
"<varname>&amp;&amp;</varname>, <varname>&lt;&lt;</varname>, etc.), each of "
"which can have as left or right arguments a built-in type (such as "
"<varname>int</varname>, <varname>timestamptz</varname>, etc.) or a new type "
"(such as <varname>period</varname>, <varname>tintseq</varname>, etc.). As a "
"consequence, there is a very high number of operators with different "
"arguments to be considered for the selectivity functions. The approach taken"
" was to group these combinations into classes corresponding to the value and"
" temporal features. The classes correspond to the type of statistics "
"collected as explained in the previous section."
msgstr ""
"MobilityDB define 23 clases de operadores booleanos "
"(como<varname>=</varname>, <varname>&lt;</varname>, "
"<varname>&amp;&amp;</varname>, <varname>&lt;&lt;</varname>, etc.), cada uno "
"de los cuales puede tener como argumentos izquierdo o derecho un tipo "
"incorporado (como <varname>int</varname>, <varname>timestamptz</varname>, "
"etc.) o un nuevo tipo (como <varname>period</varname>, "
"<varname>tintseq</varname>, etc.). Como consecuencia, existe un número muy "
"elevado de operadores con diferentes argumentos a considerar para las "
"funciones de selectividad. El enfoque adoptado fue agrupar estas "
"combinaciones en clases correspondientes al valor y características "
"temporales. Las clases corresponden al tipo de estadísticas recopiladas como"
" se explica en la sección anterior."

#. Tag: para
#: manipulating_temporal_types.xml:1815
#, no-c-format
msgid ""
"Currently, only restriction selectivity functions are implemented for "
"temporal types, while join selectivity functions give a default selectivity "
"value depending on the operator. It is planned to implement joint "
"selectivity functions in the future."
msgstr ""
"Actualmente, solo están implementadas las funciones de selectividad de "
"restricción para tipos temporales, mientras que las funciones de "
"selectividad de unión dan un valor de selectividad predeterminado según el "
"operador. Está previsto implementar las funciones de selectividad de unión "
"en el futuro."
