<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [

<!ENTITY geography_support
"<inlinemediaobject>
	<imageobject><imagedata fileref='images/world.pdf' width='16pt' /></imageobject>
	<imageobject><imagedata fileref='images/world.svg' width='16pt' /></imageobject>
	<imageobject><imagedata fileref='images/world.png' width='16pt' /></imageobject>
 </inlinemediaobject>
">

<!ENTITY Z_support
"<inlinemediaobject>
	<imageobject><imagedata fileref='images/cube.pdf' width='16pt' /></imageobject>
	<imageobject><imagedata fileref='images/cube.svg' width='16pt' /></imageobject>
	<imageobject><imagedata fileref='images/cube.png' width='16pt' /></imageobject>
 </inlinemediaobject>
">

<!ENTITY python_support
"<inlinemediaobject>
	<imageobject><imagedata fileref='images/python.pdf' width='16pt' /></imageobject>
	<imageobject><imagedata fileref='images/python.svg' width='16pt' /></imageobject>
	<imageobject><imagedata fileref='images/python.png' width='16pt' /></imageobject>
 </inlinemediaobject>
">

]>
<book lang="en">
	<bookinfo>
		<title>MobilityDB Manual</title>

		<author>
			<firstname>Esteban</firstname>
			<surname>Zim&aacute;nyi</surname>
			<affiliation>
				<orgname>Universit&eacute; libre de Bruxelles, Belgium</orgname>
			</affiliation>
		</author>

		<pubdate>07.01.2020</pubdate>
		<abstract>
			<para>MobilityDB is an extension to the PostgreSQL object-relational database system and its spatial extension PostGIS. It allows temporal and spatio-temporal objects to be stored in the database, that is, objects whose attribute values and/or location evolves in time. MobilityDB includes functions for analysis and processing of temporal and spatio-temporal objects and provides support for GiST and SP-GiST indexes. MobilityDB is open source and its code is available on <ulink url="https://github.com/ULB-CoDE-WIT/MobilityDB">Github</ulink>. An adapter for the Python programming language is also available on <ulink url="https://github.com/ULB-CoDE-WIT/python-mobilityDB">Github</ulink>.</para>

			<para>
				<inlinemediaobject>
					<imageobject>
						<imagedata fileref='images/mobilitydb-logo.png' width='200pt' />
					</imageobject>
				</inlinemediaobject>
			</para>

			<para>
			MobilityDB is developed by the Computer &amp; Decision Engineering Department of the Universit&eacute; Libre de Bruxelles (ULB) under the direction of Prof. Esteban Zim&aacute;nyi. ULB is an OGC Associate Member.
			</para>

			<para>
				<inlinemediaobject>
					<imageobject>
						<imagedata fileref='images/OGC_Associate_Member_3DR.png' width='100pt' />
					</imageobject>
				</inlinemediaobject>
			</para>
		</abstract>
	</bookinfo>

	<chapter id ="introduction">
		<title>Introduction</title>

		<para>MobilityDB is an extension of <ulink url="http://postgresql.org">PostgreSQL</ulink> and <ulink url="http://postgis.net">PostGIS</ulink> that provides temporal types. Such types are data types that represent the evolution on time of values of some element type, called the base type of the temporal type. For instance, temporal integers may be used to represent the evolution on time of the number of employees of a department. In this case, the data type is &ldquo;temporal integer&rdquo; and &ldquo;integer&rdquo; is the base type. Similarly, a temporal float may be used to represent the evolution on time of the temperature of a room. As another example, a temporal point may be used to represent the evolution on time of the location of a car, as reported by GPS devices. Temporal types are useful because representing values that evolve in time is essential in many applications, for example in mobility applications. Furthermore, the operators on the base types (such as arithmetic operators and aggregation for integers and floats, spatial relationships and distance for geometries) can be intuitively generalized when the values evolve in time.</para>

		<para>MobilityDB provides the following temporal types: <varname>tbool</varname>, <varname>tint</varname>, <varname>tfloat</varname>, <varname>ttext</varname>, <varname>tgeompoint</varname> and <varname>tgeogpoint</varname>. These temporal types are based, respectively, on the <varname>bool</varname>, <varname>int</varname>, <varname>float</varname>, and <varname>text</varname> base types provided by PostgreSQL, and on the <varname>geometry</varname> and <varname>geography</varname> base types provided by PostGIS (restricted to 2D or 3D points).<footnote><para>Although 4D temporal points can be represented, the M dimension is currently not taken into account.</para></footnote> Furthermore, MobilityDB uses four time types to represent extents of time: the <varname>timestamptz</varname> type provided by PostgreSQL and three new types which are <varname>period</varname>, <varname>timestampset</varname>, and <varname>periodset</varname>. In addition, two range types are defined in MobilityDB: <varname>intrange</varname> and <varname>floatrange</varname>.</para>
		
	</chapter>
	
	<chapter id="time_types_range_types">
		<title>Time Types and Range Types</title>

		<para>Temporal types are based on four time types: the <varname>timestamptz</varname> type provided by PostgreSQL and three new types which are <varname>period</varname>, <varname>timestampset</varname>, and <varname>periodset</varname>.</para>

		<para>The <varname>period</varname> type is a specialized version of the <varname>tstzrange</varname> (short for timestamp with time zone range) type provided by PostgreSQL. Type <varname>period</varname> has similar functionality as type <varname>tstzrange</varname> but has a more efficient implementation, in particular it is of fixed length while the <varname>tstzrange</varname> type is of variable length. Furthermore, empty periods and infinite bounds are not allowed in <varname>period</varname> values, while they are allowed in <varname>tstzrange</varname> values.</para>

		<para>A value of the <varname>period</varname> type has two bounds, the lower bound and the upper bound, which are <varname>timestamptz</varname> values. The bounds can be inclusive or exclusive. An inclusive bound means that the boundary instant is included in the period, while an exclusive bound means that the boundary instant is not included in the period. In the text form of a <varname>period</varname> value, inclusive and exclusive lower bounds are represented, respectively, by &ldquo;<varname>[</varname>&rdquo; and &ldquo;<varname>(</varname>&rdquo;. Likewise, inclusive and exclusive upper bounds are represented, respectively, by &ldquo;<varname>]</varname>&rdquo; and &ldquo;<varname>)</varname>&rdquo;. In a <varname>period</varname> value, the lower bound must be less than or equal to the upper bound. A <varname>period</varname> value with equal and inclusive bounds is called an instant period and corresponds to a <varname>timestamptz</varname> value. Examples of <varname>period</varname> values are as follows:
			<programlisting>
SELECT period '[2012-01-01 08:00:00, 2012-01-03 09:30:00)';
-- Instant period
SELECT period '[2012-01-01 08:00:00, 2012-01-01 08:00:00]';
-- Erroneous periods
SELECT period '[2012-01-01 08:10:00, 2012-01-01 08:00:00]'; -- invalid bounds
SELECT period '[2012-01-01 08:00:00, 2012-01-01 08:00:00)'; -- empty period
			</programlisting>
		</para>

		<para>The <varname>timestampset</varname> type represents a set of different <varname>timestamptz</varname> values. A <varname>timestampset</varname> value must contain at least one element, in which case it corresponds to a <varname>timestamptz</varname> value. The elements composing a <varname>timestampset</varname> value must be ordered. Examples of <varname>timestampset</varname> values are as follows:
			<programlisting>
SELECT timestampset '{2012-01-01 08:00:00, 2012-01-03 09:30:00}';
-- Singleton timestampset
SELECT timestampset '{2012-01-01 08:00:00}';
-- Erroneous timestampset values
SELECT timestampset '{2012-01-01 08:10:00, 2012-01-01 08:00:00}'; -- unordered elements
SELECT timestampset '{2012-01-01 08:00:00, 2012-01-01 08:00:00}'; -- duplicate elements
			</programlisting>
		</para>

		<para>Finally, the <varname>periodset</varname> type represents a set of disjoint <varname>period</varname> values. A <varname>periodset</varname> value must contain at least one element, in which case it corresponds to a <varname>period</varname> value. The elements composing a <varname>periodset</varname> value must be ordered. Examples of <varname>periodset</varname> values are as follows:
			<programlisting>
SELECT periodset '{[2012-01-01 08:00:00, 2012-01-01 08:10:00],
[2012-01-01 08:20:00, 2012-01-01 08:40:00]}';
-- Singleton periodset
SELECT periodset '{[2012-01-01 08:00:00, 2012-01-01 08:10:00]}';
-- Erroneous periodset values
SELECT periodset '{[2012-01-01 08:20:00, 2012-01-01 08:40:00],
	[2012-01-01 08:00:00, 2012-01-01 08:10:00]}';
-- unordered elements
SELECT periodset '{[2012-01-01 08:00:00, 2012-01-01 08:10:00],
	[2012-01-01 08:05:00, 2012-01-01 08:15:00]}';
-- overlapping elements
			</programlisting>
		</para>

		<para>Values of the <varname>periodset</varname> type are converted into a <emphasis role="strong">normal</emphasis> form so that equivalent values have identical representations. For this, consecutive adjacent period values are merged when possible. An example of transformation into a normal form is as follows:
			<programlisting>
SELECT periodset '{[2012-01-01 08:00:00, 2012-01-01 08:10:00),
	[2012-01-01 08:10:00, 2012-01-01 08:10:00], (2012-01-01 08:10:00, 2012-01-01 08:20:00]}';
-- "{[2012-01-01 08:00:00+00,2012-01-01 08:20:00+00]}"
			</programlisting>
		</para>

		<para>Besides the built-in range types provided by PostgreSQL, two additional range types are defined, <varname>intrange</varname> (another name for <varname>int4range</varname>) and <varname>floatrange</varname>.</para>

		<sect1 id ="functions_operations_time_types">
			<title>Functions and Operators for Time Types and Range Types</title>
				
			<para>We present next the functions and operators for time types. These functions and operators are polymorphic, that is, their arguments may be of several types, and the result type may depend on the type of the arguments. To express this in the signature of the operators, we use the following notation:
				<itemizedlist>
					<listitem>
						<para>A set of types such as <varname>{period, timestampset, periodset}</varname> represents any of the types listed,</para>
					</listitem>
					<listitem>
						<para><varname>time</varname> represents any time type, that is, <varname>timestamptz</varname>, <varname>period</varname>, <varname>timestampset</varname>, or <varname>periodset</varname>,</para>
					</listitem>
					<listitem>
						<para><varname>number</varname> represents any numeric type, that is, <varname>int</varname> or <varname>float</varname>,</para>
					</listitem>
					<listitem>
						<para><varname>range</varname> represents any numeric range type, that is, <varname>intrange</varname> or <varname>floatrange</varname>.</para>
					</listitem>
					<listitem>
						<para><varname>type[]</varname> represents an array of <varname>type</varname>.
						</para>
					</listitem>
				</itemizedlist>
			</para>
				
			<para>As an example, the signature of the contains operator (<varname>@&gt;</varname>) is as follows:
				<programlisting>
{timestampset, period, periodset} @&gt; time
				</programlisting>
			In the following, for conciseness, the time part of the timestamps is omitted in the examples. Recall that in that case PostgreSQL assumes the time <varname>00:00:00</varname>.
			</para>

			<sect2>
				<title>Constructor Functions</title>

				<para>The <varname>period</varname> type has a constructor function that accepts two or four arguments. The two-argument form constructs a period in <emphasis role="strong">normal</emphasis> form, that is, with inclusive lower bound and exclusive upper bound. The four-argument form constructs a period with bounds specified by the third and fourth arguments, which are Boolean values stating, respectively, whether the left and right bounds are inclusive or not.
				</para>
				<itemizedlist>
					<listitem id="period">
						<para>Constructor for <varname>period</varname></para>
						<para><varname>period(timestamptz, timestamptz, left_inc = true, right_inc = false): period</varname></para>
						<programlisting>
-- It is assumed that the lower bound is inclusive and the upper bound is exclusive.
SELECT period('2012-01-01 08:00:00', '2012-01-03 08:00:00');
-- Period defined with four arguments
SELECT period('2012-01-01 08:00:00', '2012-01-03 09:30:00', false, true);
						</programlisting>
					</listitem>
				</itemizedlist>

				<para>The <varname>timestampset</varname> type has a constructor function that accepts a single argument which is an array of <varname>timestamptz</varname> values.
				</para>
				<itemizedlist>
					<listitem id="timestampset">
						<para>Constructor for <varname>timestampset</varname></para>
						<para><varname>timestampset(timestamptz[]): timestampset</varname></para>
						<programlisting>
SELECT timestampset(ARRAY[timestamptz '2012-01-01 08:00:00', '2012-01-03 09:30:00']);
-- "{2012-01-01 08:00:00+00, 2012-01-03 09:30:00+00}"
						</programlisting>
					</listitem>
				</itemizedlist>

				<para>The <varname>periodset</varname> type has a constructor function that accepts a single argument which is an array of <varname>period</varname> values.
				</para>
				<itemizedlist>
					<listitem id="periodset">
						<para>Constructor for <varname>periodset</varname></para>
						<para><varname>periodset(period[]): periodset</varname></para>
						<programlisting>
SELECT periodset(ARRAY[period '[2012-01-01 08:00:00, 2012-01-01 08:10:00]',
-- '[2012-01-01 08:20:00, 2012-01-01 08:40:00]']);
						</programlisting>
					</listitem>
				</itemizedlist>
			</sect2>

			<sect2>
				<title>Casting</title>
				<para>Values of the <varname>timestamptz</varname> type, the <varname>tstzrange</varname> type, or the time types can be converted to one another using an explicit <varname>CAST</varname> or using the <varname>::</varname> notation.
				</para>

				<itemizedlist>
					<listitem id="timestamptz_cast">
						<para>Cast a <varname>timestamptz</varname> to another time type</para>
						<para><varname>timestamptz::timestampset</varname></para>
						<para><varname>timestamptz::period</varname></para>
						<para><varname>timestamptz::periodset</varname></para>
						<programlisting>
SELECT CAST(timestamptz '2012-01-01 08:00:00' AS timestampset);
-- "{2012-01-01 08:00:00+01}"
SELECT CAST(timestamptz '2012-01-01 08:00:00' AS period);
-- "[2012-01-01 08:00:00+01, 2012-01-01 08:00:00+01]"
SELECT CAST(timestamptz '2012-01-01 08:00:00' AS periodset);
-- "{[2012-01-01 08:00:00+01, 2012-01-01 08:00:00+01]}"
						</programlisting>
					</listitem>
					<listitem id="timestampset_cast">
						<para>Cast a <varname>timestampset</varname> to a <varname>periodset</varname></para>
						<para><varname>timestampset::periodset</varname></para>
						<programlisting>
SELECT CAST(timestampset '{2012-01-01 08:00:00, 2012-01-01 08:15:00, 
	2012-01-01 08:25:00}' AS periodset);
-- "{[2012-01-01 08:00:00+01, 2012-01-01 08:00:00+01], 
	[2012-01-01 08:15:00+01, 2012-01-01 08:15:00+01], 
	[2012-01-01 08:25:00+01, 2012-01-01 08:25:00+01]}"
						</programlisting>
					</listitem>
					<listitem id="period_cast">
						<para>Cast a <varname>period</varname> to another type</para>
						<para><varname>period::periodset</varname></para>
						<para><varname>period::tstzrange</varname></para>
						<programlisting>
SELECT period '[2012-01-01 08:00:00, 2012-01-01 08:30:00)'::periodset;
-- "{[2012-01-01 08:00:00+01, 2012-01-01 08:30:00+01)}"
SELECT period '[2012-01-01 08:00:00, 2012-01-01 08:30:00)'::tstzrange;
-- "["2012-01-01 08:00:00+01","2012-01-01 08:30:00+01")"
						</programlisting>
					</listitem>
					<listitem id="tstzrange_cast">
						<para>Cast a <varname>tstzrange</varname> to a <varname>period</varname></para>
						<para><varname>tstzrange::period</varname></para>
						<programlisting>
SELECT tstzrange '[2012-01-01 08:00:00, 2012-01-01 08:30:00)'::period;
-- "[2012-01-01 08:00:00+01, 2012-01-01 08:30:00+01)"
						</programlisting>
					</listitem>
				</itemizedlist>
			</sect2>

			<sect2>
				<title>Accessor Functions</title>

				<itemizedlist>
					<listitem id="time_memSize">
					<para>Get the memory size in bytes</para>
						<para><varname>memSize({timestampset, periodset}): integer</varname></para>
						<programlisting>
SELECT memSize(timestampset '{2012-01-01, 2012-01-02, 2012-01-03}');
-- 104
SELECT memSize(periodset '{[2012-01-01, 2012-01-02], [2012-01-03, 2012-01-04], 
	[2012-01-05, 2012-01-06]}');
-- 136
						</programlisting>
					</listitem>

					<listitem id="lower">
					<para>Get the lower bound</para>
					<para><varname>lower(period): timestamptz</varname></para>
					<programlisting>
SELECT lower(period '[2011-01-01, 2011-01-05)');
-- "2011-01-01"
					</programlisting>
					</listitem>

					<listitem id="upper">
						<para>Get the upper bound</para>
						<para><varname>upper(period): timestamptz</varname></para>
						<programlisting>
SELECT upper(period '[2011-01-01, 2011-01-05)');
-- "2011-01-05"
						</programlisting>
					</listitem>

					<listitem id="lower_inc">
						<para>Is the lower bound inclusive?</para>
						<para><varname>lower_inc(period): boolean</varname></para>
						<programlisting>
SELECT lower_inc(period '[2011-01-01, 2011-01-05)');
-- true
						</programlisting>
					</listitem>

					<listitem id="upper_inc">
						<para>Is the upper bound inclusive?</para>
						<para><varname>upper_inc(period): boolean</varname></para>
						<programlisting>
SELECT upper_inc(period '[2011-01-01, 2011-01-05)');
-- false
						</programlisting>
					</listitem>

					<listitem id="time_timespan">
						<para>Get the timespan</para>
						<para><varname>timespan({period, periodset}): interval</varname></para>
						<programlisting>
SELECT timespan(period '[2012-01-01, 2012-01-03)');
-- "2 days"
SELECT timespan(periodset '{[2012-01-01, 2012-01-03), [2012-01-04, 2012-01-05)}');
-- "3 days"
						</programlisting>
					</listitem>

					<listitem id="time_period">
						<para>Get the period on which the timestamp set or period set is defined ignoring the potential time gaps</para>
						<para><varname>period({timestampset, periodset}): period</varname></para>
						<programlisting>
SELECT period(timestampset '{2012-01-01, 2012-01-03, 2012-01-05}');
-- "[2012-01-01, 2012-01-05]"
SELECT period(periodset '{[2012-01-01, 2012-01-02), [2012-01-03, 2012-01-04)}');
-- "[2012-01-01, 2012-01-04)"
						</programlisting>
					</listitem>

					<listitem id="time_numTimestamps">
						<para>Get the number of different timestamps</para>
						<para><varname>numTimestamps({timestampset, periodset}): int</varname></para>
						<programlisting>
SELECT numTimestamps(timestampset '{2012-01-01, 2012-01-03, 2012-01-04}');
-- 3
SELECT numTimestamps(periodset '{[2012-01-01, 2012-01-03), (2012-01-03, 2012-01-05)}');
-- 3
						</programlisting>
					</listitem>

					<listitem id="time_startTimestamp">
						<para>Get the start timestamp</para>
						<para><varname>startTimestamp({timestampset, periodset}): timestamptz</varname></para>
						<para>The function does not take into account whether the bounds are inclusive or not.</para>
						<programlisting>
SELECT startTimestamp(periodset '{[2012-01-01, 2012-01-03), (2012-01-03, 2012-01-05)}');
-- "2012-01-01"
						</programlisting>
					</listitem>

					<listitem id="time_endTimestamp">
						<para>Get the end timestamp</para>
						<para><varname>endTimestamp({timestampset, periodset}): timestamptz</varname></para>
						<para>The function does not take into account whether the bounds are inclusive or not.</para>
						<programlisting>
SELECT endTimestamp(periodset '{[2012-01-01, 2012-01-03), (2012-01-03, 2012-01-05)}');
-- "2012-01-05"
						</programlisting>
					</listitem>

					<listitem id="time_timestampN">
						<para>Get the n-th different timestamp</para>
						<para><varname>timestampN({timestampset, periodset}, int): timestamptz</varname></para>
						<para>The function does not take into account whether the bounds are inclusive or not.</para>
						<programlisting>
SELECT timestampN(periodset '{[2012-01-01, 2012-01-03), (2012-01-03, 2012-01-05)}', 3);
-- "2012-01-04"
						</programlisting>
					</listitem>

					<listitem id="time_timestamps">
						<para>Get the different timestamps</para>
						<para><varname>timestamps({timestampset, periodset}): timestampset</varname></para>
						<para>The function does not take into account whether the bounds are inclusive or not.</para>
						<programlisting>
SELECT timestamps(periodset '{[2012-01-01, 2012-01-03), (2012-01-03, 2012-01-05)}');
-- "{"2012-01-01", "2012-01-03", "2012-01-05"}"
						</programlisting>
					</listitem>

					<listitem id="numPeriods">
						<para>Get the number of periods</para>
						<para><varname>numPeriods(periodset): int</varname></para>
						<programlisting>
SELECT numPeriods(periodset '{[2012-01-01, 2012-01-03), [2012-01-04, 2012-01-04],
	[2012-01-05, 2012-01-06)}');
-- 3
						</programlisting>
					</listitem>

					<listitem id="startPeriod">
						<para>Get the start period</para>
						<para><varname>startPeriod(periodset): period</varname></para>
						<programlisting>
SELECT startPeriod(periodset '{[2012-01-01, 2012-01-03), [2012-01-04, 2012-01-04],
	[2012-01-05, 2012-01-06)}');
-- "[2012-01-01,2012-01-03)"
						</programlisting>
					</listitem>

					<listitem id="endPeriod">
						<para>Get the end period</para>
						<para><varname>endPeriod(periodset): period</varname></para>
						<programlisting>
SELECT endPeriod(periodset '{[2012-01-01, 2012-01-03), [2012-01-04, 2012-01-04],
	[2012-01-05, 2012-01-06)}');
-- "[2012-01-05,2012-01-06)"
						</programlisting>
					</listitem>

					<listitem id="periodN">
						<para>Get the n-th period</para>
						<para><varname>periodN(periodset, int): period</varname></para>
						<programlisting>
SELECT periodN(periodset '{[2012-01-01, 2012-01-03), [2012-01-04, 2012-01-04],
	[2012-01-05, 2012-01-06)}', 2);
-- "[2012-01-04,2012-01-04]"
						</programlisting>
					</listitem>

					<listitem id="periods">
						<para>Get the periods</para>
						<para><varname>periods(periodset): period[]</varname></para>
						<programlisting>
SELECT periods(periodset '{[2012-01-01, 2012-01-03), [2012-01-04, 2012-01-04], 
	[2012-01-05, 2012-01-06)}');
-- "{"[2012-01-01,2012-01-03)","[2012-01-04,2012-01-04]","[2012-01-05,2012-01-06)"}"
						</programlisting>
					</listitem>

					<listitem id="time_shift">
						<para>Shift the time value by an interval</para>
						<para><varname>shift({timestampset,period,periodset}): {timestampset,period,periodset}</varname></para>
						<programlisting>
SELECT shift(timestampset '{2001-01-01, 2001-01-03, 2001-01-05}', '1 day'::interval);
-- "{2001-01-02, 2001-01-04, 2001-01-06}"
SELECT shift(period '[2001-01-01, 2001-01-03]', '1 day'::interval);
-- "[2001-01-02, 2001-01-04]"
SELECT shift(periodset '{[2001-01-01, 2001-01-03], [2001-01-04, 2001-01-05]}', 
	'1 day'::interval);
-- "{[2001-01-02, 2001-01-04], [2001-01-05, 2001-01-06]}"
						</programlisting>
					</listitem>
				</itemizedlist>
			</sect2>
			
			<sect2 id="time_comp_operators">
				<title>Comparison Operators</title>

				<para>The comparison operators (<varname>=</varname>, <varname>&lt;</varname>, and so on) require that the left and right arguments be of the same type. Excepted equality and inequality, the other comparison operators are not useful in the real world but allow B-tree indexes to be constructed on time types.</para>

				<para>The comparison operators available for the time types are given next.</para>

				<itemizedlist>
					<listitem id="time_eq">
						<para>Are the time values equal?</para>
						<para><varname>time = time</varname></para>
						<programlisting>
SELECT period '[2012-01-01, 2012-01-04)' = period '[2012-01-01, 2012-01-04)';
-- true
						</programlisting>
					</listitem>

					<listitem id="time_ne">
						<para>Are the time values different?</para>
						<para><varname>time &lt;&gt; time</varname></para>
						<programlisting>
SELECT period '[2012-01-01, 2012-01-04)' &lt;&gt; period '[2012-01-03, 2012-01-05)';
-- true
						</programlisting>
					</listitem>

					<listitem id="time_lt">
						<para>Is the first time value less than the second one?</para>
						<para><varname>time &lt; time</varname></para>
						<programlisting>
SELECT timestampset '{2012-01-01, 2012-01-04}' &lt; timestampset '{2012-01-01, 2012-01-05}';
-- true
						</programlisting>
					</listitem>

					<listitem id="time_gt">
						<para>Is the first time value greater than the second one?</para>
						<para><varname>time &gt; time</varname></para>
						<programlisting>
SELECT period '[2012-01-03, 2012-01-04)' &gt; period '[2012-01-02, 2012-01-05)';
-- true
						</programlisting>
					</listitem>

					<listitem id="time_le">
						<para>Is the first time value less than or equal to the second one?</para>
						<para><varname>time &lt;= time</varname></para>
						<programlisting>
SELECT periodset '{[2012-01-01, 2012-01-04)}' &lt;= 
	periodset '{[2012-01-01, 2012-01-05), [2012-01-06, 2012-01-07)}';
-- true
						</programlisting>
					</listitem>

					<listitem id="time_ge">
						<para>Is the first time value greater than or equal to the second one?</para>
						<para><varname>time &gt;= time</varname></para>
						<programlisting>
SELECT period '[2012-01-03, 2012-01-05)' &gt;= period '[2012-01-03, 2012-01-04)';
-- true
						</programlisting>
					</listitem>
				</itemizedlist>
			</sect2>
			
			<sect2 id="time_set_operators">
				<title>Set Operators</title>

				<para>The set operators available for the time types are given next.</para>

				<itemizedlist>
					<listitem id="time_union">
						<para>Union of the time values</para>
						<para><varname>time + time</varname></para>
						<programlisting>
SELECT timestampset '{2011-01-01, 2011-01-03, 2011-01-05}' +
	timestampset '{2011-01-03, 2011-01-06}';
-- "{2011-01-01, 2011-01-03, 2011-01-05, 2011-01-06}"
SELECT period '[2011-01-01, 2011-01-05)' + period '[2011-01-03, 2011-01-07)';
-- "[2011-01-01, 2011-01-07)"
SELECT periodset '{[2011-01-01, 2011-01-03), [2011-01-04, 2011-01-05)}' +
	period '[2011-01-03, 2011-01-04)';
-- "{[2011-01-01, 2011-01-05)}"
						</programlisting>
					</listitem>

					<listitem id="time_intersection">
						<para>Intersection of the time values</para>
						<para><varname>time * time</varname></para>
						<programlisting>
SELECT timestampset '{2011-01-01, 2011-01-03}' * timestampset '{2011-01-03, 2011-01-05}';
-- "{2011-01-03}"
SELECT period '[2011-01-01, 2011-01-05)' * period '[2011-01-03, 2011-01-07)';
-- "[2011-01-03, 2011-01-05)"
						</programlisting>
					</listitem>

					<listitem id="time_difference">
						<para>Difference of the time values</para>
						<para><varname>time - time</varname></para>
						<programlisting>
SELECT period '[2011-01-01, 2011-01-05)' - period '[2011-01-03, 2011-01-07)';
-- "[2011-01-01, 2011-01-03)"
SELECT period '[2011-01-01, 2011-01-05]' - period '[2011-01-03, 2011-01-04]'
-- "{[2011-01-01,2011-01-03), (2011-01-04,2011-01-05]}"
SELECT periodset '{[2011-01-01, 2011-01-06], [2011-01-07, 2011-01-10]}' -
	periodset '{[2011-01-02, 2011-01-03], [2011-01-04, 2011-01-05], 
	[2011-01-08, 2011-01-09]}';
-- "{[2011-01-01,2011-01-02), (2011-01-03,2011-01-04), (2011-01-05,2011-01-06],
[2011-01-07,2011-01-08), (2011-01-09,2011-01-10]}"
						</programlisting>
					</listitem>
				</itemizedlist>
			</sect2>
			

			<sect2 id="time_topo_operators">
				<title>Topological Operators</title>
				<para>In PostgreSQL, the range operators <varname>&lt;&lt;</varname>, <varname>&amp;&lt;</varname>, <varname>&gt;&gt;</varname>, <varname>&amp;&gt;</varname>, and <varname>-|-</varname> only accept a range as left or right argument. We extended these operators for numeric ranges so that one argument may be an integer or a float.</para>

				<para>The topological operators available for the time types and range types are given next.</para>

				<itemizedlist>
					<listitem id="time_overlaps">
						<para>Do the time values overlap (have points in common)?</para>
						<para><varname>{timestampset, period, periodset} &amp;&amp; {timestampset, period, periodset}</varname></para>
						<programlisting>
SELECT period '[2011-01-01, 2011-01-05)' &amp;&amp; period '[2011-01-02, 2011-01-07)';
-- true
						</programlisting>
					</listitem>

					<listitem id="time_contains">
						<para>Does the first time value contain the second one?</para>
						<para><varname>{timestampset, period, periodset} @&gt; time</varname></para>
						<programlisting>
SELECT period '[2011-01-01, 2011-05-01)' @&gt; period '[2011-02-01, 2011-03-01)';
-- true
SELECT period '[2011-01-01, 2011-05-01)' @&gt; timestamptz '2011-02-01';
-- true
						</programlisting>
					</listitem>

					<listitem id="time_containedby">
						<para>Is the first time value contained by the second one?</para>
						<para><varname>time &lt;@ {timestampset, period, periodset}</varname></para>
						<programlisting>
SELECT period '[2011-02-01, 2011-03-01)' &lt;@ period '[2011-01-01, 2011-05-01)';
-- true
SELECT timestamptz '2011-01-10' &lt;@ period '[2011-01-01, 2011-05-01)';
-- true
						</programlisting>
					</listitem>

					<listitem id="time_adjacent">
						<para>Is the first time value adjacent to the second one?</para>
						<para><varname>time -|- time</varname></para>
						<programlisting>
SELECT period '[2011-01-01, 2011-01-05)' -|- timestampset '{2011-01-05, 2011-01-07}';
-- true
SELECT periodset '{[2012-01-01, 2012-01-02]}' -|- period '[2012-01-02, 2012-01-03)';
-- false
						</programlisting>
					</listitem>

					<listitem id="range_left">
						<para>Is the first numeric or range value strictly left of the second one?</para>
						<para><varname>{number, range} &lt;&lt; {number, range}</varname></para>
						<programlisting>
SELECT intrange '[15, 20)' &lt;&lt; 20;
-- true
						</programlisting>
					</listitem>

					<listitem id="range_right">
						<para>Is the first numeric or range value strictly right of the second one?</para>
						<para><varname>{number, range} &gt;&gt; {number, range}</varname></para>
						<programlisting>
SELECT intrange '[15, 20)' &gt;&gt; 10;
-- true
						</programlisting>
					</listitem>

					<listitem id="range_overleft">
						<para>Is the first numeric or range value not to the right of the second one?</para>
						<para><varname>{number, range} &amp;&lt; {number, range}</varname></para>
						<programlisting>
SELECT intrange '[15, 20)' &amp;&lt; 18;
-- false
						</programlisting>
					</listitem>

					<listitem id="range_overright">
						<para>Is the first numeric or range value not to the left of the second one?</para>
						<para><varname>{number, range} &amp;&gt; {number, range}</varname></para>
						<programlisting>
SELECT period '[2011-01-01, 2011-01-03)' &amp;&gt; period '[2011-01-01, 2011-01-05)';
-- true
SELECT intrange '[15, 20)' &amp;&gt; 30;
-- true
						</programlisting>
					</listitem>

					<listitem id="range_adjacent">
						<para>Is the first numeric or range value adjacent to the second one?</para>
						<para><varname>{number, range} -|- {number, range}</varname></para>
						<programlisting>
SELECT floatrange '[15, 20)' -|- 20;
-- true
						</programlisting>
					</listitem>

					<listitem id="time_before">
						<para>Is the first time value scritly before the second one?</para>
						<para><varname>time &lt;&lt;# time</varname></para>
						<programlisting>
SELECT period '[2011-01-01, 2011-01-03)' &lt;&lt;# timestampset '{2011-01-03, 2011-01-05}';
-- true
						</programlisting>
					</listitem>

					<listitem id="time_after">
						<para>Is the first time value strictly after the second one?</para>
						<para><varname>time #&gt;&gt; time</varname></para>
						<programlisting>
SELECT period '[2011-01-04, 2011-01-05)' #&gt;&gt; 
	periodset '{[2011-01-01, 2011-01-04), [2011-01-05, 2011-01-06)}';
-- true
						</programlisting>
					</listitem>

					<listitem id="time_overbefore">
						<para>Is the first time value not after the second one?</para>
						<para><varname>time &amp;&lt;# time</varname></para>
						<programlisting>
SELECT timestampset '{2011-01-02, 2011-01-05}' &amp;&lt;# period '[2011-01-01, 2011-01-05)';
-- false
						</programlisting>
					</listitem>

					<listitem id="time_overafter">
						<para>Is the first time value not before the second one?</para>
						<para><varname>time #&amp;&gt; time</varname></para>
						<programlisting>
SELECT timestamp '2011-01-01' #&amp;&gt; period '[2011-01-01, 2011-01-05)';
-- true
						</programlisting>
					</listitem>
				</itemizedlist>
			</sect2>
		</sect1>

		<sect1 id ="indexing_time_types">
			<title>Indexing of Time Types</title>
			<para>GiST and SP-GiST indexes can be created for table columns of the <varname>timestampset</varname>, <varname>period</varname>, and <varname>periodset</varname> types. An example of creation of a GiST index in a column <varname>during</varname> of type <varname>period</varname> in a table <varname>reservation</varname> is as follows:
					<programlisting>
CREATE TABLE reservation (ReservationID integer PRIMARY KEY, RoomID integer, 
	During period);
CREATE INDEX reservation_during_idx ON reservation USING GIST(during);
					</programlisting>
			</para>
			<para>A GiST or SP-GiST index can accelerate queries involving the following operators: <varname>=</varname>, <varname>&amp;&amp;</varname>, <varname>&lt;@</varname>, <varname>@&gt;</varname>, <varname>-|-</varname>, <varname>&lt;&lt;</varname>, <varname>&gt;&gt;</varname>, <varname>&amp;&lt;</varname>, and <varname>&amp;&gt;</varname>.</para>
			<para>In addition, B-tree indexes can be created for table columns of a time type. For these index types, basically the only useful operation is equality. There is a B-tree sort ordering defined for values of time types, with corresponding <varname>&lt;</varname> and <varname>&gt;</varname> operators, but the ordering is rather arbitrary and not usually useful in the real world. The B-tree support is primarily meant to allow sorting internally in queries, rather than creation of actual indexes.</para>
		</sect1>
	</chapter>

	<chapter id="temporal_types">
		<title>Temporal Types</title>
		<para>There are six built-in temporal types, <varname>tbool</varname>, <varname>tint</varname>, <varname>tfloat</varname>, <varname>ttext</varname>, <varname>tgeompoint</varname>, and <varname>tgeogpoint</varname>, which are, respectively, based on the base types <varname>bool</varname>, <varname>int</varname>, <varname>float</varname>, <varname>text</varname>, <varname>geometry</varname>, and <varname>geography</varname> (the last two types restricted to 2D or 3D points with Z dimension). 
		</para>

		<para>The <emphasis role="strong">interpolation</emphasis> of a temporal value states how the value evolves between successive instants. The interpolation is <emphasis role="strong">stepwise</emphasis> when the value remains constant between two successive instants. For example, the number of employees of a department may be represented with a temporal integer, which indicates that its value is constant between two time instants. On the other hand, the interpolation is <emphasis role="strong">linear</emphasis> when the value evolves linearly between two successive instants. For example, the temperature of a room may be represented with a temporal float, which indicates that the values are known at the two time instants but continuously evolve between them. Similarly, the location of a vehicule may be represented by a temporal point where the location between two consecutive GPS readings is obtained by linear interpolation. Temporal types based on discrete base types, that is the <varname>tbool</varname>, <varname>tint</varname>, or <varname>ttext</varname> evolve necesssarily in a stepwise manner. On the other hand, temporal types based on continuous base types, that is <varname>tfloat</varname>, <varname>tgeompoint</varname>, or <varname>tgeogpoint</varname> may evolve in a stepwise or linear manner.</para>

		<para>The <emphasis role="strong">duration</emphasis> of a temporal value states the temporal extent at which the evolution of values is recorded. Temporal values come in four durations, namely, instant, instant set, sequence, and sequence set.</para>

		<para>A temporal value of <emphasis role="strong">instant</emphasis> duration (briefly, an instant value) represents the value at a time instant, for example
			<programlisting>
SELECT tfloat '17@2018-01-01 08:00:00';
			</programlisting>
		</para>

		<para>A temporal value of <emphasis role="strong">instant set</emphasis> duration (briefly, an instant set value) represents the evolution of the value at a set of time instants, where the values between these instants are unknown. An example is as follows:
			<programlisting>
SELECT tfloat '{17@2018-01-01 08:00:00, 17.5@2018-01-01 08:05:00, 18@2018-01-01 08:10:00}';
			</programlisting>
		</para>

		<para>A temporal value of <emphasis role="strong">sequence</emphasis> duration (briefly, a sequence value) represents the evolution of the value during a sequence of time instants, where the values between these instants are interpolated using either a stepwise or a linear function (see below). An example is as follows:
			<programlisting>
SELECT tint '(10@2018-01-01 08:00:00, 20@2018-01-01 08:05:00, 15@2018-01-01 08:10:00]';
			</programlisting>
		</para>
				
		<para>As can be seen, a value of a type with sequence duration has a lower and an upper bound that can be inclusive (represented by &lsquo;<varname>[</varname>&rsquo; and &lsquo;<varname>]</varname>&rsquo;) or exclusive (represented by &lsquo;<varname>(</varname>' and &lsquo;<varname>)</varname>'). A temporal sequence value with a single instant such as
			<programlisting>
SELECT tint '[10@2018-01-01 08:00:00]';
			</programlisting>
		is called an <emphasis role="strong">instantaneous sequence</emphasis>. In that case, both bounds must be inclusive.
		</para>
				
		<para>The value of a temporal sequence is interpreted by assuming that the period of time defined by every pair of consecutive values <varname>v1@t1</varname> and <varname>v2@t2</varname> is lower inclusive and upper exclusive, unless they are the first or the last instants of the sequence and in that case the bounds of the whole sequence apply. Furthermore, the value taken by the temporal sequence between two consecutive instants depends on whether the interpolation is stepwise or linear. For example, the temporal sequence above represents that the value is <varname>10</varname> during <varname>(2018-01-01 08:00:00, 2018-01-01 08:05:00)</varname>, <varname>20</varname> during <varname>[2018-01-01 08:05:00, 2018-01-01 08:10:00)</varname>, and <varname>15</varname> at the end instant <varname>2018-01-01 08:10:00</varname>. On the other hand, the following temporal sequence
			<programlisting>
SELECT tfloat '(10@2018-01-01 08:00:00, 20@2018-01-01 08:05:00, 15@2018-01-01 08:10:00]';
			</programlisting>
		represents that the value evolves linearly from <varname>10</varname> to <varname>20</varname> during <varname>(2018-01-01 08:00:00, 2018-01-01 08:05:00)</varname> and evolves from <varname>20</varname> to <varname>15</varname> during <varname>[2018-01-01 08:05:00, 2018-01-01 08:10:00]</varname>.</para>

		<para>Finally, a temporal value of <emphasis role="strong">sequence set</emphasis> duration (briefly, a sequence set value) represents the evolution of the value at a set of sequences, where the values between these sequences are unknown. An example is as follows:
			<programlisting>
SELECT tfloat '{[17@2018-01-01 08:00:00, 17.5@2018-01-01 08:05:00],
	[18@2018-01-01 08:10:00, 18@2018-01-01 08:15:00]}';
			</programlisting>
		</para>
				
		<para>Temporal values with instant or sequence duration are called <emphasis role="strong">temporal unit values</emphasis>, while temporal values with instant set or sequence set duration are called <emphasis role="strong">temporal set values</emphasis>. Temporal set values can be thought of as an array of the corresponding unit values. Temporal set values must be <emphasis role="strong">uniform</emphasis>, that is, they must be constructed from unit values of the same base type and the same duration.</para>

			<para>Temporal sequence values are converted into a <emphasis role="strong">normal</emphasis> form so that equivalent values have identical representations. For this, consecutive instant values are merged when possible. For stepwise interpolation, three consecutive instant values can be merged into two if they have the same value. For linear interpolation, three consecutive instant values can be merged into two if the linear functions defining the evolution of values are the same. Examples of transformation into a normal form are as follows.
				<programlisting>
SELECT tint '[1@2001-01-01, 2@2001-01-03, 2@2001-01-04, 2@2001-01-05)';
-- "[1@2001-01-01 00:00:00+00, 2@2001-01-03 00:00:00+00, 2@2001-01-05 00:00:00+00)"
SELECT tgeompoint '[Point(1 1)@2001-01-01 08:00:00, Point(1 1)@2001-01-01 08:05:00,
	Point(1 1)@2001-01-01 08:10:00)';
-- "[Point(1 1)@2001-01-01 08:00:00, Point(1 1)@2001-01-01 08:10:00)"
SELECT tfloats(ARRAY[tfloat '[1@2001-01-01, 2@2001-01-03, 3@2001-01-05]']);
-- "{[1@2001-01-01 00:00:00+00, 3@2001-01-05 00:00:00+00]}"
SELECT tgeompoint '[Point(1 1)@2001-01-01 08:00:00, Point(2 2)@2001-01-01 08:05:00,
	Point(3 3)@2001-01-01 08:10:00]';
-- "[Point(1 1)@2001-01-01 08:00:00, Point(3 3)@2001-01-01 08:10:00]"
				</programlisting>
			</para>

			<para> Similary, temporal sequence set values are converted into a normal form. For this, consecutive sequence values are merged when possible. Examples of transformation into a normal form are as follows.
				<programlisting>
SELECT tints(ARRAY[tint '[1@2001-01-01, 1@2001-01-03)', '[2@2001-01-03, 2@2001-01-05)']);
-- '{[1@2001-01-01 00:00:00+00, 2@2001-01-03 00:00:00+00, 2@2001-01-05 00:00:00+00)}'
SELECT tfloats(ARRAY[tfloat '[1@2001-01-01, 2@2001-01-03)', 
	'[2@2001-01-03, 3@2001-01-05]']);
-- '{[1@2001-01-01 00:00:00+00, 3@2001-01-05 00:00:00+00]}'
SELECT tfloats(ARRAY[tfloat '[1@2001-01-01, 3@2001-01-05)', '[3@2001-01-05]']);
-- '{[1@2001-01-01 00:00:00+00, 3@2001-01-05 00:00:00+00]}'
SELECT tgeompoint '{[Point(0 0)@2001-01-01 08:00:00,
	Point(1 1)@2001-01-01 08:05:00, Point(1 1)@2001-01-01 08:10:00),
	[Point(1 1)@2001-01-01 08:10:00, Point(1 1)@2001-01-01 08:15:00)}';
-- "{[[Point(0 0)@2001-01-01 08:00:00, Point(1 1)@2001-01-01 08:05:00,
	Point(1 1)@2001-01-01 08:15:00)}"
SELECT tgeompoint '{[Point(1 1)@2001-01-01 08:00:00, Point(2 2)@2001-01-01 08:05:00),
	[Point(2 2)@2001-01-01 08:05:00, Point(3 3)@2001-01-01 08:10:00]}';
-- "{[Point(1 1)@2001-01-01 08:00:00, Point(3 3)@2001-01-01 08:10:00]}"
SELECT tgeompoint '{[Point(1 1)@2001-01-01 08:00:00, Point(3 3)@2001-01-01 08:10:00),
	[Point(3 3)@2001-01-01 08:10:00]}';
-- "{[Point(1 1)@2001-01-01 08:00:00, Point(3 3)@2001-01-01 08:10:00]}"
				</programlisting>
			</para>

		<para>Temporal types support <emphasis role="strong">type modifiers</emphasis> (or <varname>typmod</varname> in PostgreSQL terminology), which specify additional information for a column definition. For example, in the following table definition:
			<programlisting>
CREATE TABLE Department(DeptNo integer, DeptName varchar(25), NoEmps tint(Sequence));
			</programlisting>
		the type modifier for the type <varname>varchar</varname> is the value 25, which indicates the maximum length of the values of the column, while the type modifier for the type <varname>tint</varname> is the string <varname>Sequence</varname>, which restricts the duration of the values of the column to be sequences. In the case of temporal alphanumeric types (that is, <varname>tbool</varname>, <varname>tint</varname>, <varname>tfloat</varname>, and <varname>ttext</varname>), the possible values for the type modifier are <varname>Instant</varname>, <varname>InstantSet</varname>, <varname>Sequence</varname>, and <varname>SequenceSet</varname>. If no type modifier is specified for a column, values of any duration are allowed.</para>

		<para>On the other hand, in the case of temporal point types (that is, <varname>tgeompoint</varname> or <varname>tgeogpoint</varname>) the type modifier may be used to specify specify the duration, the dimensionality, and/or the spatial reference identifier (SRID). For example, in the following table definition:
			<programlisting>
CREATE TABLE Flight(FlightNo integer, Route tgeogpoint(Sequence, PointZ, 4326));
			</programlisting>
		the type modifier for the type <varname>tgeogpoint</varname> is composed of three values, the first one indicating the duration as above, the second one the spatial type of the geographies composing the temporal point, and the last one the SRID of the composing geographies. For temporal points, the possible values for the first argument of the type modifier are as above, those for the second argument are either <varname>Point</varname> or <varname>PointZ</varname>, and those for the third argument are valid SRIDs. All the three arguments are optional and if any of them is not specified for a column, values of any duration, dimensionality, and/or SRID are allowed.</para>

		<para>Each temporal type is associated to another type, referred to as its <emphasis role="strong">bounding box</emphasis>, which represent its extent in the value and/or the time dimension. The bounding box of the various temporal types are as follows:
			<itemizedlist>
				<listitem>
					<para>The <varname>period</varname> type for the <varname>tbool</varname> and <varname>ttext</varname> types, where only the temporal extent is considered.</para>
				</listitem>

				<listitem>
					<para>A <varname>tbox</varname> (temporal box) type for the <varname>tint</varname> and <varname>tfloat</varname> types, where the value extent is defined in the X dimension and the temporal extent in the T dimension.</para>
				</listitem>

				<listitem>
					<para>A <varname>stbox</varname> (spatiotemporal box) type for the <varname>tgeompoint</varname> and <varname>tgeogpoint</varname> types, where the spatial extent is defined in the X, Y, and Z dimensions, and the temporal extent in the T dimension.</para>
				</listitem>
			</itemizedlist>
		</para>

		<para>A rich set of functions and operators is available to perform various operations on temporal types. They are explained in <xref linkend="manipulating_temporal_types" />. Some of these operations, in particular those related to indexes, manipulate bounding boxes for efficiency reasons.</para>

		<sect1 id="examples_temporal_types">
			<title>Examples of Temporal Types</title>
			<para>Examples of usage of temporal alphanumeric types are given next.</para>
			<programlisting>
CREATE TABLE Department(DeptNo integer, DeptName varchar(25), NoEmps tint);
INSERT INTO Department VALUES
(10, 'Research', tint '[10@2012-01-01, 12@2012-04-01, 12@2012-08-01)'),
(20, 'Human Resources', tint '[4@2012-02-01, 6@2012-06-01, 6@2012-10-01)');
CREATE TABLE Temperature(RoomNo integer, Temp tfloat);
INSERT INTO Temperature VALUES
(1001, tfloat '{18.5@2012-01-01 08:00:00, 20.0@2012-01-01 08:10:00}'),
(2001, tfloat '{19.0@2012-01-01 08:00:00, 22.5@2012-01-01 08:10:00}');
-- Value at a timestamp
SELECT RoomNo, valueAtTimestamp(Temp, '2012-01-01 08:10:00')
FROM temperature;
-- 1001;
-- 2001;22.5
-- Restriction to a value
SELECT DeptNo, atValue(NoEmps, 10)
FROM Department;
-- 10;"[10@2012-01-01 00:00:00+00, 10@2012-04-01 00:00:00+00)"
-- 20; NULL
-- Restriction to a period
SELECT DeptNo, atPeriod(NoEmps, '[2012-01-01, 2012-04-01]')
FROM Department;
-- 10;"[10@2012-01-01 00:00:00+00, 12@2012-04-01 00:00:00+00]"
-- 20;"[4@2012-02-01 00:00:00+00, 4@2012-04-01 00:00:00+00]"
-- Temporal comparison
SELECT DeptNo, NoEmps #&lt;= 10
FROM Department;
-- 10;"[t@2012-01-01 00:00:00+00, f@2012-04-01 00:00:00+00, f@2012-08-01 00:00:00+00)"
-- 20;"[t@2012-04-02 00:00:00+00, t@2012-10-01 00:00:00+00)"
-- Temporal aggregation
SELECT tsum(NoEmps)
FROM Department;
-- "{[10@2012-01-01 00:00:00+00, 14@2012-02-01 00:00:00+00, 16@2012-04-01 00:00:00+00,
 18@2012-06-01 00:00:00+00, 6@2012-08-01 00:00:00+00, 6@2012-10-01 00:00:00+00)}"
			</programlisting>
			<para>Examples of usage of temporal point types are given next.</para>
			<programlisting>
CREATE TABLE Trips(CarId integer, TripId integer, Trip tgeompoint);
INSERT INTO Trips VALUES
(10, 1, tgeompoint '{[Point(0 0)@2012-01-01 08:00:00, Point(2 0)@2012-01-01 08:10:00,
	Point(2 1)@2012-01-01 08:15:00)}'),
(20, 1, tgeompoint '{[Point(0 0)@2012-01-01 08:05:00, Point(1 1)@2012-01-01 08:10:00,
	Point(3 3)@2012-01-01 08:20:00)}');
-- Value at a given timestamp
SELECT CarId, ST_AsText(valueAtTimestamp(Trip, timestamptz '2012-01-01 08:10:00'))
FROM Trips;
-- 10;"POINT(2 0)"
-- 20;"POINT(1 1)"
-- Restriction to a given value
SELECT CarId, asText(atValue(Trip, 'Point(2 0)'))
FROM Trips;
-- 10;"{"[POINT(2 0)@2012-01-01 08:10:00+00]"}"
-- 20; NULL
-- Restriction to a period
SELECT CarId, asText(atPeriod(Trip, '[2012-01-01 08:05:00,2012-01-01 08:10:00]'))
FROM Trips;
-- 10;"{[POINT(1 0)@2012-01-01 08:05:00+00, POINT(2 0)@2012-01-01 08:10:00+00]}"
-- 20;"{[POINT(0 0)@2012-01-01 08:05:00+00, POINT(1 1)@2012-01-01 08:10:00+00]}"
-- Temporal distance
SELECT T1.CarId, T2.CarId, T1.Trip &lt;-&gt; T2.Trip
FROM Trips T1, Trips T2
WHERE T1.CarId &lt; T2.CarId;
-- 10;20;"{[1@2012-01-01 08:05:00+00, 1.4142135623731@2012-01-01 08:10:00+00,
	1@2012-01-01 08:15:00+00)}"
			</programlisting>
		</sect1>
			
		<sect1 id="validity_temporal_types">
			<title>Validity of Temporal Types</title>

			<para>Values of temporal types must satisfy several constraints so that they are well defined. These constraints are given next.
			<itemizedlist>
				<listitem>
					<para>The constraints on the corresponding base type and <varname>timestamptz</varname> types must be satisfied.</para>
				</listitem>

				<listitem>
					<para>A temporal sequence value must be composed of at least one instant value.</para>
				</listitem>

				<listitem>
					<para>An instantaneous temporal sequence value must have inclusive lower and upper bounds.</para>
				</listitem>

				<listitem>
					<para>In a temporal sequence value, the timestamps of the composing instants must be different and ordered.</para>
				</listitem>

				<listitem>
					<para>In a temporal sequence value with stepwise interpolation, the last two values must be equal if upper bound is exclusive.</para>
				</listitem>

				<listitem>
					<para>A temporal set value must be composed of at least one temporal unit value.</para>
				</listitem>

				<listitem>
					<para>In a temporal instant set value, the composing instants must be different and ordered. This implies that the temporal extent of a temporal instant set value is an ordered set of <varname>timestamptz</varname> values without duplicates.</para>
				</listitem>

				<listitem>
					<para>In a temporal sequence set value, the composing sequence values must be non overlapping and ordered. This implies that the temporal extent of a temporal sequence set value is an ordered set of disjoint periods.</para>
				</listitem>
			</itemizedlist>
			An error is raised whenever one of these constraints are not satisfied. Examples of incorrect temporal values are as follows.
				<programlisting>
-- incorrect value for base type
SELECT tbool '1.5@2001-01-01 08:00:00';
-- base type is not a point
SELECT tgeompoint 'Linestring(0 0,1 1)@2001-01-01 08:05:00';
-- incorrect timestamp
SELECT tint '2@2001-02-31 08:00:00';
-- empty sequence
SELECT tint '';
-- incorrect bounds for instantaneous sequence
SELECT tint '[1@2001-01-01 09:00:00)';
-- duplicate timestamps
SELECT tint '[1@2001-01-01 08:00:00, 2@2001-01-01 08:00:00]';
-- unordered timestamps
SELECT tint '[1@2001-01-01 08:10:00, 2@2001-01-01 08:00:00]';
-- incorrect end value
SELECT tint '[1@2001-01-01 08:00:00, 2@2001-01-01 08:10:00)';
-- empty temporal sequence set value
SELECT tints(ARRAY[]);
-- duplicate timestamps
SELECT tinti(ARRAY[tint '1@2001-01-01 08:00:00', '2@2001-01-01 08:00:00']);
-- overlapping periods
SELECT tints(ARRAY[tint '[1@2001-01-01 08:00:00, 1@2001-01-01 10:00:00)',
	'[2@2001-01-01 09:00:00, 2@2001-01-01 11:00:00)']);
				</programlisting>
			</para>
		</sect1>
	</chapter>

	<chapter id="manipulating_box_types">
		<title>Manipulating Box Types</title>

		<sect1 id="input_output_box_tyes">
			<title>Input/Output of Box Types</title>
			<para>A <varname>tbox</varname> is composed of a numeric value and/or time dimensions. For each dimension, minimum and maximum values are given. Examples of input of <varname>tbox</varname> values are as follows:
				<programlisting>
-- Both value and time dimensions
SELECT tbox 'TBOX((1.0, 2000-01-01), (2.0, 2000-01-02))'; 
-- Only value dimension
SELECT tbox 'TBOX((1.0,), (2.0,))'; 
-- Only time dimension
SELECT tbox 'TBOX((, 2000-01-01), (, 2000-01-02))'; 
				</programlisting>
			</para>

			<para>An <varname>stbox</varname> is composed of a spatial value and/or time dimensions, where the coordinates of the spatial value dimension may be 2D or 3D. For each dimension, minimum and maximum values are given. The coordinates may be Cartesian (planar) or geodetic (spherical). The SRID of the coordinates may be specified; if it is not the case, a value of 0 (unknown) and 4326 (corresponding to WGS84) is assumed, respectively, for planar and geodetic boxes. Examples of input of <varname>stbox</varname> values are as follows:
				<programlisting>
-- Only value dimension with X and Y coordinates
SELECT stbox 'STBOX((1.0, 2.0), (1.0, 2.0))';
-- Only value dimension with X, Y, and Z coordinates
SELECT stbox 'STBOX Z((1.0, 2.0, 3.0), (1.0, 2.0, 3.0))';
-- Both value (with X and Y coordinates) and time dimensions
SELECT stbox 'STBOX T((1.0, 2.0, 2001-01-03), (1.0, 2.0, 2001-01-03))';
-- Both value (with X, Y, and Z coordinates) and time dimensions
SELECT stbox 'STBOX ZT((1.0, 2.0, 3.0, 2001-01-04), (1.0, 2.0, 3.0, 2001-01-04))';
-- Only time dimension
SELECT stbox 'STBOX T(( , , 2001-01-03), ( , , 2001-01-03))';
-- Only value dimension with X, Y, and Z geodetic coordinates
SELECT stbox 'GEODSTBOX((1.0, 2.0, 3.0), (1.0, 2.0, 3.0))';
-- Both value (with X, Y and Z geodetic coordinates) and time dimension
SELECT stbox 'GEODSTBOX T((1.0, 2.0, 3.0, 2001-01-04), (1.0, 2.0, 3.0, 2001-01-04))';
-- Only time dimension for geodetic box
SELECT stbox 'GEODSTBOX T(( , , 2001-01-03), ( , , 2001-01-03))';
-- SRID is given
SELECT stbox 'SRID=5676;STBOX T((1.0, 2.0, 2001-01-04), (1.0, 2.0, 2001-01-04))';
SELECT stbox 'SRID=4326;GEODSTBOX((1.0, 2.0, 3.0), (1.0, 2.0, 3.0))';
				</programlisting>
			</para>
		</sect1>

		<sect1 id="constructor_box_types">
			<title>Constructor Functions</title>

			<para>Type <varname>tbox</varname> has several constructor functions depending on whether the value and/or the time dimensions are given. These functions have two arguments for the minimum and maximum <varname>float</varname> values and/or two arguments for the minimum and maximum <varname>timestamptz</varname> values.
			</para>

			<itemizedlist>
				<listitem id="tbox">
					<para>Constructor for <varname>tbox</varname></para>
					<para><varname>tbox(float, float): tbox</varname></para>
					<para><varname>tboxt(timestamptz, timestamptz): tbox</varname></para>
					<para><varname>tbox(float, timestamptz, float, timestamptz): tbox</varname></para>
					<programlisting>
-- Both value and time dimensions
SELECT tbox(1.0, '2001-01-01', 2.0, '2001-01-02');
-- Only value dimension
SELECT tbox(1.0, 2.0);
-- Only time dimension
SELECT tboxt('2001-01-01', '2001-01-02');
					</programlisting>
				</listitem>
			</itemizedlist>

			<para>Type <varname>stbox</varname> has several constructor functions depending on whether the coordinates and/or the time dimensions are given. Furthermore, the coordinates can be 2D or 3D and can be either Cartesian or geodetic. These functions have several arguments for the minimum and maximum coordinate values and/or two arguments for the minimum and maximum <varname>timestamptz</varname> values. The SRID can be specified in an optional last argument. If not given, a value 0 (respectively 4326) is assumed by default for planar (respectively geodetic) boxes.
			</para>

			<itemizedlist>
				<listitem id="stbox">
					<para>Constructor for <varname>stbox</varname></para>
					<para><varname>stbox(float, float, float, float, integer): stbox</varname></para>
					<para><varname>stbox(float, float, float, float, float, float, integer): stbox</varname></para>
					<para><varname>stbox(float, float, float, timestamptz, float, float, float, timestamptz, integer): stbox</varname></para>
					<para><varname>stboxt(timestamptz, timestamptz, integer): stbox</varname></para>
					<para><varname>stbox(float, float, timestamptz, float, float, timestamptz, integer): stbox</varname></para>
					<para><varname>stbox(geo, {timestamp, period}): stbox</varname></para>
					<programlisting>
-- Only value dimension with X and Y coordinates
SELECT stbox(1.0, 2.0, 1.0, 2.0);
-- Only value dimension with X, Y, and Z coordinates
SELECT stbox(1.0, 2.0, 3.0, 1.0, 2.0, 3.0);
-- Only value dimension with X, Y, and Z coordinates and SRID
SELECT stbox(1.0, 2.0, 3.0, 1.0, 2.0, 3.0);
-- Both value (with X and Y coordinates) and time dimensions
SELECT stboxt(1.0, 2.0, '2001-01-03', 1.0, 2.0, '2001-01-03');
-- Both value (with X, Y, and Z coordinates) and time dimensions
SELECT stbox(1.0, 2.0, 3.0, '2001-01-04', 1.0, 2.0, 3.0, '2001-01-04');
-- Only time dimension
SELECT stboxt('2001-01-03', '2001-01-03');
-- Only value dimension with X, Y, and Z geodetic coordinates
SELECT geodstbox(1.0, 2.0, 3.0, 1.0, 2.0, 3.0);
--  Both value (with X, Y, and Z geodetic coordinates) and time dimensions
SELECT geodstbox(1.0, 2.0, 3.0, '2001-01-04', 1.0, 2.0, 3.0, '2001-01-03');
-- Only time dimension for geodetic box
SELECT geodstboxt('2001-01-03', '2001-01-03');
SELECT stbox(geometry 'Linestring(1 1 1,2 2 2)', period '[2012-01-03, 2012-01-05]');
-- "STBOX ZT((1,1,1,2012-01-03),(2,2,2,2012-01-05))"
SELECT stbox(geography 'Linestring(1 1 1,2 2 2)', period '[2012-01-03, 2012-01-05]');
-- "GEODSTBOX T((0.99878198,0.017449748,0.017452406,2012-01-03),
  (0.99969542,0.034878239,0.034899499,2012-01-05))"
					</programlisting>
				</listitem>
			</itemizedlist>
		</sect1>

		<sect1 id="casting_box_types">
			<title>Casting</title>
	
			<itemizedlist>
				<listitem id="tbox_cast_to">
					<para>Cast a <varname>tbox</varname> to another type</para>
					<para><varname>tbox::{floatrange,period}</varname></para>
					<programlisting>
SELECT tbox 'TBOX((1,2000-01-01),(2,2000-01-02))'::floatrange;
-- "[1,2]"
SELECT tbox 'TBOX((1,2000-01-01),(2,2000-01-02))'::period;
-- "[2000-01-01, 2000-01-02]"
					</programlisting>
				</listitem>

				<listitem id="tbox_cast_from">
					<para>Cast another type to a <varname>tbox</varname></para>
					<para><varname>{int, float, numeric, intrange, floatrange}::tbox</varname>,</para>
					<para><varname>{timestamptz, timestampset, period, periodset, tint, tfloat}::tbox</varname></para>
					<programlisting>
SELECT floatrange '(1.0, 2.0)'::tbox;
-- "TBOX((1,),(2,))"
SELECT periodset '{(2001-01-01,2001-01-02), (2001-01-03,2001-01-04)}'::tbox;
-- "TBOX((,2001-01-01),(,2001-01-04))"
					</programlisting>
				</listitem>

				<listitem id="stbox_cast_to">
					<para>Cast an <varname>stbox</varname> to a another type</para>
					<para><varname>stbox::{period, box2d, box3d}</varname></para>
					<programlisting>
SELECT stbox 'STBOX T((1.0, 2.0, 2001-01-01), (3.0, 4.0, 2001-01-03))'::period;
-- "[2000-01-01, 2000-01-03]"
SELECT stbox 'STBOX Z((1 1 1),(3 3 3))'::box2d;
-- "BOX(1 1,3 3)"
SELECT stbox 'STBOX Z((1 1 1),(3 3 3))'::box3d;
-- "BOX3D(1 1 1,3 3 3)"
					</programlisting>
				</listitem>

				<listitem id="stbox_cast_from">
					<para>Cast another type to an <varname>stbox</varname></para>
					<para><varname>{geometry, geography, box2d, box3d}::stbox</varname></para>
					<para><varname>{timestamptz, timestampset, period, periodset, tgeompoint, tgeogpoint}::stbox</varname></para>
					<programlisting>
select geometry 'Linestring(1 1,2 2)'::stbox;
-- "STBOX((1,1),(2,2))"
SELECT periodset '{(2001-01-01,2001-01-02), (2001-01-03,2001-01-04)}'::stbox;
-- "STBOX T((,,2001-01-01),(,,2001-01-04))"
					</programlisting>
				</listitem>
			</itemizedlist>
		</sect1>

		<sect1 id="accessor_box_types">
			<title>Accessor Functions</title>

			<itemizedlist>
				<listitem id="Xmin">
					<para>Get the minimum X value</para>
					<para><varname>Xmin({tbox, stbox}): float</varname></para>
					<programlisting>
SELECT Xmin(tbox 'TBOX((1.0, 2000-01-01), (3.0, 2000-01-03))');
-- 1
SELECT Xmin(stbox 'STBOX((1.0, 2.0), (3.0, 4.0))');
-- 1
					</programlisting>
				</listitem>

				<listitem id="Xmax">
					<para>Get the maximum X value</para>
					<para><varname>Xmax({tbox, stbox}): float</varname></para>
					<programlisting>
SELECT Xmax(tbox 'TBOX((1.0, 2000-01-01), (3.0, 2000-01-03))');
-- 3
SELECT Xmax(stbox 'STBOX((1.0, 2.0), (3.0, 4.0))');
-- 3
					</programlisting>
				</listitem>

				<listitem id="Ymin">
					<para>Get the minimum Y value</para>
					<para><varname>Ymin(stbox): float</varname></para>
					<programlisting>
SELECT Ymin(stbox 'STBOX((1.0, 2.0), (3.0, 4.0))');
-- 2
					</programlisting>
				</listitem>

				<listitem id="Ymax">
					<para>Get the maximum Y value</para>
					<para><varname>Ymax(stbox): float</varname></para>
					<programlisting>
SELECT Ymax(stbox 'STBOX((1.0, 2.0), (3.0, 4.0))');
-- 4
					</programlisting>
				</listitem>

				<listitem id="Zmin">
					<para>Get the minimum Z value</para>
					<para><varname>Zmin(stbox): float</varname></para>
					<programlisting>
SELECT Zmin(stbox 'STBOX Z((1.0, 2.0, 3.0), (4.0, 5.0, 6.0))');
-- 3
					</programlisting>
				</listitem>

				<listitem id="Zmax">
					<para>Get the maximum Z value</para>
					<para><varname>Zmax(stbox): float</varname></para>
					<programlisting>
SELECT Zmax(stbox 'STBOX Z((1.0, 2.0, 3.0), (4.0, 5.0, 6.0))');
-- 6
					</programlisting>
				</listitem>

				<listitem id="Tmin">
					<para>Get the minimum timestamp</para>
					<para><varname>Tmin({tbox, stbox}): timestamptz</varname></para>
					<programlisting>
SELECT Tmin(stbox 'GEODSTBOX T(( , , 2001-01-01), ( , , 2001-01-03))');
-- "2001-01-01"
					</programlisting>
				</listitem>

				<listitem id="Tmax">
					<para>Get the maximum timestamp</para>
					<para><varname>Tmax({tbox, stbox}): timestamptz</varname></para>
					<programlisting>
SELECT Tmax(stbox 'GEODSTBOX T(( , , 2001-01-01), ( , , 2001-01-03))');
-- "2001-01-03"
					</programlisting>
				</listitem>
			</itemizedlist>
		</sect1>

		<sect1 id ="modification_box_tyes">
				<title>Modification Functions</title>

				<para>The functions given next expand the bounding boxes on the value and the time dimension or set the precision of the value dimension. These functions raise an error if the corresponding dimension is not present.
				</para>
				<itemizedlist>
					<listitem id="expandValue">
						<para>Expand the numeric value dimension of the bounding box by a float value</para>
						<para><varname>expandValue(tbox, float): tbox</varname></para>
						<programlisting>
SELECT expandValue(tbox 'TBOX((1,2012-01-01),(2,2012-01-03))', 1);
-- "TBOX((0,2012-01-01),(3,2012-01-03))"
SELECT expandValue(tbox 'TBOX((,2012-01-01),(,2012-01-03))', 1);
-- The box must have value dimension
						</programlisting>
					</listitem>

					<listitem id="expandSpatial">
						<para>Expand the spatial value dimension of the bounding box by a float value</para>
						<para><varname>expandSpatial(stbox, float): stbox</varname></para>
						<programlisting>
SELECT expandSpatial(stbox 'STBOX ZT((1,1,1,2012-01-01),(2,2,2,2012-01-03))', 1);
-- "STBOX ZT((0,0,0,2012-01-01),(3,3,3,2012-01-03))"
SELECT expandSpatial(stbox 'STBOX T((,2012-01-01),(,2012-01-03))', 1);
-- The box must have XY dimension
						</programlisting>
					</listitem>

					<listitem id="expandTemporal">
						<para>Expand the temporal dimension of the bounding box by a time interval</para>
						<para><varname>expandTemporal({tbox, stbox}, interval): {tbox, stbox}</varname></para>
						<programlisting>
	SELECT expandTemporal(tbox 'TBOX((1,2012-01-01),(2,2012-01-03))', interval '1 day');
	-- "TBOX((1,2011-12-31),(2,2012-01-04))"
	SELECT expandTemporal(stbox 'STBOX ZT((1,1,1,2012-01-01),(2,2,2,2012-01-03))',
		interval '1 day');
	-- "STBOX ZT((1,1,1,2011-12-31),(2,2,2,2012-01-04))"
						</programlisting>
					</listitem>

					<listitem id="box_setPrecision">
						<para>Round the value or the coordinates of the bounding box to a number of decimal places</para>
						<para><varname>setPrecision({tbox, stbox}, int): {tbox, stbox}</varname></para>
						<programlisting>
	SELECT setPrecision(tbox 'TBOX((1.12345, 2000-01-01), (2.12345, 2000-01-02))', 2);
	-- "TBOX((1.12,2000-01-01),(2.12,2000-01-02))"
	SELECT setPrecision(stbox 'STBOX T((1.12345, 1.12345, 2000-01-01),
		(2.12345, 2.12345, 2000-01-02))', 2);
	-- "STBOX T((1.12,1.12,2000-01-01),(2.12,2.12,2000-01-02))"
						</programlisting>
					</listitem>

				</itemizedlist>
			</sect1>

		<sect1 id ="srid_box_tyes">
			<title>Spatial Reference System Functions</title>

			<itemizedlist>
				<listitem id="stbox_SRID">
					<para>Get the spatial reference identifier</para>
					<para><varname>SRID(stbox): int</varname></para>
					<programlisting>
SELECT SRID(stbox 'STBOX ZT((1.0, 2.0, 3.0, 2000-01-01), (4.0, 5.0, 6.0, 2000-01-02))');
-- 0
SELECT SRID(stbox 'SRID=5676;STBOX T((1.0, 2.0, 2000-01-01), (4.0, 5.0, 2000-01-02))');
-- 5676
SELECT SRID(geodstbox 'GEODSTBOX T((, , 2000-01-01), (, , 2000-01-02))');
-- 4326
					</programlisting>
				</listitem>

				<listitem id="stbox_setSRID">
					<para>Set the spatial reference identifier</para>
					<para><varname>setSRID(stbox): stbox</varname></para>
					<programlisting>
SELECT setSRID(stbox 'STBOX ZT((1.0, 2.0, 3.0, 2000-01-01),
	(4.0, 5.0, 6.0, 2000-01-02))', 5676);
-- "SRID=5676;STBOX ZT((1,2,3,2000-01-01),(4,5,6,2000-01-02))"
					</programlisting>
					</listitem>

				<listitem id="stbox_transform">
					<para>Transform to a different spatial reference</para>
					<para><varname>transform(stbox, integer): stbox</varname></para>
					<programlisting>
SELECT transform(stbox 'SRID=4326;STBOX T((2.340088, 49.400250, 2000-01-01),
	(6.575317, 51.553167, 2000-01-02))', 3812);
-- "SRID=3812;STBOX T((502773.429980817,511805.120401577,2000-01-01),
	(803028.908264815,751590.742628986,2000-01-02))"
					</programlisting>
				</listitem>
			</itemizedlist>
		</sect1>

		<sect1 id="comparison_box_types">
			<title>Comparison Operators</title>

			<para>The traditional comparison operators (<varname>=</varname>, <varname>&lt;</varname>, and so on) can be applied to box types. Excepted equality  and inequality, the other comparison operators are not useful in the real world but allow B-tree indexes to be constructed on bos types. These operators compare first the timestamps and if those are equal, compare the values.</para>

			<itemizedlist>
				<listitem id="box_eq">
				<para>Are the bounding boxes equal?</para>
				<para><varname>{tbox, stbox} = {tbox, stbox}: boolean</varname></para>
				<programlisting>
SELECT tbox 'TBOX((1, 2012-01-01), (1, 2012-01-04))' =
	tbox 'TBOX((2, 2012-01-03), (2, 2012-01-05))';
-- false
					</programlisting>
				</listitem>

				<listitem id="box_ne">
					<para>Are the bounding boxes different?</para>
					<para><varname>{tbox, stbox} &lt;&gt; {tbox, stbox}: boolean</varname></para>
					<programlisting>
SELECT tbox 'TBOX((1, 2012-01-01), (1, 2012-01-04))' &lt;&gt;
	tbox 'TBOX((2, 2012-01-03), (2, 2012-01-05))'
-- true
					</programlisting>
				</listitem>

				<listitem id="box_lt">
					<para>Is the first bounding box less than the second one?</para>
					<para><varname>{tbox, stbox} &lt; {tbox, stbox}: boolean</varname></para>
					<programlisting>
SELECT tbox 'TBOX((1, 2012-01-01), (1, 2012-01-04))' &lt;
	tbox 'TBOX((1, 2012-01-03), (2, 2012-01-05))'
-- true
					</programlisting>
				</listitem>

				<listitem id="box_gt">
					<para>Is the first bounding box greater than the second one?</para>
					<para><varname>{tbox, stbox} &gt; {tbox, stbox}: boolean</varname></para>
					<programlisting>
SELECT tbox 'TBOX((1, 2012-01-03), (1, 2012-01-04))' &gt;
	tbox 'TBOX((1, 2012-01-01), (2, 2012-01-05))'
-- true
					</programlisting>
				</listitem>

				<listitem id="box_le">
					<para>Is the first bounding box less than or equal to the second one?</para>
					<para><varname>{tbox, stbox} &lt;= {tbox, stbox}: boolean</varname></para>
					<programlisting>
SELECT tbox 'TBOX((1, 2012-01-01), (1, 2012-01-04))' &lt;=
	tbox 'TBOX((2, 2012-01-03), (2, 2012-01-05))'
-- true
					</programlisting>
				</listitem>

				<listitem id="box_ge">
					<para>Is the first bounding box greater than or equal to the second one?</para>
					<para><varname>{tbox, stbox} &gt;= {tbox, stbox}: boolean</varname></para>
					<programlisting>
SELECT tbox 'TBOX((1, 2012-01-01), (1, 2012-01-04))' &gt;=
	tbox 'TBOX((2, 2012-01-03), (2, 2012-01-05))'
-- false
					</programlisting>
				</listitem>
			</itemizedlist>
		</sect1>

		<sect1 id="set_box_types">
			<title>Set Operators</title>

			<para>The set operators for box types are union (<varname>+</varname>) and intersection (<varname>*</varname>). In the case of union, the operands must have exactly the same dimensions, otherwise an error is raided. Furthermore, if the operands do not overlap on all the dimensions and error is raised, since in this would result in a box with disjoint values, which cannot be represented.  The operator computes the union on all dimensions that are present in both arguments. In the case of intersection, the operands must have at least one common dimension, otherwise an error is raised. The operator computes the intersection on all dimensions that are present in both arguments.</para>

			<itemizedlist>
				<listitem id="box_union">
					<para>Union of the bounding boxes</para>
					<para><varname>{tbox, stbox} + {tbox, stbox}: {tbox, stbox}</varname></para>
					<programlisting>
SELECT tbox 'TBOX((1,2001-01-01),(3,2001-01-03))' +
	tbox 'TBOX((2,2001-01-02),(4,2001-01-04))';
-- "TBOX((1,2001-01-01),(4,2001-01-04))"
SELECT stbox 'STBOX ZT((1,1,1,2001-01-01),(2,2,2,2001-01-02))' +
	stbox 'STBOX T((2,2,2001-01-01),(3,3,2001-01-03))';
-- ERROR:  Boxes must be of the same dimensionality
SELECT tbox 'TBOX((1,2001-01-01),(3,2001-01-02))' +
	tbox 'TBOX((2,2001-01-03),(4,2001-01-04))';
-- ERROR:  Result of box union would not be contiguous
					</programlisting>
				</listitem>

				<listitem id="box_intersection">
					<para>Intersection of the bounding boxes</para>
					<para><varname>{tbox, stbox} * {tbox, stbox}: {tbox, stbox}</varname></para>
					<programlisting>
SELECT tbox 'TBOX((1,2001-01-01),(3,2001-01-03))' *
	tbox 'TBOX((,2001-01-02),(,2001-01-04))';
-- "TBOX((,2001-01-02),(,2001-01-03))"
SELECT stbox 'STBOX ZT((1,1,1,2001-01-01),(3,3,3,2001-01-02))' *
	stbox 'STBOX((2,2),(4,4))';
-- "STBOX((2,2),(3,3))"
					</programlisting>
				</listitem>
			</itemizedlist>
		</sect1>

		<sect1 id="operators_box_types">
			<title>Topological Operators</title>

			<para>A first set of operators consider the relative position of the bounding boxes. The operators <varname>&lt;&lt;</varname>, <varname>&gt;&gt;</varname>, <varname>&amp;&lt;</varname>, and <varname>&amp;&gt;</varname> consider the X value for the <varname>tbox</varname> type and the X coordinates for the <varname>stbox</varname> type, the operators <varname>&lt;&lt;|</varname>, <varname>|&gt;&gt;</varname>, <varname>&amp;&lt;|</varname>, and <varname>|&amp;&gt;</varname> consider the Y coordinates for the <varname>stbox</varname> type, the operators <varname>&lt;&lt;/</varname>, <varname>/&gt;&gt;</varname>, <varname>&amp;&lt;/</varname>, and <varname>/&amp;&gt;</varname> consider the Z coordinates for the <varname>stbox</varname> type, and the operators <varname>&lt;&lt;#</varname>, <varname>#&gt;&gt;</varname>, <varname>#&amp;&lt;</varname>, and <varname>#&amp;&gt;</varname> consider the time dimension for the <varname>tbox</varname> and <varname>stbox</varname> types. The operators raise an error if both boxes do not have the required dimension.</para>

			<para>The operators for the numeric value dimension of the <varname>tbox</varname> type are given next.</para>

			<itemizedlist>
				<listitem id="tbox_left">
					<para>Are the X values of the first bounding box strictly less than those of the second one?</para>
					<para><varname>tbox &lt;&lt; tbox: boolean</varname></para>
					<programlisting>
SELECT tbox 'TBOX((1,2012-01-01),(2,2012-01-02))' &lt;&lt;
	tbox 'TBOX((3,2012-01-03),(4,2012-01-04))';
-- true
SELECT tbox 'TBOX((1,2012-01-01),(2,2012-01-02))' &lt;&lt;
	tbox 'TBOX((,2012-01-03),(,2012-01-04))';
-- ERROR:  Boxes must have X dimension
					</programlisting>
				</listitem>

				<listitem id="tbox_right">
					<para>Are the X values of the first bounding box strictly greater than those of the second one?</para>
					<para><varname>tbox &gt;&gt; tbox: boolean</varname></para>
					<programlisting>
SELECT tbox 'TBOX((3,2012-01-03),(4,2012-01-04))' &gt;&gt;
	tbox 'TBOX((1,2012-01-01),(2,2012-01-02))';
-- true
					</programlisting>
				</listitem>

				<listitem id="tbox_overleft">
					<para>Are the X values of the first bounding box not greater than those of the second one?</para>
					<para><varname>tbox &amp;&lt; tbox: boolean</varname></para>
					<programlisting>
SELECT tbox 'TBOX((1,2012-01-01),(4,2012-01-04))' &amp;&lt;
	tbox 'TBOX((3,2012-01-03),(4,2012-01-04))';
-- true
					</programlisting>
				</listitem>

				<listitem id="tbox_overright">
					<para>Are the X values of the first bounding box not less than those of the second one?</para>
					<para><varname>tbox &amp;&gt; tbox: boolean</varname></para>
					<programlisting>
SELECT tbox 'TBOX((1,2012-01-01),(2,2012-01-02))' &amp;&gt;
	tbox 'TBOX((1,2012-01-01),(4,2012-01-04))';
-- true
					</programlisting>
				</listitem>
			</itemizedlist>
			<para>The operators for the spatial value dimension of the <varname>stbox</varname> type are given next.</para>

			<itemizedlist>
				<listitem id="stbox_left">
					<para>Are the X values of the first bounding box strictly to the left of those of the second one?</para>
					<para><varname>stbox &lt;&lt; stbox: boolean</varname></para>
					<programlisting>
SELECT stbox 'STBOX Z((1,1,1),(2,2,2))' &lt;&lt; stbox 'STBOX Z((3,3,3),(4,4,4))';
-- true
					</programlisting>
				</listitem>

				<listitem id="stbox_right">
					<para>Are the X values of the first bounding box strictly to the right of those of the second one?</para>
					<para><varname>stbox &gt;&gt; stbox: boolean</varname></para>
					<programlisting>
SELECT stbox 'STBOX Z((3,3,3),(4,4,4))' &gt;&gt; stbox 'STBOX Z((1,1,1),(2,2,2))';
-- true
					</programlisting>
				</listitem>

				<listitem id="stbox_overleft">
					<para>Are the X values of the first bounding box not to the right of those of the second one?</para>
					<para><varname>stbox &amp;&lt; stbox: boolean</varname></para>
					<programlisting>
SELECT stbox 'STBOX Z((1,1,1),(4,4,4))' &amp;&lt; stbox 'STBOX Z((3,3,3),(4,4,4))';
-- true
					</programlisting>
				</listitem>

				<listitem id="stbox_overright">
					<para>Are the X values of the first bounding box not to the left of those of the second one?</para>
					<para><varname>stbox &amp;&gt; stbox: boolean</varname></para>
					<programlisting>
SELECT stbox 'STBOX Z((3,3,3),(4,4,4))' &amp;&gt; stbox 'STBOX Z((1,1,1),(2,2,2))';
-- true
					</programlisting>
				</listitem>

				<listitem id="stbox_below">
					<para>Are the Y values of the first bounding box strictly below of those of the second one?</para>
					<para><varname>stbox &lt;&lt;| stbox: boolean</varname></para>
					<programlisting>
SELECT stbox 'STBOX Z((1,1,1),(2,2,2))' &lt;&lt;| stbox 'STBOX Z((3,3,3),(4,4,4))';
-- true
					</programlisting>
				</listitem>

				<listitem id="stbox_above">
					<para>Are the Y values of the first bounding box strictly above of those of the second one?</para>
					<para><varname>stbox |&gt;&gt; stbox: boolean</varname></para>
					<programlisting>
SELECT stbox 'STBOX Z((3,3,3),(4,4,4))' |&gt;&gt; stbox 'STBOX Z((1,1,1),(2,2,2))';
-- true
					</programlisting>
				</listitem>

				<listitem id="stbox_overbelow">
					<para>Are the Y values of the first bounding box not above of those of the second one?</para>
					<para><varname>stbox &amp;&lt;| stbox: boolean</varname></para>
					<programlisting>
SELECT stbox 'STBOX Z((1,1,1),(4,4,4))' &amp;&lt;| stbox 'STBOX Z((3,3,3),(4,4,4))';
-- true
					</programlisting>
				</listitem>

				<listitem id="stbox_overabove">
					<para>Are the Y values of the first bounding box not below of those of the second one?</para>
					<para><varname>stbox |&amp;&gt; stbox: boolean</varname></para>
					<programlisting>
SELECT stbox 'STBOX Z((3,3,3),(4,4,4))' |&amp;&gt; stbox 'STBOX Z((1,1,1),(2,2,2))';
-- false
					</programlisting>
				</listitem>

				<listitem id="stbox_front">
					<para>Are the Z values of the first bounding box strictly in front of those of the second one?</para>
					<para><varname>stbox &lt;&lt;/ stbox: boolean</varname></para>
					<programlisting>
SELECT stbox 'STBOX Z((1,1,1),(2,2,2))' &lt;&lt;/ stbox 'STBOX Z((3,3,3),(4,4,4))';
					</programlisting>
				</listitem>

				<listitem id="stbox_back">
					<para>Are the Z values of the first bounding box strictly back of those of the second one?</para>
					<para><varname>stbox /&gt;&gt; stbox: boolean</varname></para>
					<programlisting>
SELECT stbox 'STBOX Z((3,3,3),(4,4,4))' /&gt;&gt; stbox 'STBOX Z((1,1,1),(2,2,2))';
-- true
					</programlisting>
				</listitem>

				<listitem id="stbox_overfront">
					<para>Are the Z values of the first bounding box not back of those of the second one?</para>
					<para><varname>stbox &amp;&lt;/ stbox: boolean</varname></para>
					<programlisting>
SELECT stbox 'STBOX Z((1,1,1),(4,4,4))' &amp;&lt;/ stbox 'STBOX Z((3,3,3),(4,4,4))';
-- true
					</programlisting>
				</listitem>

				<listitem id="stbox_overback">
					<para>Are the Z values of the first bounding box not in front of those of the second one?</para>
					<para><varname>stbox /&amp;&gt; stbox: boolean</varname></para>
					<programlisting>
SELECT stbox 'STBOX Z((3,3,3),(4,4,4))' /&amp;&gt; stbox 'STBOX Z((1,1,1),(2,2,2))';
-- true
					</programlisting>
				</listitem>
			</itemizedlist>

			<para>The operators for the time dimension of the <varname>tbox</varname> and <varname>stbox</varname> types are as follows.</para>
			<itemizedlist>
				<listitem id="box_before">
					<para>Are the T values of the first bounding box strictly before those of the second one?</para>
					<para><varname>{tbox, stbox} &lt;&lt;# {tbox, stbox}: boolean</varname></para>
					<programlisting>
SELECT tbox 'TBOX((1,2000-01-01),(2,2000-01-02))' &lt;&lt;#
	tbox 'TBOX((3,2000-01-03),(4,2000-01-04)))';
-- true
					</programlisting>
				</listitem>

				<listitem id="box_after">
					<para>Are the T values of the first bounding box strictly after those of the second one?</para>
					<para><varname>{tbox, stbox} #&gt;&gt; {tbox, stbox}: boolean</varname></para>
					<programlisting>
SELECT stbox 'STBOX T((3,3,2000-01-03),(4,4,2000-01-04))'  #&gt;&gt;
	stbox 'STBOX T((1,1,2000-01-01),(2,2,2000-01-02))';
-- true
					</programlisting>
				</listitem>

				<listitem id="box_overbefore">
					<para>Are the T values of the first bounding box not after those of the second one?</para>
					<para><varname>{tbox, stbox} &amp;&lt;# {tbox, stbox}: boolean</varname></para>
					<programlisting>
SELECT tbox 'TBOX((1,2000-01-01),(4,2000-01-04))' &amp;&lt;#
	tbox 'TBOX((3,2000-01-03),(4,2000-01-04)))';
-- true
					</programlisting>
				</listitem>

				<listitem id="box_overafter">
					<para>Are the T values of the first bounding box not before those of the second one?</para>
					<para><varname>{tbox, stbox} #&amp;&gt; {tbox, stbox}: boolean</varname></para>
					<programlisting>
SELECT stbox 'STBOX T((1,1,2000-01-01),(3,3,2000-01-03))' #&amp;&gt;
	stbox 'STBOX T((3,3,2000-01-03),(4,4,2000-01-04))';
-- true
					</programlisting>
				</listitem>
			</itemizedlist>

			<para>Another set of operators consider the topological relationships between the bounding boxes. There are five topological operators: overlaps (<varname>&amp;&amp;</varname>), contains (<varname>@&gt;</varname>), contained (<varname>&lt;@</varname>), same (<varname>~=</varname>), and adjacent (<varname>-|-</varname>). The operators verify the topological relationship taking into account the value and/or the time dimension for as many dimensions that are present on both arguments.</para>

			<para>The topological operators for temporal alphanumeric types are given next.</para>

			<itemizedlist>
				<listitem id="box_overlap">
					<para>Do the bounding boxes overlap?</para>
					<para><varname>{tbox, stbox} &amp;&amp; {tbox, stbox}: boolean</varname></para>
					<programlisting>
SELECT tbox 'TBOX((1,2001-01-01),(3,2001-01-03))' &amp;&amp;
	tbox 'TBOX((2,2001-01-02),(4,2001-01-04))';
-- true
SELECT stbox 'STBOX T((1,1,2001-01-01),(2,2,2001-01-02))'&amp;&amp;
	stbox 'STBOX T((,2001-01-02),(,2001-01-02))';
-- true
					</programlisting>
				</listitem>

				<listitem id="box_contains">
					<para>Does the first bounding box contain the second one?</para>
					<para><varname>{tbox, stbox} @&gt; {tbox, stbox}: boolean</varname></para>
					<programlisting>
SELECT tbox 'TBOX((1,2001-01-01),(4,2001-01-04))' @&gt;
	tbox 'TBOX((2,2001-01-01),(3,2001-01-02))';
-- true
SELECT stbox 'STBOX Z((1,1,1),(3,3,3))' @&gt;
	stbox 'STBOX T((1,1,2001-01-01),(2,2,2001-01-02))';
-- true
					</programlisting>
				</listitem>

				<listitem id="box_containedby">
					<para>Is the first bounding box contained in the second one?</para>
					<para><varname>{tbox, stbox} &lt;@ {tbox, stbox}: boolean</varname></para>
					<programlisting>
SELECT tbox 'TBOX((1,2001-01-01),(2,2001-01-02))' &lt;@
	tbox 'TBOX((1,2001-01-01),(2,2001-01-02))';
-- true
SELECT stbox 'STBOX T((1,1,2001-01-01),(2,2,2001-01-02))' &lt;@
	stbox 'STBOX ZT((1,1,1,2001-01-01),(2,2,2,2001-01-02))';
-- true
					</programlisting>
				</listitem>

				<listitem id="box_same">
					<para>Are the bounding boxes equal in their common dimensions?</para>
					<para><varname>{tbox, stbox} ~= {tbox, stbox}: boolean</varname></para>
					<programlisting>
SELECT tbox 'TBOX((1,2001-01-01),(2,2001-01-02))' ~=
	tbox 'TBOX((,2001-01-01),(,2001-01-02))';
-- true
SELECT stbox 'STBOX T((1,1,2001-01-01),(3,3,2001-01-03))' ~=
	stbox 'STBOX Z((1,1,1),(3,3,3))';
-- true
					</programlisting>
				</listitem>

				<listitem id="box_adjacent">
					<para>Are the bounding boxes adjacent?</para>
					<para><varname>{tbox, stbox} -|- {tbox, stbox}: boolean</varname></para>
					<para>Two boxes are adjacent if they share <emphasis>n</emphasis> dimensions and their intersection is at most of <emphasis>n</emphasis>-1 dimensions.</para>
					<programlisting>
SELECT tbox 'TBOX((1,2001-01-01),(2,2001-01-02))' -|-
	tbox 'TBOX((,2001-01-02),(,2001-01-03))';
-- true
SELECT stbox 'STBOX T((1,1,2001-01-01),(3,3,2001-01-03))' -|-
	stbox 'STBOX T((2,2,2001-01-03),(4,4,2001-01-04))';
-- true
					</programlisting>
				</listitem>
			</itemizedlist>
		</sect1>


		<sect1 id ="indexing_box_types">
			<title>Indexing of Box Types</title>
			<para>GiST and SP-GiST indexes can be created for table columns of the <varname>tbox</varname> and <varname>stbox</varname> types. An example of creation of a GiST index in a column <varname>bbox</varname> of type <varname>stbox</varname> in a table <varname>Trips</varname> is as follows:
					<programlisting>
CREATE TABLE Trips(TripID integer PRIMARY KEY, Trip tgeompoint, bbox stbox);
CREATE INDEX trips_bbox_idx ON Trips USING GIST(bbox);
					</programlisting>
			</para>
			<para>A GiST or SP-GiST index can accelerate queries involving the following operators: <varname>&amp;&amp;</varname>, <varname>&lt;@</varname>, <varname>@&gt;</varname>, <varname>~=</varname>, <varname>-|-</varname>, <varname>&lt;&lt;</varname>, <varname>&gt;&gt;</varname>, <varname>&amp;&lt;</varname>, <varname>&amp;&gt;</varname>, <varname>&lt;&lt;|</varname>, <varname>|&gt;&gt;</varname>, <varname>&amp;&lt;|</varname>, <varname>|&amp;&gt;</varname>,  <varname>&lt;&lt;/</varname>, <varname>/&gt;&gt;</varname>, <varname>&amp;&lt;/</varname>, <varname>/&amp;&gt;</varname>, <varname>&lt;&lt;#</varname>, <varname>#&gt;&gt;</varname>, <varname>&amp;&lt;#</varname>, and <varname>#&amp;&gt;</varname>.</para>

			<para>In addition, B-tree indexes can be created for table columns of a box type. For these index types, basically the only useful operation is equality. There is a B-tree sort ordering defined for values of time types, with corresponding <varname>&lt;</varname> and <varname>&gt;</varname> operators, but the ordering is rather arbitrary and not usually useful in the real world. The B-tree support is primarily meant to allow sorting internally in queries, rather than creation of actual indexes.</para>
		</sect1>
	</chapter>

	<chapter id="manipulating_temporal_types">
		<title>Manipulating Temporal Types</title>
		<para>We present next the functions and operators for temporal types. These functions and operators are polymorphic, that is, their arguments may be of several types, and the result type may depend on the type of the arguments. To express this, we use the following notation:</para>

		<itemizedlist>
			<listitem>
				<para><varname>ttype</varname> represents any temporal type,</para>
			</listitem>

			<listitem>
				<para><varname>time</varname> represents any time type, that is, <varname>timestamptz</varname>, <varname>period</varname>, <varname>timestampset</varname>, or <varname>periodset</varname>,</para>
			</listitem>

			<listitem>
				<para><varname>tnumber</varname> represents any temporal numeric type, that is, <varname>tint</varname> or <varname>tfloat</varname>,</para>
			</listitem>

			<listitem>
				<para><varname>torder</varname> represents any temporal type whose base type has a total order defined, that is, <varname>tint</varname>, <varname>tfloat</varname>, or <varname>ttext</varname>,</para>
			</listitem>

			<listitem>
				<para><varname>tpoint</varname> represents a temporal point type, that is, <varname>tgeompoint</varname> or <varname>tgeogpoint</varname>,</para>
			</listitem>

			<listitem>
				<para><varname>ttypeinst</varname> represents any temporal type with instant duration,</para>
			</listitem>

			<listitem>
				<para><varname>ttypei</varname> represents any temporal type with instant set duration,</para>
			</listitem>

			<listitem>
				<para><varname>ttypeseq</varname> represents any temporal type with sequence duration,</para>
			</listitem>

			<listitem>
				<para><varname>tdiscseq</varname> represents any temporal type with sequence duration and a discrete base type,</para>
			</listitem>

			<listitem>
				<para><varname>tcontseq</varname> represents any temporal type with sequence duration and a continuous base type,</para>
			</listitem>

			<listitem>
				<para><varname>ttypes</varname> represents any temporal type with sequence set duration,</para>
			</listitem>

			<listitem>
				<para><varname>base</varname> represents any base type of a temporal type, that is, <varname>bool</varname>, <varname>int</varname>, <varname>float</varname>, <varname>text</varname>, <varname>geometry</varname>, or <varname>geography</varname>,</para>
			</listitem>

			<listitem>
				<para><varname>number</varname> represents any numeric base type, that is, <varname>int</varname> or <varname>float</varname>,</para>
			</listitem>

			<listitem>
				<para><varname>numrange</varname> represents any numeric range of values, that is, either <varname>intrange</varname> or <varname>floatrange</varname>,</para>
			</listitem>

			<listitem>
				<para><varname>geo</varname> represents either <varname>geometry</varname> or <varname>geography</varname>,</para>
			</listitem>

			<listitem>
				<para><varname>point</varname> represents a <varname>geometry</varname> or a <varname>geography</varname> restricted to a point.</para>
			</listitem>

			<listitem>
				<para><varname>type[]</varname> represents an array of <varname>type</varname>.</para>
			</listitem>
		</itemizedlist>
				
		<para>A common way to generalize the traditional operations to the temporal types is to apply the operation at each instant, which yields a temporal value as result. In that case, the operation is only defined on the intersection of the emporal extents of the operands; if the temporal extents are disjoint, then the result is null. For example, the temporal comparison operators, such as <varname>#&lt;</varname>, test whether the values taken by their operands at each instant satisfy the condition and return a temporal Boolean. Examples of the various generalizations of the operators are given next.
			<programlisting>
-- Temporal comparison
SELECT tint '[2@2001-01-01, 2@2001-01-03)' #&lt; tfloat '[1@2001-01-01, 3@2001-01-03)';
-- "{[f@2001-01-01, f@2001-01-02], (t@2001-01-02, t@2001-01-03)}"
SELECT tfloat '[1@2001-01-01, 3@2001-01-03)' #&lt; tfloat '[3@2001-01-03, 1@2001-01-05)';
-- NULL
-- Temporal addition
SELECT tint '[1@2001-01-01, 1@2001-01-03)' + tint '[2@2001-01-02, 2@2001-01-05)';
-- "[3@2001-01-02, 3@2001-01-03)"
-- Temporal intersects
SELECT tintersects(tgeompoint '[Point(0 1)@2001-01-01, Point(3 1)@2001-01-04)',
	geometry 'Polygon((1 0,1 2,2 2,2 0,1 0))');
-- "{[f@2001-01-01, t@2001-01-02, t@2001-01-03], (f@2001-01-03, f@2001-01-04]}"
-- Temporal distance
SELECT tgeompoint '[Point(0 0)@2001-01-01 08:00:00, Point(0 1)@2001-01-03 08:10:00)' &lt;-&gt;
	tgeompoint '[Point(0 0)@2001-01-02 08:05:00, Point(1 1)@2001-01-05 08:15:00)';
-- "[0.5@2001-01-02 08:05:00+00, 0.745184033794557@2001-01-03 08:10:00+00)"
			</programlisting>
		</para>
			
		<para>Another common requirement is to determine whether the operands ever or always satisfy a condition with respect to an operation. These can be obtained by applying the ever/always comparison operators. These operators are denoted by prefixing the traditional comparison operators with, respectively, <varname>?</varname> (ever) and <varname>%</varname> (always). Examples of ever and always comparison operators are given next.
			<programlisting>
-- Does the operands ever intersect?
SELECT tintersects(tgeompoint '[Point(0 1)@2001-01-01, Point(3 1)@2001-01-04)',
	geometry 'Polygon((1 0,1 2,2 2,2 0,1 0))') ?= true;
-- true
-- Does the operands always intersect?
SELECT tintersects(tgeompoint '[Point(0 1)@2001-01-01, Point(3 1)@2001-01-04)',
	geometry 'Polygon((0 0,0 2,4 2,4 0,0 0))') %= true;
-- true
-- Is the left operand ever less than the right one ?
SELECT (tfloat '[1@2001-01-01, 3@2001-01-03)' #&lt;
	tfloat '[3@2001-01-01, 1@2001-01-03)') ?= true;
-- true
-- Is the left operand always less than the right one ?
SELECT (tfloat '[1@2001-01-01, 3@2001-01-03)' #&lt;
	tfloat '[2@2001-01-01, 4@2001-01-03)') %= true;
-- true
			</programlisting>
		For efficiency reasons, some common operations with the ever or the always semantics are natively provided. For example, the <varname>intersects</varname> function determines whether there is an instant at which the two arguments spatially intersect.</para>

		<para>We describe next the functions and operators for temporal types. For conciseness, in the examples we mostly use sequences composed of two instants.</para>

		<sect1 id="input_output_temporal_tyes">
			<title>Input/Output of Temporal Types</title>
			<para>A temporal instant value is a couple of the form <varname>v@t</varname>, where <varname>v</varname> is a value of the base type and <varname>t</varname> is a <varname>timestamptz</varname> value. A temporal sequence value is a set of values <varname>v1@t1,...,vn@tn</varname> delimited by a lower and an upper bounds that can be inclusive (represented by &lsquo;<varname>[</varname>' and &lsquo;<varname>]</varname>') or exclusive (represented by &lsquo;<varname>(</varname>' and &lsquo;<varname>)</varname>'). Examples of input of temporal unit values are as follows:
				<programlisting>
SELECT tbool 'true@2001-01-01 08:00:00';
SELECT tint '1@2001-01-01 08:00:00';
SELECT tfloat '1.5@2001-01-01 08:00:00';
SELECT ttext 'AAA@2001-01-01 08:00:00';
SELECT tgeompoint 'Point(0 0)@2017-01-01 08:00:05';
SELECT tgeogpoint 'Point(0 0)@2017-01-01 08:00:05';
SELECT tbool '[true@2001-01-01 08:00:00, true@2001-01-03 08:00:00]';
SELECT tint '[1@2001-01-01 08:00:00, 1@2001-01-03 08:00:00]';
SELECT tfloat '[2.5@2001-01-01 08:00:00, 3@2001-01-03 08:00:00, 1@2001-01-04 08:00:00]';
SELECT tfloat '[1.5@2001-01-01 08:00:00]';  -- Instant sequence
SELECT ttext '[BBB@2001-01-01 08:00:00, BBB@2001-01-03 08:00:00]';
SELECT tgeompoint '[Point(0 0)@2017-01-01 08:00:00, Point(0 0)@2017-01-01 08:05:00)';
SELECT tgeogpoint '[Point(0 0)@2017-01-01 08:00:00, Point(0 1)@2017-01-01 08:05:00,
	Point(0 0)@2017-01-01 08:10:00)';
				</programlisting>
			</para>
			
			<para>The temporal extent of a temporal instant value is a single instant while the temporal extent of temporal sequence value is a period defined by the first and last instants as well as the upper and lower bounds.</para>

			<para>A temporal set value is a set <varname>{v1,...,vn}</varname> where every <varname>vi</varname> is a temporal unit value of the corresponding type. Examples of input of temporal set values are as follows:
				<programlisting>
SELECT tbool '{true@2001-01-01 08:00:00, false@2001-01-03 08:00:00}';
SELECT tint '{1@2001-01-01 08:00:00, 2@2001-01-03 08:00:00}';
SELECT tfloat '{1.0@2001-01-01 08:00:00, 2.0@2001-01-03 08:00:00}';
SELECT ttext '{AAA@2001-01-01 08:00:00, BBB@2001-01-03 08:00:00}';
SELECT tgeompoint '{Point(0 0)@2017-01-01 08:00:00, Point(0 1)@2017-01-02 08:05:00}';
SELECT tgeogpoint '{Point(0 0)@2017-01-01 08:00:00, Point(0 1)@2017-01-02 08:05:00}';
SELECT tbool '{[false@2001-01-01 08:00:00, false@2001-01-03 08:00:00),
	[true@2001-01-03 08:00:00], (false@2001-01-04 08:00:00, false@2001-01-06 08:00:00]}';
SELECT tint '{[1@2001-01-01 08:00:00, 1@2001-01-03 08:00:00),
	[2@2001-01-04 08:00:00, 3@2001-01-05 08:00:00, 3@2001-01-06 08:00:00]}';
SELECT tfloat '{[1@2001-01-01 08:00:00, 2@2001-01-03 08:00:00, 2@2001-01-04 08:00:00,
	3@2001-01-06 08:00:00]}';
SELECT ttext '{[AAA@2001-01-01 08:00:00, BBB@2001-01-03 08:00:00, BBB@2001-01-04 08:00:00),
	[CCC@2001-01-05 08:00:00, CCC@2001-01-06 08:00:00]}';
SELECT tgeompoint '{[Point(0 0)@2017-01-01 08:00:00, Point(0 1)@2017-01-01 08:05:00),
	[Point(0 1)@2017-01-01 08:10:00, Point(1 1)@2017-01-01 08:15:00)}';
SELECT tgeogpoint '{[Point(0 0)@2017-01-01 08:00:00, Point(0 1)@2017-01-01 08:05:00),
	[Point(0 1)@2017-01-01 08:10:00, Point(1 1)@2017-01-01 08:15:00)}';
				</programlisting>
			The temporal extent of a temporal instant set value is a set of instants while the temporal extent of temporal sequence set value is a set of periods.</para>

			<para>Temporal values of sequence or sequence set duration whose base type is continuous may specify that the interpolation is stepwise. If this is not specified, it is supposed that the interpolation is linear by default.
				<programlisting>
-- Linear interpolation by default				
SELECT tfloat '[2.5@2001-01-01, 3@2001-01-03, 1@2001-01-04]';
SELECT tgeompoint '{[Point(2.5 2.5)@2001-01-01, Point(3 3)@2001-01-03],
	[Point(1 1)@2001-01-04, Point(1 1)@2001-01-04]}';
-- Stepwise interpolation
SELECT tfloat 'Interp=Stepwise;[2.5@2001-01-01, 3@2001-01-03, 1@2001-01-04]';
SELECT tgeompoint 'Interp=Stepwise;{[Point(2.5 2.5)@2001-01-01, Point(3 3)@2001-01-03],
	[Point(1 1)@2001-01-04, Point(1 1)@2001-01-04]}';
				</programlisting>
			For temporal values of sequence set duration all component sequences are supposed to be in the same interpolation, either stepwise or linear, as in the examples above.
			</para>

			<para>For temporal points, it is possible to specify the spatial reference identifier (SRID) using the Extended Well-Known text (EWKT) representation as follows: 
				<programlisting>
SELECT tgeompoint 'SRID=5435;[Point(0 0)@2000-01-01,Point(0 1)@2000-01-02]'
				</programlisting>
			All components geometries will then be of the given SRID. Furthermore, each component geometry can specify its SRID with the EWKT format as in the following example
				<programlisting>
SELECT tgeompoint '[SRID=5435;Point(0 0)@2000-01-01,SRID=5435;Point(0 1)@2000-01-02]'
				</programlisting>
			An error is raised if the component geometries are not all in the same SRID or if the SRID of a component geometry is different from the one of the temporal point
				<programlisting>
SELECT tgeompoint '[SRID=5435;Point(0 0)@2000-01-01,SRID=4326;Point(0 1)@2000-01-02]';
ERROR: Geometry SRID (4326) does not match temporal type SRID (5435)
SELECT tgeompoint 'SRID=5435;[SRID=4326;Point(0 0)@2000-01-01,
	SRID=4326;Point(0 1)@2000-01-02]'
ERROR: Geometry SRID (4326) does not match temporal type SRID (5435)
				</programlisting>
			</para>
		</sect1>

		<sect1 id="constructor_temporal_tyes">
			<title>Constructor Functions</title>

			<para>Each temporal type has constructor functions with the same name as the type and with a suffix for the duration, where the suffix &lsquo;<varname>inst</varname>&rsquo;, &lsquo;<varname>i</varname>&rsquo;, &lsquo;<varname>seq</varname>&rsquo;, and &lsquo;<varname>s</varname>&rsquo; correspond, respectively, to the durations instant, instant set, sequence, and sequence set. Examples are <varname>tintseq</varname> or <varname>tgeompoints</varname>. Using the constructor function is frequently more convenient than writing a literal constant.
			</para>

			<itemizedlist>
				<listitem>
					<para>A first set of constructor functions have two arguments, a base type and a time type, where the latter is a <varname>timestamptz</varname>, a <varname>timestampset</varname>, a <varname>period</varname>, or a <varname>periodset</varname> value for constructing, respectively, a temporal instant, instant set, sequence, or sequence set value. The constructors for temporal sequence or sequence set values with continuous base type have in addition an optional third argument which is a Boolean for stating whether the resulting temporal value has linear interpolation or not. By default this argument is true if it is not specified.</para>
				</listitem>

				<listitem>
					<para>Another set of constructor functions for temporal instant set values have a single argument, which is an array of values of the corresponding instant values.</para>
				</listitem>
			
				<listitem>
					<para>Another set of constructor functions for temporal sequence values have one argument for the array of values of the corresponding instant duration and two optional Boolean arguments stating, respectively, whether the left and right bounds are inclusive or exclusive. It the these arguments are not specified they are assumed to be true by default. In addition, the constructor functions for temporal sequence values with continuous base type have an additional Boolean argument stating whether the interpolation is linear or not. It this argument is not specified it is assumed to be true by default.</para>
				</listitem>
			
				<listitem>
					<para>Another set of constructor functions for temporal sequence set values have a single argument, which is an array of values of the corresponding sequence values. For temporal sequence values with continuous base type, the interpolation of the resulting temporal value depends on the interpolation of the composing sequences. An error is raised if the sequences composing the array have different interpolation.</para>
				</listitem>
			</itemizedlist>
			
			<para>We give next the constructor functions for the various durations.</para>
			
			<itemizedlist>
				<listitem id="ttypeinst">
					<para>Constructor for temporal types of instant duration</para>
					<para><varname>ttypeinst(base, timestamptz): ttypeinst</varname></para>
					<programlisting>
SELECT tboolinst(true, '2001-01-01');
SELECT tfloatinst(1.5, '2001-01-01');
SELECT tgeompointinst('Point(0 0)', '2001-01-01');
					</programlisting>
				</listitem>

				<listitem id="ttypei">
					<para>Constructor for temporal types of instant set duration</para>
					<para><varname>ttypei(base, timestampset): ttypei</varname></para>
					<para><varname>ttypei(ttypeinst[]]): ttypei</varname></para>
					<programlisting>
SELECT tinti(2, '{2001-01-01, 2001-01-02, 2001-01-03}');
SELECT tgeompointi('Point(0 0)', '{2001-01-01, 2001-01-02}');
SELECT tbooli(ARRAY[tbool 'true@2001-01-01 08:00:00', 'false@2001-01-01 08:05:00']);
SELECT tinti(ARRAY[tint '1@2001-01-01 08:00:00', '2@2001-01-01 08:05:00']);
SELECT tfloati(ARRAY[tfloat '1.0@2001-01-01 08:00:00', '2.0@2001-01-01 08:05:00']);
SELECT ttexti(ARRAY[ttext 'AAA@2001-01-01 08:00:00', 'BBB@2001-01-01 08:05:00']);
SELECT tgeompointi(ARRAY[tgeompoint 'Point(0 0)@2001-01-01 08:00:00',
	'Point(0 1)@2001-01-01 08:05:00', 'Point(1 1)@2001-01-01 08:10:00']);
SELECT tgeogpointi(ARRAY[tgeogpoint 'Point(1 1)@2001-01-01 08:00:00',
	'Point(2 2)@2001-01-01 08:05:00']);
					</programlisting>
				</listitem>

				<listitem id="ttypeseq">
					<para>Constructor for temporal types of sequence duration</para>
					<para><varname>tdiscseq(base, period): tdiscseq</varname></para>
					<para><varname>tdiscseq(ttypeinst[], left_inc = true, right_inc = true}): tdiscseq</varname></para>
					<para><varname>tcontseq(base, period, linear = true): tcontseq</varname></para>
					<para><varname>tcontseq(ttypeinst[], left_inc = true, right_inc = true, linear = true}): tcontseq</varname></para>
					<programlisting>
SELECT tfloatseq(1.5, '[2001-01-01, 2001-01-02]');
SELECT tfloatseq(2.0, '[2001-01-01, 2001-01-02]', false);
SELECT tboolseq(ARRAY[tbool 'true@2001-01-01 08:00:00', 'true@2001-01-03 08:05:00'],
	true, true);
SELECT tintseq(ARRAY[tintinst(2,'2001-01-01 08:00:00'),
	tintinst(2,'2001-01-01 08:10:00')], true, false);
SELECT tfloatseq(ARRAY[tfloat '2.0@2001-01-01 08:00:00', '3@2001-01-03 08:05:00',
	'1@2001-01-03 08:10:00'], true, false);
SELECT tfloatseq(ARRAY[tfloat '2.0@2001-01-01 08:00:00', '3@2001-01-03 08:05:00',
	'1@2001-01-03 08:10:00'], true, true, false);
SELECT ttextseq(ARRAY[ttextinst('AAA', '2001-01-01 08:00:00'),
	ttextinst('BBB', '2001-01-03 08:05:00'), ttextinst('BBB', '2001-01-03 08:10:00')]);
SELECT tgeompointseq(ARRAY[tgeompoint 'Point(0 0)@2001-01-01 08:00:00',
	'Point(0 1)@2001-01-03 08:05:00', 'Point(1 1)@2001-01-03 08:10:00']);
SELECT tgeogpointseq(ARRAY[tgeogpoint 'Point(0 0)@2001-01-01 08:00:00',
	'Point(0 0)@2001-01-03 08:05:00'], true, true, false);
					</programlisting>
				</listitem>

				<listitem id="ttypes">
					<para>Constructors for temporal types of sequence set duration</para>
					<para><varname>tdiscs(base, periodset): tdiscs</varname></para>
					<para><varname>tconts(base, periodset, linear = true): tconts</varname></para>
					<para><varname>ttypes(ttypeseq[]): ttypes</varname></para>
					<programlisting>
SELECT ttexts('AAA', '{[2001-01-01, 2001-01-02], [2001-01-03, 2001-01-04]}');
SELECT tgeogpointseq('Point(1 1)', '[2001-01-01, 2001-01-02]', false);
SELECT tbools(ARRAY[tbool '[false@2001-01-01 08:00:00, false@2001-01-01 08:05:00)',
	'[true@2001-01-01 08:05:00]','(false@2001-01-01 08:05:00, false@2001-01-01 08:10:00)']);
SELECT tints(ARRAY[tint '[1@2001-01-01 08:00:00, 2@2001-01-01 08:05:00,
	2@2001-01-01 08:10:00, 2@2001-01-01 08:15:00)']);
SELECT tfloats(ARRAY[tfloat '[1.0@2001-01-01 08:00:00, 2.0@2001-01-01 08:05:00,
	2.0@2001-01-01 08:10:00]', '[2.0@2001-01-01 08:15:00, 3.0@2001-01-01 08:20:00)']);
SELECT tfloats(ARRAY[tfloat 'Interp=Stepwise;[1.0@2001-01-01 08:00:00,
	2.0@2001-01-01 08:05:00, 2.0@2001-01-01 08:10:00]',
	'Interp=Stepwise;[3.0@2001-01-01 08:15:00, 3.0@2001-01-01 08:20:00)']);
SELECT ttexts(ARRAY[ttext '[AAA@2001-01-01 08:00:00, AAA@2001-01-01 08:05:00)',
	'[BBB@2001-01-01 08:10:00, BBB@2001-01-01 08:15:00)']);
SELECT tgeompoints(ARRAY[tgeompoint '[Point(0 0)@2001-01-01 08:00:00,
	Point(0 1)@2001-01-01 08:05:00, Point(0 1)@2001-01-01 08:10:00)',
	'[Point(0 1)@2001-01-01 08:15:00, Point(0 0)@2001-01-01 08:20:00)']);
SELECT tgeogpoints(ARRAY[tgeogpoint
	'Interp=Stepwise;[Point(0 0)@2001-01-01 08:00:00, Point(0 0)@2001-01-01 08:05:00)',
	'Interp=Stepwise;[Point(1 1)@2001-01-01 08:10:00, Point(1 1)@2001-01-01 08:15:00)']);
SELECT tfloats(ARRAY[tfloat 'Interp=Stepwise;[1.0@2001-01-01 08:00:00,
	2.0@2001-01-01 08:05:00, 2.0@2001-01-01 08:10:00]',
	'[3.0@2001-01-01 08:15:00, 3.0@2001-01-01 08:20:00)']);
-- ERROR:  Input sequences must have the same interpolation
					</programlisting>
				</listitem>
			</itemizedlist>
		</sect1>

		<sect1 id="casting_temporal_types">
			<title>Casting</title>

			<para>A temporal value can be converted into a temporal value of a compatible type. This can be done using the notation <varname>CAST(ttype1 AS ttype2)</varname> or <varname>ttype1::ttype2</varname>.</para>
			<itemizedlist>
				<listitem id="tint_tfloat">
					<para>Cast a temporal integer to a temporal float</para>
					<para><varname>tint::tfloat</varname></para>
					<programlisting>
SELECT tint '[1@2001-01-01, 2@2001-01-03]'::tfloat;
-- "[1@2001-01-01 00:00:00+00, 2@2001-01-03 00:00:00+00]"
SELECT tint '[1@2000-01-01, 2@2000-01-03, 3@2000-01-05]'::tfloat;
-- "Interp=Stepwise;[1@2000-01-01 00:00:00+01, 2@2000-01-03 00:00:00+01, 3@2000-01-05 00:00:00+01]"
					</programlisting>
				</listitem>

				<listitem id="tfloat_tint">
					<para>Cast a temporal float to a temporal integer</para>
					<para><varname>tfloat::tint</varname></para>
					<programlisting>
SELECT tfloat 'Interp=Stepwise;[1.5@2001-01-01, 2.5@2001-01-03]'::tint;
-- "[1@2001-01-01 00:00:00+00, 2@2001-01-03 00:00:00+00]"
SELECT tfloat '[1.5@2001-01-01, 2.5@2001-01-03]'::tint;
-- ERROR:  Cannot cast temporal float with linear interpolation to temporal integer
					</programlisting>
				</listitem>

				<listitem id="tgeompoint_tgeogpoint">
					<para>Cast a temporal geometry point to a temporal geography point</para>
					<para><varname>tgeompoint::tgeogpoint</varname></para>
					<programlisting>
SELECT asText((tgeogpoint 'Point(0 0)@2001-01-01')::tgeompoint);
-- "{POINT(0 0)@2001-01-01}"
					</programlisting>
				</listitem>

				<listitem id="tgeogpoint_tgeompoint">
					<para>Cast a temporal geography point to a temporal geometry point</para>
					<para><varname>tgeogpoint::tgeompoint</varname></para>
					<programlisting>
SELECT asText((tgeompoint '[Point(0 0)@2001-01-01, Point(0 1)@2001-01-02)')::tgeogpoint);
-- "{[POINT(0 0)@2001-01-01, POINT(0 1)@2001-01-02)}"
					</programlisting>
				</listitem>

			</itemizedlist>

			<para>A common way to store temporal points in PostGIS is to represent them as geometries of type <varname>LINESTRING M</varname> and abuse the M dimension to encode timestamps as seconds since 1970-01-01 00:00:00. These time-enhanced geometries, called trajectories, can be validated with the function <varname>ST_IsValidTrajectory</varname> to verify that the M value is growing from each vertex to the next. Trajectories can be manipulated with the functions <varname>ST_ClosestPointOfApproach</varname>, <varname>ST_DistanceCPA</varname>, and <varname>ST_CPAWithin</varname>. Temporal point values can be converted to/from PostGIS trajectories.</para>

			<itemizedlist>
				<listitem id="tgeompoint_geometry">
				<para>Cast a temporal point to a PostGIS trajectory</para>
				<para><varname>tgeompoint::geometry</varname></para>
				<para><varname>tgeogpoint::geography</varname></para>
				<programlisting>
SELECT ST_AsText((tgeompoint 'Point(0 0)@2001-01-01')::geometry);
-- "POINT M (0 0 978307200)"
SELECT ST_AsText((tgeompoint '{Point(0 0)@2001-01-01, Point(1 1)@2001-01-02,
	Point(1 1)@2001-01-03}')::geometry);
-- "MULTIPOINT M (0 0 978307200,1 1 978393600,1 1 978480000)"
SELECT ST_AsText((tgeompoint '[Point(0 0)@2001-01-01, Point(1 1)@2001-01-02)')::geometry);
-- "LINESTRING M (0 0 978307200,1 1 978393600)"
SELECT ST_AsText((tgeompoint '{[Point(0 0)@2001-01-01, Point(1 1)@2001-01-02),
	[Point(1 1)@2001-01-03, Point(1 1)@2001-01-04),
	[Point(1 1)@2001-01-05, Point(0 0)@2001-01-06)}')::geometry);
-- "MULTILINESTRING M ((0 0 978307200,1 1 978393600),(1 1 978480000,1 1 978566400),
(1 1 978652800,0 0 978739200))"
SELECT ST_AsText((tgeompoint '{[Point(0 0)@2001-01-01, Point(1 1)@2001-01-02),
	[Point(1 1)@2001-01-03],
	[Point(1 1)@2001-01-05, Point(0 0)@2001-01-06)}')::geometry);
-- "GEOMETRYCOLLECTION M (LINESTRING M (0 0 978307200,1 1 978393600),
POINT M (1 1 978480000),LINESTRING M (1 1 978652800,0 0 978739200))"
					</programlisting>
				</listitem>

				<listitem id="geometry_tgeompoint">
					<para>Cast a PostGIS trajectory to a temporal point</para>
					<para><varname>geometry::tgeompoint</varname></para>
					<para><varname>geography::tgeogpoint</varname></para>
					<programlisting>
SELECT asText(geometry 'LINESTRING M (0 0 978307200,0 1 978393600,
	1 1 978480000)'::tgeompoint);
-- "[POINT(0 0)@2001-01-01, POINT(0 1)@2001-01-02, POINT(1 1)@2001-01-03]";
SELECT asText(geometry 'GEOMETRYCOLLECTION M (LINESTRING M (0 0 978307200,1 1 978393600),
	POINT M (1 1 978480000),LINESTRING M (1 1 978652800,0 0 978739200))'::tgeompoint);
-- "{[POINT(0 0)@2001-01-01, POINT(1 1)@2001-01-02], [POINT(1 1)@2001-01-03],
	[POINT(1 1)@2001-01-05, POINT(0 0)@2001-01-06]}"
					</programlisting>
				</listitem>
			</itemizedlist>
		</sect1>

		<sect1 id="transformation_functions">
			<title>Transformation Functions</title>
			<para>A temporal value can be transformed to another duration. An error is raised if the durations are incompatible.</para>
			<itemizedlist>
				<listitem id="ttype_transform">
					<para>Transform a temporal value to another duration</para>
					<para><varname>ttypeinst(ttype): ttypeinst</varname></para>
					<para><varname>ttypei(ttype): ttypei</varname></para>
					<para><varname>ttypeseq(ttype): ttypeseq</varname></para>
					<para><varname>ttypes(ttype): ttypes</varname></para>
					<programlisting>
SELECT tboolinst(tbool '{[true@2001-01-01]}');
-- "t@2001-01-01 00:00:00+00"
SELECT tboolinst(tbool '{[true@2001-01-01, true@2001-01-02]}');
-- ERROR: Cannot transform input to a temporal instant
SELECT tbooli(tbool 'true@2001-01-01');
-- "{t@2001-01-01}"
SELECT tintseq(tint '1@2001-01-01');
-- "[1@2001-01-01]"
SELECT tfloats(tfloat '2.5@2001-01-01');
-- "{[2.5@2001-01-01]}"
SELECT tfloats(tfloat '{2.5@2001-01-01, 1.5@2001-01-02, 3.5@2001-01-02}');
-- "{[2.5@2001-01-01],[1.5@2001-01-02],[3.5@2001-01-03]}"
					</programlisting>
				</listitem>

				<listitem id="toLinear">
					<para> Transform a temporal value with continuous base type from stepwise to linear interpolation</para>
					<para><varname>toLinear(ttype) : ttype</varname></para>
				<programlisting>
SELECT toLinear(tfloat 'Interp=Stepwise;[1@2000-01-01, 2@2000-01-02,
	1@2000-01-03, 2@2000-01-04]');
-- "{[1@2000-01-01, 1@2000-01-02), [2@2000-01-02, 2@2000-01-03), 
	[1@2000-01-03, 1@2000-01-04), [2@2000-01-04]}"
SELECT asText(toLinear(tgeompoint 'Interp=Stepwise;{[Point(1 1)@2000-01-01,
	Point(2 2)@2000-01-02], [Point(3 3)@2000-01-05, Point(4 4)@2000-01-06]}'));
-- "{[POINT(1 1)@2000-01-01, POINT(1 1)@2000-01-02), [POINT(2 2)@2000-01-02], 
	[POINT(3 3)@2000-01-05, POINT(3 3)@2000-01-06), [POINT(4 4)@2000-01-06]}"
				</programlisting>
				</listitem>

				<listitem id="appendInstant">
					<para>Append a temporal instant to a temporal value</para>
					<para><varname>appendInstant(ttype, ttypeinst) : ttype</varname></para>
				<programlisting>
SELECT appendInstant(tint '1@2000-01-01', tint '1@2000-01-02');
-- "{1@2000-01-01, 1@2000-01-02}"
SELECT appendInstant(tintseq(tint '1@2000-01-01'), tint '1@2000-01-02');
-- "[1@2000-01-01, 1@2000-01-02]"
SELECT asText(appendInstant(tgeompoint '{[Point(1 1 1)@2000-01-01, 
	Point(2 2 2)@2000-01-02], [Point(3 3 3)@2000-01-04, Point(3 3 3)@2000-01-05]}', 
	tgeompoint 'Point(1 1 1)@2000-01-06'));
-- "{[POINT Z (1 1 1)@2000-01-01, POINT Z (2 2 2)@2000-01-02], 
	[POINT Z (3 3 3)@2000-01-04, POINT Z (3 3 3)@2000-01-05, POINT Z (1 1 1)@2000-01-06]}"
				</programlisting>
				</listitem>

				<listitem id="merge">
					<para>Merge temporal values</para>
					<para><varname>merge(ttype, ttype) : ttype</varname></para>
					<para><varname>merge(ttype[]) : ttype</varname></para>
					<para>The values may share a single timestamp, in that case the temporal values are joined in the result if their value at the common timestamp is the same, otherwise an error is raised.</para>
					<programlisting>
SELECT merge(tint '1@2000-01-01', tint '1@2000-01-02');
-- "{1@2000-01-01, 1@2000-01-02}"
SELECT merge(tint '[1@2000-01-01, 2@2000-01-02]', tint '[2@2000-01-02, 1@2000-01-03]');
-- "[1@2000-01-01, 2@2000-01-02, 1@2000-01-03]"
SELECT merge(tint '[1@2000-01-01, 2@2000-01-02]', tint '[3@2000-01-03, 1@2000-01-04]');
-- "{[1@2000-01-01, 2@2000-01-02], [3@2000-01-03, 1@2000-01-04]}"
SELECT merge(tint '[1@2000-01-01, 2@2000-01-02]', tint '[1@2000-01-02, 2@2000-01-03]');
-- ERROR:  Both arguments have different value at their overlapping timestamp
SELECT asText(merge(tgeompoint '{[Point(1 1 1)@2000-01-01,
	Point(2 2 2)@2000-01-02], [Point(3 3 3)@2000-01-04, Point(3 3 3)@2000-01-05]}',
	tgeompoint '{[Point(3 3 3)@2000-01-05, Point(1 1 1)@2000-01-06]}'));
-- "{[POINT Z (1 1 1)@2000-01-01, POINT Z (2 2 2)@2000-01-02],
	[POINT Z (3 3 3)@2000-01-04, POINT Z (3 3 3)@2000-01-05, POINT Z (1 1 1)@2000-01-06]}"

SELECT merge(ARRAY[tint '1@2000-01-01', '1@2000-01-02']);
-- "{1@2000-01-01, 1@2000-01-02}"
SELECT merge(ARRAY[tint '{1@2000-01-01, 2@2000-01-02}', '{2@2000-01-02, 3@2000-01-03}']);
-- "{1@2000-01-01, 2@2000-01-02, 3@2000-01-03}"
SELECT merge(ARRAY[tint '{1@2000-01-01, 2@2000-01-02}', '{3@2000-01-03, 4@2000-01-04}']);
-- "{1@2000-01-01, 2@2000-01-02, 3@2000-01-03, 4@2000-01-04}"
SELECT merge(ARRAY[tint '[1@2000-01-01, 2@2000-01-02]', '[2@2000-01-02, 1@2000-01-03]']);
-- "[1@2000-01-01, 2@2000-01-02, 1@2000-01-03]"
SELECT merge(ARRAY[tint '[1@2000-01-01, 2@2000-01-02]', '[3@2000-01-03, 4@2000-01-04]']);
-- "{[1@2000-01-01, 2@2000-01-02], [3@2000-01-03, 4@2000-01-04]}"
SELECT merge(ARRAY[tgeompoint '{[Point(1 1)@2000-01-01, Point(2 2)@2000-01-02],
	[Point(3 3)@2000-01-03, Point(4 4)@2000-01-04]}', '{[Point(4 4)@2000-01-04,
	Point(3 3)@2000-01-05], [Point(6 6)@2000-01-06, Point(7 7)@2000-01-07]}']);
-- "{[Point(1 1)@2000-01-01, Point(2 2)@2000-01-02], [Point(3 3)@2000-01-03,
	Point(4 4)@2000-01-04, Point(3 3)@2000-01-05],
	[Point(6 6)@2000-01-06, Point(7 7)@2000-01-07]}"
SELECT merge(ARRAY[tgeompoint '{[Point(1 1)@2000-01-01, Point(2 2)@2000-01-02]}',
	'{[Point(2 2)@2000-01-02, Point(1 1)@2000-01-03]}']);
-- "[Point(1 1)@2000-01-01, Point(2 2)@2000-01-02, Point(1 1)@2000-01-03]"
					</programlisting>
				</listitem>

			</itemizedlist>
		</sect1>

		<sect1>
			<title>Accessor Functions</title>
			<itemizedlist>

				<listitem id="ttype_memSize">
					<para>Get the memory size in bytes</para>
					<para><varname>memSize(ttype): integer</varname></para>
					<programlisting>
SELECT memSize(tint '{1@2012-01-01, 2@2012-01-02, 3@2012-01-03}');
-- 280
					</programlisting>
				</listitem>

				<listitem id="duration">
					<para>Get the duration</para>
					<para><varname>duration(ttype): {'Instant', 'InstantSet', 'Sequence', 'SequenceSet'}</varname></para>
					<programlisting>
SELECT duration(tint '[1@2012-01-01, 2@2012-01-02, 3@2012-01-03]');
-- "Sequence"
					</programlisting>
				</listitem>

				<listitem id="interpolation">
					<para>Get the interpolation</para>
					<para><varname>interpolation(ttype): {'Discrete', 'Stepwise', 'Linear'}</varname></para>
					<programlisting>
SELECT interpolation(tfloat '{1@2012-01-01, 2@2012-01-02, 3@2012-01-03}');
-- "Discrete"
SELECT interpolation(tint '[1@2012-01-01, 2@2012-01-02, 3@2012-01-03]');
-- "Stepwise"
SELECT interpolation(tfloat '[1@2012-01-01, 2@2012-01-02, 3@2012-01-03]');
-- "Linear"
SELECT interpolation(tfloat 'Interp=Stepwise;[1@2012-01-01, 2@2012-01-02, 3@2012-01-03]');
-- "Stepwise"
SELECT interpolation(tgeompoint 'Interp=Stepwise;[Point(1 1)@2012-01-01, Point(2 2)@2012-01-02, Point(3 3)@2012-01-03]');
-- "Stepwise"
					</programlisting>
				</listitem>

				<listitem id="getValue">
					<para>Get the value</para>
					<para><varname>getValue(ttypeinst): base</varname></para>
					<programlisting>
SELECT getValue(tint '1@2012-01-01');
-- 1
SELECT ST_AsText(getValue(tgeompoint 'Point(0 0)@2012-01-01'));
-- "POINT(0 0)"
					</programlisting>
				</listitem>

				<listitem id="getValues">
					<para>Get the values</para>
					<para><varname>getValues(ttype): {base[], floatrange[], geo}</varname></para>
					<programlisting>
SELECT getValues(tint '[1@2012-01-01, 2@2012-01-03]');
-- "{1,2}"
SELECT getValues(tfloat '[1@2012-01-01, 2@2012-01-03)');
-- "{[1,2)}"
SELECT getValues(tfloat '{[1@2012-01-01, 2@2012-01-03), [3@2012-01-03, 4@2012-01-05)}');
-- "{[1,2),[3,4)}"
SELECT getValues(tfloat 'Interp=Stepwise;{[1@2012-01-01, 2@2012-01-02],
	[3@2012-01-03, 4@2012-01-05]}');
-- "{"[1,1]","[2,2]","[3,3]","[4,4]"}"
SELECT ST_AsText(getValues(tgeompoint '{[Point(0 0)@2012-01-01, Point(0 1)@2012-01-02),
	[Point(0 1)@2012-01-03, Point(1 1)@2012-01-04)}'));
-- "LINESTRING(0 0,0 1,1 1)"
SELECT ST_AsText(getValues(tgeompoint '{[Point(0 0)@2012-01-01, Point(0 1)@2012-01-02),
	[Point(1 1)@2012-01-03, Point(2 2)@2012-01-04)}'));
-- "MULTILINESTRING((0 0,0 1),(1 1,2 2)"
SELECT ST_AsText(getValues(tgeompoint 'Interp=Stepwise;{[Point(0 0)@2012-01-01,
	Point(0 1)@2012-01-02], [Point(0 1)@2012-01-03, Point(1 1)@2012-01-04]}'));
-- "GEOMETRYCOLLECTION(MULTIPOINT(0 0,0 1),MULTIPOINT(0 1,1 1))"
SELECT ST_AsText(getValues(tgeompoint '{Point(0 0)@2012-01-01, Point(0 1)@2012-01-02}'));
-- "MULTIPOINT(0 0,0 1)"
SELECT ST_AsText(getValues(tgeompoint '{[Point(0 0)@2012-01-01, Point(0 1)@2012-01-02),
	[Point(1 1)@2012-01-03, Point(1 1)@2012-01-04), 
	[Point(2 1)@2012-01-05, Point(2 2)@2012-01-06)}'));
-- "GEOMETRYCOLLECTION(POINT(1 1),LINESTRING(0 0,0 1),LINESTRING(2 1,2 2))"
					</programlisting>
				</listitem>

				<listitem id="startValue">
					<para>Get the start value</para>
					<para><varname>startValue(ttype): base</varname></para>
					<para>The function does not take into account whether the bounds are inclusive or not.</para>
					<programlisting>
SELECT startValue(tfloat '(1@2012-01-01, 2@2012-01-03)');
-- 1
					</programlisting>
				</listitem>

				<listitem id="endValue">
					<para>Get the end value</para>
					<para><varname>endValue(ttype): base</varname></para>
					<para>The function does not take into account whether the bounds are inclusive or not.</para>
					<programlisting>
SELECT endValue(tfloat '{[1@2012-01-01, 2@2012-01-03), [3@2012-01-03, 5@2012-01-05)}');
-- 5
					</programlisting>
				</listitem>

				<listitem id="minValue">
					<para>Get the minimum value</para>
					<para><varname>minValue(torder): base</varname></para>
					<para>The function does not take into account whether the bounds are inclusive or not.</para>
					<programlisting>
SELECT minValue(tfloat '{1@2012-01-01, 2@2012-01-03, 3@2012-01-05}');
-- 1
					</programlisting>
				</listitem>

				<listitem id="maxValue">
					<para>Get the maximum value</para>
					<para><varname>maxValue(torder): base</varname></para>
					<para>The function does not take into account whether the bounds are inclusive or not.</para>
					<programlisting>
SELECT maxValue(tfloat '{[1@2012-01-01, 2@2012-01-03), [3@2012-01-03, 5@2012-01-05)}');
-- 5
					</programlisting>
				</listitem>

				<listitem id="valueRange">
					<para>Get the value range</para>
					<para><varname>valueRange(tnumber): numrange</varname></para>
					<para>The function does not take into account whether the bounds are inclusive or not.</para>
					<programlisting>
SELECT valueRange(tfloat '{[2@2012-01-01, 1@2012-01-03), [4@2012-01-03, 6@2012-01-05)}');
-- "[1,6]"
SELECT valueRange(tfloat '{1@2012-01-01, 2@2012-01-03, 3@2012-01-05}');
-- "[1,3])"
					</programlisting>
				</listitem>

				<listitem id="valueAtTimestamp">
					<para>Get the value at a timestamp</para>
					<para><varname>valueAtTimestamp(ttype, timestamptz): base</varname></para>
					<programlisting>
SELECT valueAtTimestamp(tfloat '[1@2012-01-01, 4@2012-01-04)', '2012-01-02');
-- "2"
					</programlisting>
				</listitem>

				<listitem id="getTimestamp">
					<para>Get the timestamp</para>
					<para><varname>getTimestamp(ttypeinst): timestamptz</varname></para>
					<programlisting>
SELECT getTimestamp(tint '1@2012-01-01');
-- "2012-01-01"
					</programlisting>
				</listitem>

				<listitem id="getTime">
					<para>Get the time</para>
					<para><varname>getTime(ttype): periodset</varname></para>
					<programlisting>
SELECT getTime(tint '[1@2012-01-01, 1@2012-01-15)');
-- "{[2012-01-01, 2012-01-15)}"
					</programlisting>
				</listitem>

				<listitem id="timespan">
					<para>Get the timespan</para>
					<para><varname>timespan(ttype): interval</varname></para>
					<programlisting>
SELECT timespan(tfloat '{[1@2012-01-01, 2@2012-01-03), [2@2012-01-04, 2@2012-01-05)}');
-- "3 days"
					</programlisting>
				</listitem>

				<listitem id="ttype_period">
					<para>Get the period on which the temporal value is defined ignoring the potential time gaps</para>
					<para><varname>period(ttype): period</varname></para>
					<programlisting>
SELECT period(tint '{1@2012-01-01, 2@2012-01-03, 3@2012-01-05}');
-- "[2012-01-01, 2012-01-05]"
SELECT period(tfloat '{[1@2012-01-01, 1@2012-01-02), [2@2012-01-03, 3@2012-01-04)}');
-- "[2012-01-01, 2012-01-04)"
					</programlisting>
				</listitem>

				<listitem id="numInstants">
					<para>Get the number of different instants</para>
					<para><varname>numInstants(ttype): int</varname></para>
					<programlisting>
SELECT numInstants(tfloat '{[1@2000-01-01, 2@2000-01-02), (2@2000-01-02, 3@2000-01-03)}');
-- 3
					</programlisting>
				</listitem>

				<listitem id="startInstant">
					<para>Get the start instant</para>
					<para><varname>startInstant(ttype): ttypeinst</varname></para>
					<para>The function does not take into account whether the bounds are inclusive or not.</para>
					<programlisting>
SELECT startInstant(tfloat '{[1@2000-01-01, 2@2000-01-02), 
	(2@2000-01-02, 3@2000-01-03)}');
-- "1@2000-01-01"
					</programlisting>
				</listitem>

				<listitem id="endInstant">
					<para>Get the end instant</para>
					<para><varname>endInstant(ttype): ttypeinst</varname></para>
					<para>The function does not take into account whether the bounds are inclusive or not.</para>
					<programlisting>
SELECT endInstant(tfloat '{[1@2000-01-01, 2@2000-01-02), (2@2000-01-02, 3@2000-01-03)}');
-- "3@2000-01-03"
					</programlisting>
				</listitem>

				<listitem id="instantN">
					<para>Get the n-th different instant</para>
					<para><varname>instantN(ttype, int): ttypeinst</varname></para>
					<programlisting>
SELECT instantN(tfloat '{[1@2000-01-01, 2@2000-01-02), (2@2000-01-02, 3@2000-01-03)}', 3);
-- "3@2000-01-03"
					</programlisting>
				</listitem>

				<listitem id="instants">
					<para>Get the different instants</para>
					<para><varname>instants(ttype): ttypeinst[]</varname></para>
					<programlisting>
SELECT instants(tfloat '{[1@2000-01-01, 2@2000-01-02), (2@2000-01-02, 3@2000-01-03)}');
-- "{"1@2000-01-01","2@2000-01-02","3@2000-01-03"}"
					</programlisting>
				</listitem>

				<listitem id="ttype_numTimestamps">
					<para>Get the number of different timestamps</para>
					<para><varname>numTimestamps(ttype): int</varname></para>
					<programlisting>
SELECT numTimestamps(tfloat '{[1@2012-01-01, 2@2012-01-03), 
	[3@2012-01-03, 5@2012-01-05)}');
-- 3
					</programlisting>
				</listitem>

				<listitem id="ttype_startTimestamp">
					<para>Get the start timestamp</para>
					<para>The function does not take into account whether the bounds are inclusive or not.</para>
					<para><varname>startTimestamp(ttype): timestamptz</varname></para>
					<programlisting>
SELECT startTimestamp(tfloat '[1@2012-01-01, 2@2012-01-03)');
-- "2012-01-01"
					</programlisting>
				</listitem>

				<listitem id="ttype_endTimestamp">
					<para>Get the end timestamp</para>
					<para><varname>endTimestamp(ttype): timestamptz</varname></para>
					<para>The function does not take into account whether the bounds are inclusive or not.</para>
					<programlisting>
SELECT endTimestamp(tfloat '{[1@2012-01-01, 2@2012-01-03), 
	[3@2012-01-03, 5@2012-01-05)}');
-- "2012-01-05"
					</programlisting>
				</listitem>

				<listitem id="ttype_timestampN">
					<para>Get the n-th different timestamp</para>
					<para><varname>timestampN(ttype, int): timestamptz</varname></para>
					<programlisting>
SELECT timestampN(tfloat '{[1@2012-01-01, 2@2012-01-03), 
	[3@2012-01-03, 5@2012-01-05)}', 3);
-- "2012-01-05"
					</programlisting>
				</listitem>

				<listitem id="ttype_timestamps">
					<para>Get the different timestamps</para>
					<para><varname>timestamps(ttype): timestamptz[]</varname></para>
					<programlisting>
SELECT timestamps(tfloat '{[1@2012-01-01, 2@2012-01-03), [3@2012-01-03, 5@2012-01-05)}');
-- "{"2012-01-01", "2012-01-03", "2012-01-05"}"
					</programlisting>
				</listitem>

				<listitem id="numSequences">
					<para>Get the number of sequences</para>
					<para><varname>numSequences({ttypeseq,ttypes}): int</varname></para>
					<programlisting>
SELECT numSequences(tfloat '{[1@2012-01-01, 2@2012-01-03), 
	[3@2012-01-03, 5@2012-01-05)}');
-- 2
					</programlisting>
				</listitem>

				<listitem id="startSequence">
					<para>Get the start sequence</para>
					<para><varname>startSequence({ttypeseq,ttypes}): ttypeseq</varname></para>
					<programlisting>
SELECT startSequence(tfloat '{[1@2012-01-01, 2@2012-01-03), 
	[3@2012-01-03, 5@2012-01-05)}');
-- "[1@2012-01-01, 2@2012-01-03)"
					</programlisting>
				</listitem>

				<listitem id="endSequence">
					<para>Get the end sequence</para>
					<para><varname>endSequence({ttypeseq,ttypes}): ttypeseq</varname></para>
					<programlisting>
SELECT endSequence(tfloat '{[1@2012-01-01, 2@2012-01-03), [3@2012-01-03, 5@2012-01-05)}');
-- "[3@2012-01-03, 5@2012-01-05)"
					</programlisting>
				</listitem>

				<listitem id="sequenceN">
					<para>Get the n-th sequence</para>
					<para><varname>sequenceN({ttypeseq,ttypes}, int): ttypeseq</varname></para>
					<programlisting>
SELECT sequenceN(tfloat '{[1@2012-01-01, 2@2012-01-03), 
	[3@2012-01-03, 5@2012-01-05)}', 2);
-- "[3@2012-01-03, 5@2012-01-05)"
					</programlisting>
				</listitem>

				<listitem id="sequences">
					<para>Get the sequences</para>
					<para><varname>sequences({ttypeseq,ttypes}): ttypeseq[]</varname></para>
					<programlisting>
SELECT sequences(tfloat '{[1@2012-01-01, 2@2012-01-03), [3@2012-01-03, 5@2012-01-05)}');
-- "{"[1@2012-01-01, 2@2012-01-03)", "[3@2012-01-03, 5@2012-01-05)"}"
					</programlisting>
				</listitem>

				<listitem id="ttype_shift">
					<para>Shift the temporal value by an interval</para>
					<para><varname>shift(ttype): ttype</varname></para>
					<programlisting>
SELECT shift(tint '{1@2001-01-01, 2@2001-01-03, 1@2001-01-05}', '1 day'::interval);
-- "{1@2001-01-02, 2@2001-01-04, 1@2001-01-06}"
SELECT shift(tfloat '[1@2001-01-01, 2@2001-01-03]', '1 day'::interval);
-- "[1@2001-01-02, 2@2001-01-04]"
SELECT asText(shift(tgeompoint '{[Point(1 1)@2001-01-01, Point(2 2)@2001-01-03], 
	[Point(2 2)@2001-01-04, Point(1 1)@2001-01-05]}', '1 day'::interval));
-- "{[POINT(1 1)@2001-01-02, POINT(2 2)@2001-01-04], [
	POINT(2 2)@2001-01-05, POINT(1 1)@2001-01-06]}"
					</programlisting>
				</listitem>

				<listitem id="intersectsTimestamp">
					<para>Does the temporal value intersect the timestamp?</para>
					<para><varname>intersectsTimestamp(ttype, timestamptz): boolean</varname></para>
					<programlisting>
SELECT intersectsTimestamp(tint '[1@2012-01-01, 1@2012-01-15)', timestamptz '2012-01-03');
-- true
					</programlisting>
				</listitem>

				<listitem id="intersectsTimestampSet">
					<para>Does the temporal value intersect the timestamp set?</para>
					<para><varname>intersectsTimestampSet(ttype, timestampset): boolean</varname></para>
					<programlisting>
SELECT intersectsTimestampSet(tint '[1@2012-01-01, 1@2012-01-15)',
	timestampset '{2012-01-01, 2012-01-03}');
-- true
					</programlisting>
				</listitem>

				<listitem id="intersectsPeriod">
					<para>Does the temporal value intersect the period?</para>
					<para><varname>intersectsPeriod(ttype, period): boolean</varname></para>
					<programlisting>
SELECT intersectsPeriod(tint '[1@2012-01-01, 1@2012-01-04)',
	period '[2012-01-01,2012-01-05)');
-- true
					</programlisting>
				</listitem>

				<listitem id="intersectsPeriodSet">
					<para>Does the temporal value intersect the period set?</para>
					<para><varname>intersectsPeriodSet(ttype, periodset): boolean</varname></para>
					<programlisting>
SELECT intersectsPeriodSet(tbool '[t@2012-01-01, f@2012-01-15]',
	periodset '{[2012-01-01, 2012-01-03), [2012-01-05, 2012-01-07)}');
-- true
					</programlisting>
				</listitem>

				<listitem id="twAvg">
					<para>Get the time-weighted average</para>
					<para><varname>twAvg(tnumber): float</varname></para>
					<programlisting>
SELECT twAvg(tfloat '{[1@2012-01-01, 2@2012-01-03), [2@2012-01-04, 2@2012-01-06)}');
-- 1.75
					</programlisting>
				</listitem>
			</itemizedlist>
		</sect1>

		<sect1>
			<title>Spatial Functions</title>
			<para>In the following, we specify with the symbol &Z_support; that the function supports 3D points and with the symbol &geography_support; that the function is available for geographies.</para>

			<itemizedlist>
				<listitem id="asText">
					<para>Get the Well-Known Text (WKT) representation &Z_support; &geography_support;</para>
					<para><varname>asText({tpoint, tpoint[], geo[]}): {text, text[]}</varname></para>
					<programlisting>
SELECT asText(tgeompoint 'SRID=4326;[Point(0 0 0)@2012-01-01, Point(1 1 1)@2012-01-02)');
-- "[POINT Z (0 0 0)@2012-01-01 00:00:00+00, POINT Z (1 1 1)@2012-01-02 00:00:00+00)"
SELECT asText(ARRAY[geometry 'Point(0 0)', 'Point(1 1)']);
-- "{"POINT(0 0)","POINT(1 1)"}"
					</programlisting>
				</listitem>

				<listitem id="asEWKT">
					<para>Get the Extended Well-Known Text (EWKT) representation &Z_support; &geography_support;</para>
					<para><varname>asEWKT({tpoint, tpoint[], geo[]}): {text, text[]}</varname></para>
					<programlisting>
SELECT asEWKT(tgeompoint 'SRID=4326;[Point(0 0 0)@2012-01-01, Point(1 1 1)@2012-01-02)');
-- "SRID=4326;[POINT Z (0 0 0)@2012-01-01 00:00:00+00, 
	POINT Z (1 1 1)@2012-01-02 00:00:00+00)"
SELECT asEWKT(ARRAY[geometry 'SRID=5676;Point(0 0)', 'SRID=5676;Point(1 1)']);
-- "{"SRID=5676;POINT(0 0)","SRID=5676;POINT(1 1)"}"
					</programlisting>
				</listitem>

				<listitem id="asMFJSON">
					<para>Get the Moving Features JSON representation &Z_support; &geography_support;</para>
					<para><varname>asMFJSON(tpoint, maxdecdigits int4 DEFAULT 15, options int4 DEFAULT 0): bytea</varname></para>
					<para>The last <varname>options</varname> argument could be used to add BBOX and/or CRS in MFJSON output:</para>
					<itemizedlist>
						<listitem><para>0: means no option (default value)</para></listitem>
						<listitem><para>1: MFJSON BBOX</para></listitem>
						<listitem><para>2: MFJSON Short CRS (e.g EPSG:4326)</para></listitem>
						<listitem><para>4: MFJSON Long CRS (e.g urn:ogc:def:crs:EPSG::4326)</para></listitem>
					</itemizedlist>
					<programlisting>
SELECT asMFJSON(tgeompoint 'Point(1 2)@2019-01-01 18:00:00.15+02');
-- "{"type":"MovingPoint","coordinates":[1,2],"datetimes":"2019-01-01T17:00:00.15+01",
	"interpolations":["Discrete"]}"
SELECT asMFJSON(tgeompoint 'SRID=4326;
	Point(50.813810 4.384260)@2019-01-01 18:00:00.15+02', 2, 3);
-- "{"type":"MovingPoint","crs":{"type":"name","properties":{"name":"EPSG:4326"}},
	"stBoundedBy":{"bbox":[50.81,4.38,50.81,4.38],
	"period":{"begin":"2019-01-01 17:00:00.15+01","end":"2019-01-01 17:00:00.15+01"}},
	"coordinates":[50.81,4.38],"datetimes":"2019-01-01T17:00:00.15+01",
	"interpolations":["Discrete"]}"
					</programlisting>
				</listitem>

				<listitem id="asBinary">
					<para>Get the Well-Known Binary (WKB) representation &Z_support; &geography_support;</para>
					<para><varname>asBinary(tpoint, text default 'NDR'): bytea</varname></para>
					<para>The result is encoded using either the little-endian (NDR) or the big-endian (XDR) encoding. If no encoding is specified, then NDR is used.</para>
					<programlisting>
SELECT asBinary(tgeompoint 'SRID=4326;Point(1 2 3)@2012-01-01');
-- "\001\001\000\000\000\000\000\000\360?\000\000\000\000\000\000\000@\000\000\000\000\000\000\010@\000\374\340\023jX\001\000"
					</programlisting>
				</listitem>

				<listitem id="asEWKB">
					<para>Get the Extended Well-Known Binary (EWKB) representation &Z_support; &geography_support;</para>
					<para><varname>asEWKB(tpoint, text default 'NDR'): bytea</varname></para>
					<para>The result is encoded using either the little-endian (NDR) or the big-endian (XDR) encoding. If no encoding is specified, then NDR is used.</para>
					<programlisting>
SELECT asEWKB(tgeompoint 'SRID=4326;Point(1 2 3)@2012-01-01');
-- "\0011\346\020\000\000\000\000\000\000\000\000\360?\000\000\000\000\000\000\000@\000\000\000\000\000\000\010@\000\374\340\023jX\001\000"
					</programlisting>
				</listitem>

				<listitem id="asHexEWKB">
					<para>Get the Hexadecimal Extended Well-Known Binary (EWKB) representation as text &Z_support; &geography_support;</para>
					<para><varname>asHexEWKB(tpoint, text default 'NDR'): text</varname></para>
					<para>The result is encoded using either the little-endian (NDR) or the big-endian (XDR) encoding. If no encoding is specified, then NDR is used.</para>
					<programlisting>
SELECT asHexEWKB(tgeompoint 'SRID=4326;Point(1 2 3)@2012-01-01');
-- "0131E6100000000000000000F03F0000000000000040000000000000084000FCE0136A580100"					
					</programlisting>
				</listitem>

				<listitem id="fromMFJSON">
					<para>Input a temporal point from a Moving Features JSON representation &Z_support; &geography_support;</para>
					<para><varname>fromMFJSON(text): tpoint</varname></para>
					<programlisting>
SELECT asEWKT(fromMFJSON(text '{"type":"MovingPoint","crs":{"type":"name",
"properties":{"name":"EPSG:4326"}},"coordinates":[50.81,4.38],
"datetimes":"2019-01-01T17:00:00.15+01","interpolations":["Discrete"]}'));
-- "SRID=4326;POINT(50.81 4.38)@2019-01-01 17:00:00.15+01"
					</programlisting>
				</listitem>

				<listitem id="fromEWKB">
					<para>Input a temporal point from an Extended Well-Known Binary (EWKB) representation &Z_support; &geography_support;</para>
					<para><varname>fromEWKB(bytea): tpoint</varname></para>
					<programlisting>
SELECT asEWKT(fromEWKB(bytea 
'\0011\346\020\000\000\000\000\000\000\000\000\360?\000\000\000\000\000\000\000@\000\000\000\000\000\000\010@\000\374\340\023jX\001\000'));
-- "SRID=4326;POINT Z (1 2 3)@2012-01-01 00:00:00+01"
					</programlisting>
				</listitem>

				<listitem id="tpoint_SRID">
					<para>Get the spatial reference identifier &Z_support; &geography_support;</para>
					<para><varname>SRID(tpoint): integer</varname></para>
					<programlisting>
SELECT SRID(tgeompoint 'Point(0 0)@2012-01-01');
-- 0
					</programlisting>
				</listitem>

				<listitem id="tpoint_setSRID">
					<para>Set the spatial reference identifier &Z_support; &geography_support;</para>
					<para><varname>setSRID(tpoint): tpoint</varname></para>
					<programlisting>
SELECT asEWKT(setSRID(tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-02)', 4326));
-- "SRID=4326;[POINT(0 0)@2012-01-01 00:00:00+00, POINT(1 1)@2012-01-02 00:00:00+00)"
					</programlisting>
					</listitem>

				<listitem id="tpoint_transform">
					<para>Transform to a different spatial reference &Z_support; &geography_support;</para>
					<para><varname>transform(tpoint, integer): tpoint</varname></para>
					<programlisting>
SELECT asEWKT(transform(tgeompoint 'SRID=4326;Point(4.35 50.85)@2012-01-01', 3812));
-- "SRID=3812;POINT(648679.018035303 671067.055638114)@2012-01-01 00:00:00+00"
					</programlisting>
				</listitem>

				<listitem id="tpoint_setPrecision">
					<para>Round the coordinate values to a number of decimal places &Z_support; &geography_support;</para>
					<para><varname>setPrecision(tpoint, int): tpoint</varname></para>
					<programlisting>
SELECT asText(setPrecision(tgeompoint '{Point(1.12345 1.12345 1.12345)@2000-01-01, 
	Point(2 2 2)@2000-01-02, Point(1.12345 1.12345 1.12345)@2000-01-03}', 2));
-- "{POINT Z (1.12 1.12 1.12)@2000-01-01, POINT Z (2 2 2)@2000-01-02, 
	POINT Z (1.12 1.12 1.12)@2000-01-03}"
SELECT asText(setPrecision(tgeogpoint 'Point(1.12345 1.12345)@2000-01-01', 2));
-- "POINT(1.12 1.12)@2000-01-01"
					</programlisting>
				</listitem>

				<listitem id="length">
					<para>Get the length traversed by the temporal point &Z_support; &geography_support;</para>
					<para><varname>length(tpoint): float</varname></para>
					<programlisting>
SELECT length(tgeompoint '[Point(0 0 0)@2000-01-01, Point(1 1 1)@2000-01-02]');
-- 1.73205080756888
SELECT length(tgeompoint '[Point(0 0 0)@2000-01-01, Point(1 1 1)@2000-01-02,
	Point(0 0 0)@2000-01-03]');
-- 3.46410161513775
SELECT length(tgeompoint 'Interp=Stepwise;[Point(0 0 0)@2000-01-01, Point(1 1 1)@2000-01-02,
	Point(0 0 0)@2000-01-03]');
-- 0
					</programlisting>
				</listitem>

				<listitem id="cumulativeLength">
					<para>Get the cumulative length traversed by the temporal point &Z_support; &geography_support;</para>
					<para><varname>cumulativeLength(tpoint): tfloatseq</varname></para>
					<programlisting>
SELECT cumulativeLength(tgeompoint
	'{[Point(0 0)@2000-01-01, Point(1 1)@2000-01-02, Point(1 0)@2000-01-03],
	[Point(1 0)@2000-01-04, Point(0 0)@2000-01-05]}');
-- "{[0@2000-01-01, 1.4142135623731@2000-01-02, 2.41421356237309@2000-01-03],
	[2.41421356237309@2000-01-04, 3.41421356237309@2000-01-05]}"
SELECT cumulativeLength(tgeompoint 'Interp=Stepwise;[Point(0 0 0)@2000-01-01, Point(1 1 1)@2000-01-02,
	Point(0 0 0)@2000-01-03]');
-- "Interp=Stepwise;[0@2000-01-01, 0@2000-01-02, 0@2000-01-03]"
					</programlisting>
				</listitem>

				<listitem id="speed">
					<para>Get the speed of the temporal point in units per second &Z_support; &geography_support;</para>
					<para><varname>speed(tpoint): tfloats</varname></para>
					<programlisting>
SELECT speed(tgeompoint '{[Point(0 0)@2000-01-01, Point(1 1)@2000-01-02, Point(1 0)@2000-01-03],
	[Point(1 0)@2000-01-04, Point(0 0)@2000-01-05]}') * 3600 * 24;
-- "Interp=Stepwise;{[1.4142135623731@2000-01-01, 1@2000-01-02, 1@2000-01-03], [1@2000-01-04, 1@2000-01-05]}"
SELECT speed(tgeompoint 'Interp=Stepwise;[Point(0 0)@2000-01-01, Point(1 1)@2000-01-02, Point(1 0)@2000-01-03]') * 3600 * 24;
-- "Interp=Stepwise;[0@2000-01-01 00:00:00+01, 0@2000-01-03 00:00:00+01]"
					</programlisting>
				</listitem>

				<listitem id="twCentroid">
					<para>Get the time-weighted centroid &Z_support;</para>
					<para><varname>twCentroid(tgeompoint): point</varname></para>
					<programlisting>
SELECT ST_AsText(twCentroid(tgeompoint '{[Point(0 0 0)@2012-01-01, 
	Point(0 1 1)@2012-01-02, Point(0 1 1)@2012-01-03, Point(0 0 0)@2012-01-04)}'));
-- "POINT Z (0 0.666666666666667 0.666666666666667)"
					</programlisting>
				</listitem>

				<listitem id="azimuth">
					<para>Get the temporal azimuth &Z_support; &geography_support;</para>
					<para><varname>azimuth(tpoint): tfloat</varname></para>
					<programlisting>
SELECT degrees(azimuth(tgeompoint '[Point(0 0 0)@2012-01-01, Point(1 1 1)@2012-01-02,
	Point(1 1 1)@2012-01-03, Point(0 0 0)@2012-01-04)'));
-- "Interp=Stepwise;{[45@2012-01-01, 45@2012-01-02], [225@2012-01-03, 225@2012-01-04)}"
					</programlisting>
				</listitem>

				<listitem id="nearestApproachInstant">
					<para>Get the instant of the first temporal point at which the two arguments are at the nearest distance &Z_support; &geography_support;</para>
					<para><varname>nearestApproachInstant({geo, tpoint}, {geo, tpoint}): tpoint</varname></para>
					<para>The function will only return the first instant that it finds if there are more than one. The resulting instant may be at an exclusive bound.</para>
					<programlisting>
SELECT asText(NearestApproachInstant(tgeompoint '(Point(1 1)@2000-01-01, 
	Point(3 1)@2000-01-03]', geometry 'Linestring(1 3,2 2,3 3)'));
-- "POINT(2 1)@2000-01-02"
SELECT asText(NearestApproachInstant(tgeompoint 'Interp=Stepwise;(Point(1 1)@2000-01-01,
	Point(3 1)@2000-01-03]', geometry 'Linestring(1 3,2 2,3 3)'));
-- "POINT(1 1)@2000-01-01"
SELECT asText(NearestApproachInstant(tgeompoint '(Point(1 1)@2000-01-01,
	Point(2 2)@2000-01-03]', tgeompoint '(Point(1 1)@2000-01-01, Point(4 1)@2000-01-03]'));
-- "POINT(1 1)@2000-01-01"
SELECT asText(nearestApproachInstant(
	tgeompoint '[Point(0 0 0)@2012-01-01, Point(1 1 1)@2012-01-03,
	Point(0 0 0)@2012-01-05)', tgeompoint '[Point(2 0 0)@2012-01-02,
	Point(1 1 1)@2012-01-04, Point(2 2 2)@2012-01-06)'));
-- "POINT Z (0.75 0.75 0.75)@2012-01-03 12:00:00+00"
					</programlisting>
					<para>Function <varname>nearestApproachInstant</varname> generalizes the PostGIS function <varname>ST_ClosestPointOfApproach</varname>. First, the latter function requires both arguments to be trajectories. Second, function <varname>nearestApproachInstant</varname> returns both the point and the timestamp of the nearest point of approach while the PostGIS function only provides the timestamp as shown next.</para>
					<programlisting>
SELECT to_timestamp(ST_ClosestPointOfApproach(
	tgeompoint '[Point(0 0 0)@2012-01-01, Point(1 1 1)@2012-01-03, 
		Point(0 0 0)@2012-01-05)'::geometry,
	tgeompoint '[Point(2 0 0)@2012-01-02, Point(1 1 1)@2012-01-04, 
		Point(2 2 2)@2012-01-06)'::geometry));
-- "2012-01-03 12:00:00+00"
					</programlisting>
				</listitem>

				<listitem id="nearestApproachDistance">
					<para>Get the smallest distance ever &Z_support; &geography_support;</para>
					<para><varname>nearestApproachDistance({geo, tpoint}, {geo, tpoint}): float</varname></para>
					<programlisting>

SELECT NearestApproachDistance(tgeompoint '(Point(1 1)@2000-01-01, 
	Point(3 1)@2000-01-03]', geometry 'Linestring(1 3,2 2,3 3)');
-- 1
SELECT NearestApproachDistance(tgeompoint 'Interp=Stepwise;(Point(1 1)@2000-01-01,
	Point(3 1)@2000-01-03]', geometry 'Linestring(1 3,2 2,3 3)');
-- 1.4142135623731
SELECT nearestApproachDistance(
	tgeompoint '[Point(0 0 0)@2012-01-01, Point(1 1 1)@2012-01-03, 
		Point(0 0 0)@2012-01-05)',
	tgeompoint '[Point(2 0 0)@2012-01-02, Point(1 1 1)@2012-01-04, 
		Point(2 2 2)@2012-01-06)');
-- "0.5"
					</programlisting>
					<para>Function <varname>nearestApproachDistance</varname> has an associated operator <varname>|=|</varname> that can be used for doing nearest neightbor searches using a GiST index (see <xref linkend="operators_temporal_types" />). This function corresponds to the function <varname>ST_DistanceCPA</varname> provided by PostGIS, altough the latter requires both arguments to be a trajectory.</para>
					<programlisting>
SELECT ST_DistanceCPA(
	tgeompoint '[Point(0 0 0)@2012-01-01, Point(1 1 1)@2012-01-03, 
		Point(0 0 0)@2012-01-05)'::geometry,
	tgeompoint '[Point(2 0 0)@2012-01-02, Point(1 1 1)@2012-01-04, 
		Point(2 2 2)@2012-01-06)'::geometry);
-- "0.5"
					</programlisting>
				</listitem>

				<listitem id="shortestLine">
					<para>Get the line connecting the nearest approach point &Z_support; &geography_support;</para>
					<para><varname>shortestLine({geo, tpoint}, {geo, tpoint}): geo</varname></para>
					<para>The function will only return the first line that it finds if there are more than one.</para>
					<programlisting>
SELECT ST_AsText(shortestLine(tgeompoint '(Point(1 1)@2000-01-01, 
	Point(3 1)@2000-01-03]', geometry 'Linestring(1 3,2 2,3 3)'));
-- "LINESTRING(2 1,2 2)"
SELECT ST_AsText(shortestLine(tgeompoint 'Interp=Stepwise;(Point(1 1)@2000-01-01,
	Point(3 1)@2000-01-03]', geometry 'Linestring(1 3,2 2,3 3)'));
-- "LINESTRING(1 1,2 2)"
SELECT ST_AsText(shortestLine(
	tgeompoint '[Point(0 0 0)@2012-01-01, Point(1 1 1)@2012-01-03, 
		Point(0 0 0)@2012-01-05)',
	tgeompoint '[Point(2 0 0)@2012-01-02, Point(1 1 1)@2012-01-04, 
		Point(2 2 2)@2012-01-06)'));
-- "LINESTRING Z (0.75 0.75 0.75,1.25 0.75 0.75)"
					</programlisting>
					<para>Function <varname>shortestLine</varname> can be used to obtain the result provided by the PostGIS function <varname>ST_CPAWithin</varname> when both arguments are trajectories as shown next.</para>
					<programlisting>
SELECT ST_Length(shortestLine(
	tgeompoint '[Point(0 0 0)@2012-01-01, Point(1 1 1)@2012-01-03, 
		Point(0 0 0)@2012-01-05)',
	tgeompoint '[Point(2 0 0)@2012-01-02, Point(1 1 1)@2012-01-04, 
		Point(2 2 2)@2012-01-06)')) &lt;= 0.5;
-- true
SELECT ST_CPAWithin(
	tgeompoint '[Point(0 0 0)@2012-01-01, Point(1 1 1)@2012-01-03, 
		Point(0 0 0)@2012-01-05)'::geometry,
	tgeompoint '[Point(2 0 0)@2012-01-02, Point(1 1 1)@2012-01-04, 
		Point(2 2 2)@2012-01-06)'::geometry, 0.5);
-- true
					</programlisting>
				</listitem>

				<listitem id="simplify">
					<para>Simplify a temporal point using a generalization of the Douglas-Peucker algorithm &Z_support;</para>
					<para><varname>simplify(tpoint, float): tpoint</varname></para>
					<para><varname>simplify(tpoint, float, float): tpoint</varname></para>
					<para>The first version remove points that are less than the distance passed as second argument, which is specified in the units of the coordinate system. The second version remove points that are less than the distance passed as second argument provided that the speed difference between the point and the corresponding point in the simplified version is less than the speed passed as third argument, which is specified in units per second. Notice that simplification applies only to temporal sequences or sequence sets with linear interpolation. In all other cases, a copy of the given temporal point is returned.</para>

					<programlisting>
-- Only distance specified
SELECT ST_AsText(trajectory(simplify(tgeompoint '[Point(0 4)@2000-01-01,
	Point(1 1)@2000-01-02, Point(2 3)@2000-01-03, Point(3 1)@2000-01-04,
	Point(4 3)@2000-01-05, Point(5 0)@2000-01-06, Point(6 4)@2000-01-07]', 1.5)));
-- "LINESTRING(0 4,1 1,4 3,5 0,6 4)"
SELECT ST_AsText(trajectory(simplify(tgeompoint '[Point(0 4)@2000-01-01,
	Point(1 1)@2000-01-02, Point(2 3)@2000-01-03, Point(3 1)@2000-01-04,
	Point(4 3)@2000-01-05, Point(5 0)@2000-01-06, Point(6 4)@2000-01-07]', 2)));
-- "LINESTRING(0 4,5 0,6 4)"
SELECT ST_AsText(trajectory(simplify(tgeompoint '[Point(0 4)@2000-01-01,
	Point(1 1)@2000-01-02, Point(2 3)@2000-01-03, Point(3 1)@2000-01-04,
	Point(4 3)@2000-01-05, Point(5 0)@2000-01-06, Point(6 4)@2000-01-07]', 4)));
-- "LINESTRING(0 4,6 4)"

-- Speed of the temporal point
SELECT round(speed(tgeompoint '[Point(0 4)@2000-01-01, Point(1 1)@2000-01-02,
Point(2 3)@2000-01-03, Point(3 1)@2000-01-04, Point(4 3)@2000-01-05,
Point(5 0)@2000-01-06, Point(6 4)@2000-01-07]') * 1e5, 2);
-- "Interp=Stepwise;[3.66@2000-01-01, 2.59@2000-01-02, 3.66@2000-01-05,
	4.77@2000-01-06, 4.77@2000-01-07]"

-- Both distance and delta speed specified
SELECT ST_AsText(trajectory(simplify(tgeompoint '[Point(0 4)@2000-01-01,
	Point(1 1)@2000-01-02, Point(2 3)@2000-01-03, Point(3 1)@2000-01-04,
	Point(4 3)@2000-01-05, Point(5 0)@2000-01-06, Point(6 4)@2000-01-07]', 4, 1 / 1e5)));
-- "LINESTRING(0 4,1 1,2 3,3 1,4 3,5 0,6 4)"
SELECT ST_AsText(trajectory(simplify(tgeompoint '[Point(0 4)@2000-01-01,
	Point(1 1)@2000-01-02, Point(2 3)@2000-01-03, Point(3 1)@2000-01-04,
	Point(4 3)@2000-01-05, Point(5 0)@2000-01-06, Point(6 4)@2000-01-07]', 4, 2 / 1e5)));
-- "LINESTRING(0 4,1 1,5 0,6 4)"
SELECT ST_AsText(trajectory(simplify(tgeompoint '[Point(0 4)@2000-01-01,
	Point(1 1)@2000-01-02, Point(2 3)@2000-01-03, Point(3 1)@2000-01-04,
	Point(4 3)@2000-01-05, Point(5 0)@2000-01-06, Point(6 4)@2000-01-07]', 4, 3 / 1e5)));
-- "LINESTRING(0 4,6 4)"
					</programlisting>
					<para>A typical use for the <varname>simplify</varname> function is to reduce the size of a dataset, in particular for visualization purposes.</para>
				</listitem>

				<listitem id="geoMeasure">
					<para>Construct a geometry/geography with M measure from a temporal point and a temporal float &Z_support; &geography_support;</para>
					<para><varname>geoMeasure(tpoint, tfloat, segmentize = false): geo</varname></para>
					<para>The last <varname>segmentize</varname> argument states whether a resulting Linestring M value is transformed into a MultiLinestring M, where each component is a segment of two points.</para>

					<programlisting>
SELECT st_astext(geoMeasure(tgeompoint '{Point(1 1 1)@2000-01-01,
	Point(2 2 2)@2000-01-02}', '{5@2000-01-01, 5@2000-01-02}'));
-- "MULTIPOINT ZM (1 1 1 5,2 2 2 5)"
SELECT st_astext(geoMeasure(tgeogpoint '{[Point(1 1)@2000-01-01, Point(2 2)@2000-01-02],
	[Point(1 1)@2000-01-03, Point(1 1)@2000-01-04]}',
	'{[5@2000-01-01, 5@2000-01-02],[7@2000-01-03, 7@2000-01-04]}'));
-- "GEOMETRYCOLLECTION M (LINESTRING M (1 1 5,2 2 5),POINT M (1 1 7))"
SELECT st_astext(geoMeasure(tgeompoint '[Point(1 1)@2000-01-01,
	Point(2 2)@2000-01-02, Point(1 1)@2000-01-03]', '[5@2000-01-01, 7@2000-01-02, 5@2000-01-03]', true));
-- "MULTILINESTRING M ((1 1 5,2 2 5),(2 2 7,1 1 7))"
					</programlisting>
					<para>A typical visualization for mobility data is to show on a map the trajectory of the moving object using different colors according to the speed. <xref linkend="figspeed" /> shows the result of the query below using a color ramp in QGIS.</para>
					<programlisting>
WITH Temp(t) AS (
	SELECT tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-05,
			Point(2 0)@2012-01-08, Point(3 1)@2012-01-10, Point(4 0)@2012-01-11]'
)
SELECT ST_AsText(geoMeasure(t,  round(speed(t) * 3600 * 24, 2), true))
FROM Temp;
-- "MULTILINESTRING M ((0 0 0.35,1 1 0.35),(1 1 0.47,2 0 0.47),(2 0 0.71,3 1 0.71),
	(3 1 1.41,4 0 1.41))"
					</programlisting>
					<para>The following expression is used in QGIS to achieve this. The <varname>scale_linear</varname> function transforms the M value of each composing segment to the range [0, 1]. This value is then passed to the <varname>ramp_color</varname> function.</para>
					<programlisting>
ramp_color(
	'RdYlBu',
	scale_linear(
		m(start_point(geometry_n($geometry,@geometry_part_num))),
		0, 2, 0, 1
	)
)
				</programlisting>
					<figure id="figspeed" float="start"><title>Visualizing the speed of a moving object using a color ramp in QGIS.</title>
						<mediaobject>
							<imageobject><imagedata scale='30' fileref='images/speed.png' /></imageobject>
						</mediaobject>
					</figure>
				</listitem>

			</itemizedlist>
		</sect1>

		<sect1>
			<title>Restriction Functions</title>
			<para>These functions restrict the temporal value with respect to a value extent or a time extent.</para>

			<itemizedlist>
				<listitem id="atValue">
					<para>Restrict to a value</para>
					<para><varname>atValue(ttype, base): ttype</varname></para>
					<programlisting>
SELECT atValue(tint '[1@2012-01-01, 1@2012-01-15)', 1);
-- "[1@2012-01-01, 1@2012-01-15)"
SELECT asText(atValue(tgeompoint '[Point(0 0 0)@2012-01-01, Point(2 2 2)@2012-01-03)',
	'Point(1 1 1)'));
-- "{[POINT Z (1 1 1)@2012-01-02]}"
					</programlisting>
				</listitem>

				<listitem id="atValues">
					<para>Restrict to an array of values</para>
					<para><varname>atValues(ttype, base[]): ttype</varname></para>
					<programlisting>
SELECT atValues(tfloat '[1@2012-01-01, 4@2012-01-4)', ARRAY[1, 3, 5]);
-- "{[1@2012-01-01], [3@2012-01-03]}"
SELECT asText(atValues(tgeompoint '[Point(0 0)@2012-01-01, Point(2 2)@2012-01-03)',
	ARRAY[geometry 'Point(0 0)', 'Point(1 1)']));
-- "{[POINT(0 0)@2012-01-01 00:00:00+00], [POINT(1 1)@2012-01-02 00:00:00+00]}"
					</programlisting>
				</listitem>

				<listitem id="atRange">
					<para>Restrict to a range</para>
					<para><varname>atRange(tnumber, numrange): ttype</varname></para>
					<programlisting>
SELECT atRange(tfloat '[1@2012-01-01, 4@2012-01-4)', floatrange '[1,3]');
-- "[1@2012-01-01, 3@2012-01-03]"
					</programlisting>
				</listitem>

				<listitem id="atRanges">
					<para>Restrict to an array of ranges</para>
					<para><varname>atRanges(tnumber, numrange[]): ttype</varname></para>
					<programlisting>
SELECT atRanges(tfloat '[1@2012-01-01, 5@2012-01-05)', 
	ARRAY[floatrange '[1,2]', '[3,4]']);
-- "{[1@2012-01-01, 2@2012-01-02],[3@2012-01-03, 4@2012-01-04]}"
					</programlisting>
				</listitem>

				<listitem id="atMin">
					<para>Restrict to the minimum value</para>
					<para><varname>atMin(torder): torder</varname></para>
					<para>The function returns null if the minimum value only happens at exclusive bounds.</para>
					<programlisting>
SELECT atMin(tint '{1@2012-01-01, 2@2012-01-03, 1@2012-01-05}');
-- "{1@2012-01-01, 1@2012-01-05}"
SELECT atMin(tint '(1@2012-01-01, 3@2012-01-03]');
-- "{(1@2012-01-01, 1@2012-01-03)}"
SELECT atMin(tfloat '(1@2012-01-01, 3@2012-01-03]');
-- NULL
SELECT atMin(ttext '{(AA@2012-01-01, AA@2012-01-03), (BB@2012-01-03, AA@2012-01-05]}');
-- "{(AA@2012-01-01, AA@2012-01-03), [AA@2012-01-05]}"
					</programlisting>
				</listitem>

				<listitem id="atMax">
					<para>Restrict to the maximum value</para>
					<para><varname>atMax(torder): torder</varname></para>
					<para>The function returns null if the maximum value only happens at exclusive bounds.</para>
					<programlisting>
SELECT atMax(tint '{1@2012-01-01, 2@2012-01-03, 3@2012-01-05}');
-- "{3@2012-01-05}"
SELECT atMax(tfloat '(1@2012-01-01, 3@2012-01-03)');
-- NULL
SELECT atMax(tfloat '{(2@2012-01-01, 1@2012-01-03), [2@2012-01-03, 2@2012-01-05)}');
-- "{[2@2012-01-03, 2@2012-01-05]}"
SELECT atMax(ttext '{(AA@2012-01-01, AA@2012-01-03), (BB@2012-01-03, AA@2012-01-05]}');
-- "{("BB"@2012-01-03, "BB"@2012-01-05)}"
					</programlisting>
				</listitem>

				<listitem id="atGeometry">
					<para>Restrict to a geometry</para>
					<para><varname>atGeometry(tgeompoint, geometry): tgeompoint</varname></para>
					<programlisting>
SELECT asText(atGeometry(tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-04)',
	geometry 'Polygon((1 1,1 2,2 2,2 1,1 1))'));
-- "{"[POINT(1 1)@2012-01-02, POINT(2 2)@2012-01-03]"}"
					</programlisting>
				</listitem>

				<listitem id="atTimestamp">
					<para>Restrict to a timestamp</para>
					<para><varname>atTimestamp(ttype, timestamptz): ttypeinst</varname></para>
					<programlisting>
SELECT atTimestamp(tfloat '[1@2012-01-01, 5@2012-01-05)', '2012-01-02');
-- "2@2012-01-02"
					</programlisting>
				</listitem>

				<listitem id="atTimestampSet">
					<para>Restrict to a timestamp set</para>
					<para><varname>atTimestampSet(ttype, timestampset): {ttypeinst, ttypei}</varname></para>
					<programlisting>
SELECT atTimestampSet(tint '[1@2012-01-01, 1@2012-01-15)',
	timestampset '{2012-01-01, 2012-01-03}');
-- "{1@2012-01-01, 1@2012-01-03}"
					</programlisting>
				</listitem>

				<listitem id="atPeriod">
					<para>Restrict to a period</para>
					<para><varname>atPeriod(ttype, period): ttype</varname></para>
					<programlisting>
SELECT atPeriod(tfloat '{[1@2012-01-01, 3@2012-01-03), [3@2012-01-04, 1@2012-01-06)}',
	'[2012-01-02,2012-01-05)');
-- "{[2@2012-01-02, 3@2012-01-03), [3@2012-01-04, 2@2012-01-05)}"
					</programlisting>
				</listitem>

				<listitem id="atPeriodSet">
					<para>Restrict to a period set</para>
					<para><varname>atPeriodSet(ttype, periodset): ttype</varname></para>
					<programlisting>
SELECT atPeriodSet(tint '[1@2012-01-01, 1@2012-01-15)',
	periodset '{[2012-01-01, 2012-01-03), [2012-01-04, 2012-01-05)}');
-- "{[1@2012-01-01, 1@2012-01-03),[1@2012-01-04, 1@2012-01-05)}"
					</programlisting>
				</listitem>

				<listitem id="atTbox">
					<para>Restrict to a <varname>tbox</varname></para>
					<para><varname>atTbox(tnumber, tbox): tnumber</varname></para>
					<programlisting>
SELECT atTbox(tfloat '[0@2012-01-01, 3@2012-01-04)',
	tbox 'TBOX((0, 2012-01-02), (2, 2012-01-04))');
-- "{[1@2012-01-02, 2@2012-01-03]}"
					</programlisting>
				</listitem>

				<listitem id="atStbox">
					<para>Restrict to an <varname>stbox</varname></para>
					<para><varname>atStbox(tgeompoint, stbox): tgeompoint</varname></para>
					<programlisting>
SELECT asText(atStbox(tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-04)',
	stbox 'STBOX T((0, 0, 2012-01-02), (2, 2, 2012-01-04))'));
-- "{[POINT(1 1)@2012-01-02, POINT(2 2)@2012-01-03]}"
					</programlisting>
				</listitem>
			</itemizedlist>
		</sect1>

		<sect1>
			<title>Difference Functions</title>
			<para>These functions restrict the temporal value with respect to the complement of a value/range or a time extent.</para>
			<itemizedlist>
				<listitem id="minusValue">
				<para>Difference with a value</para>
				<para><varname>minusValue(ttype, base): ttype</varname></para>
				<programlisting>
SELECT minusValue(tint '[1@2012-01-01, 2@2012-01-02, 2@2012-01-03)', 1);
-- "{[2@2012-01-02, 2@2012-01-03)}"
SELECT asText(minusValue(tgeompoint '[Point(0 0 0)@2012-01-01, Point(2 2 2)@2012-01-03)',
	'Point(1 1 1)'));
-- "{[POINT Z (0 0 0)@2012-01-01, POINT Z (1 1 1)@2012-01-02),
(POINT Z (1 1 1)@2012-01-02, POINT Z (2 2 2)@2012-01-03)}"
					</programlisting>
				</listitem>

				<listitem id="minusValues">
					<para>Difference with an array of values</para>
					<para><varname>minusValues(ttype, base[]): ttype</varname></para>
					<programlisting>
SELECT minusValues(tfloat '[1@2012-01-01, 4@2012-01-4)', ARRAY[2, 3]);
-- "{[1@2012-01-01, 2@2012-01-02), (2@2012-01-02, 3@2012-01-03), 
	(3@2012-01-03, 4@2012-01-04)}"
SELECT asText(minusValues(tgeompoint '[Point(0 0 0)@2012-01-01, Point(3 3 3)@2012-01-04)',
	ARRAY[geometry 'Point(1 1 1)', 'Point(2 2 2)']));
-- "{[POINT Z (0 0 0)@2012-01-01, POINT Z (1 1 1)@2012-01-02),
	(POINT Z (1 1 1)@2012-01-02, POINT Z (2 2 2)@2012-01-03),
	(POINT Z (2 2 2)@2012-01-03, POINT Z (3 3 3)@2012-01-04)}"
					</programlisting>
				</listitem>

				<listitem id="minusRange">
					<para>Difference with a range</para>
					<para><varname>minusRange(tnumber, numrange): ttype</varname></para>
					<programlisting>
SELECT minusRange(tfloat '[1@2012-01-01, 4@2012-01-4)', floatrange '[2,3]');
-- "{[1@2012-01-01, 2@2012-01-02), (3@2012-01-03, 4@2012-01-04)}"
					</programlisting>
				</listitem>

				<listitem id="minusRanges">
					<para>Difference with an array of ranges</para>
					<para><varname>minusRanges(tnumber, numrange[]): ttype</varname></para>
					<programlisting>
SELECT minusRanges(tfloat '[1@2012-01-01, 5@2012-01-05)', 
	ARRAY[floatrange '[1,2]', '[3,4]']);
-- "{(2@2012-01-02, 3@2012-01-03), (4@2012-01-04, 5@2012-01-05)}"
					</programlisting>
				</listitem>

				<listitem id="minusMin">
					<para>Difference with the minimum value</para>
					<para><varname>minusMin(torder): torder</varname></para>
					<programlisting>
SELECT minusMin(tint '{1@2012-01-01, 2@2012-01-03, 1@2012-01-05}');
-- "{2@2012-01-03}"
SELECT minusMin(tfloat '[1@2012-01-01, 3@2012-01-03]');
-- "{(1@2012-01-01, 3@2012-01-03]}"
SELECT minusMin(tfloat '(1@2012-01-01, 3@2012-01-03)');
-- "{(1@2012-01-01, 3@2012-01-03)}"
SELECT minusMin(tint '{[1@2012-01-01, 1@2012-01-03), (1@2012-01-03, 1@2012-01-05)}');
-- NULL
					</programlisting>
				</listitem>

				<listitem id="minusMax">
					<para>Difference with the maximum value</para>
					<para><varname>minusMax(torder): torder</varname></para>
					<programlisting>
SELECT minusMax(tint '{1@2012-01-01, 2@2012-01-03, 3@2012-01-05}');
-- "{1@2012-01-01, 2@2012-01-03}"
SELECT minusMax(tfloat '[1@2012-01-01, 3@2012-01-03]');
-- "{[1@2012-01-01, 3@2012-01-03)}"
SELECT minusMax(tfloat '(1@2012-01-01, 3@2012-01-03)');
-- "{(1@2012-01-01, 3@2012-01-03)}"
SELECT minusMax(tfloat '{[2@2012-01-01, 1@2012-01-03), [2@2012-01-03, 2@2012-01-05)}');
-- "{(2@2012-01-01, 1@2012-01-03)}"
SELECT minusMax(tfloat '{[1@2012-01-01, 3@2012-01-03), (3@2012-01-03, 1@2012-01-05)}');
-- "{[1@2012-01-01, 3@2012-01-03), (3@2012-01-03, 1@2012-01-05)}"
					</programlisting>
				</listitem>

				<listitem id="minusGeometry">
					<para>Difference with a geometry</para>
					<para><varname>minusGeometry(tgeompoint, geometry): tgeompoint</varname></para>
					<programlisting>
SELECT asText(minusGeometry(tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-04)',
	geometry 'Polygon((1 1,1 2,2 2,2 1,1 1))'));
 -- "{[POINT(0 0)@2012-01-01, POINT(1 1)@2012-01-02), (POINT(2 2)@2012-01-03,
POINT(3 3)@2012-01-04)}"
					</programlisting>
				</listitem>

				<listitem id="minusTimestamp">
					<para>Difference with a timestamp</para>
					<para><varname>minusTimestamp(ttype, timestamptz): ttype</varname></para>
					<programlisting>
SELECT minusTimestamp(tfloat '[1@2012-01-01, 5@2012-01-05)', '2012-01-02');
-- "{[1@2012-01-01, 2@2012-01-02), (2@2012-01-02, 5@2012-01-05)}"
					</programlisting>
				</listitem>

				<listitem id="minusTimestampSet">
					<para>Difference with a timestamp set</para>
					<para><varname>minusTimestampSet(ttype, timestampset): ttype</varname></para>
					<programlisting>
SELECT minusTimestampSet(tint '[1@2012-01-01, 1@2012-01-15)',
	timestampset '{2012-01-02, 2012-01-03}');
-- "{[1@2012-01-01, 1@2012-01-02), (1@2012-01-02, 1@2012-01-03), 
	(1@2012-01-03, 1@2012-01-15)}"
					</programlisting>
				</listitem>

				<listitem id="minusPeriod">
					<para>Difference with a period</para>
					<para><varname>minusPeriod(ttype, period): ttype</varname></para>
					<programlisting>
SELECT minusPeriod(tfloat '{[1@2012-01-01, 3@2012-01-03), [3@2012-01-04, 1@2012-01-06)}',
	'[2012-01-02,2012-01-05)');
-- "{[1@2012-01-01, 2@2012-01-02), [2@2012-01-05, 1@2012-01-06)}"
					</programlisting>
				</listitem>

				<listitem id="minusPeriodSet">
					<para>Difference with a period set</para>
					<para><varname>minusPeriodSet(ttype, periodset): ttype</varname></para>
					<programlisting>
SELECT minusPeriodSet(tint '[1@2012-01-01, 1@2012-01-15)',
	periodset '{[2012-01-02, 2012-01-03), [2012-01-04, 2012-01-05)}');
-- "{[1@2012-01-01, 1@2012-01-02), [1@2012-01-03, 1@2012-01-04), 
	[1@2012-01-05, 1@2012-01-15)}"
					</programlisting>
				</listitem>

				<listitem id="minusTbox">
					<para>Difference with a <varname>tbox</varname></para>
					<para><varname>minusTbox(tnumber, tbox): tnumber</varname></para>
					<programlisting>
SELECT minusTbox(tfloat '[0@2012-01-01, 3@2012-01-04)',
	tbox 'TBOX((0, 2012-01-02), (2, 2012-01-04))');
-- "{[0@2012-01-01, 1@2012-01-02), (2@2012-01-03, 3@2012-01-04)}"
					</programlisting>
				</listitem>

				<listitem id="minusStbox">
					<para>Difference with an <varname>stbox</varname></para>
					<para><varname>minusStbox(tgeompoint, stbox): tgeompoint</varname></para>
					<programlisting>
SELECT asText(minusStbox(tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-04)',
	stbox 'STBOX T((0, 0, 2012-01-02), (2, 2, 2012-01-04))'));
-- "{[POINT(0 0)@2012-01-01, POINT(1 1)@2012-01-02),
	(POINT(2 2)@2012-01-03, POINT(3 3)@2012-01-04)}"
					</programlisting>
				</listitem>
			</itemizedlist>
		</sect1>

		<sect1 id="operators_temporal_types">
			<title>Comparison Operators</title>

			<para>The traditional comparison operators (<varname>=</varname>, <varname>&lt;</varname>, and so on) require that the left and right operands be of the same base type. Excepted equality  and inequality, the other comparison operators are not useful in the real world but allow B-tree indexes to be constructed on temporal types. These operators compare the bounding boxes (see <xref linkend="comparison_box_types" />) and if those are equal, then the comparison depends on the duration. For temporal instant values, they compare first the timestamps and if those are equal, compare the values. For temporal instant set and sequence values, they compare the first N instants, where N is the minimum of the number of composing instants of both values. Finally, for temporal sequence set values, they compare the first N sequence values, where N is the minimum of the number of composing sequences of both values.</para>

			<para>The equality and inequality operators consider the equivalent representation for different durations as shown next.
				<programlisting>
SELECT tint '1@2001-01-01' = tint '{1@2001-01-01}';
-- true
SELECT tfloat '1.5@2001-01-01' = tfloat '[1.5@2001-01-01]';
-- true
SELECT ttext 'AAA@2001-01-01' = ttext '{[AAA@2001-01-01]}';
-- true
SELECT tgeompoint '{Point(1 1)@2001-01-01, Point(2 2)@2001-01-02}' =
	tgeompoint '{[Point(1 1)@2001-01-01], [Point(2 2)@2001-01-02]}';
-- true
SELECT tgeogpoint '[Point(1 1 1)@2001-01-01, Point(2 2 2)@2001-01-02]' =
	tgeogpoint '{[Point(1 1 1)@2001-01-01], [Point(2 2 2)@2001-01-02]}';
-- true
				</programlisting>
			</para>

			<itemizedlist>
				<listitem id="ttype_eq">
				<para>Are the temporal values equal?</para>
				<para><varname>ttype = ttype: boolean</varname></para>
				<programlisting>
SELECT tint '[1@2012-01-01, 1@2012-01-04)' = tint '[2@2012-01-03, 2@2012-01-05)';
-- false
					</programlisting>
				</listitem>

				<listitem id="ttype_ne">
					<para>Are the temporal values different?</para>
					<para><varname>ttype &lt;&gt; ttype: boolean</varname></para>
					<programlisting>
SELECT tint '[1@2012-01-01, 1@2012-01-04)' &lt;&gt; tint '[2@2012-01-03, 2@2012-01-05)'
-- true
					</programlisting>
				</listitem>

				<listitem id="ttype_lt">
					<para>Is the first temporal value less than the second one?</para>
					<para><varname>ttype &lt; ttype: boolean</varname></para>
					<programlisting>
SELECT tint '[1@2012-01-01, 1@2012-01-04)' &lt; tint '[2@2012-01-03, 2@2012-01-05)'
-- true
					</programlisting>
				</listitem>

				<listitem id="ttype_gt">
					<para>Is the first temporal value greater than the second one?</para>
					<para><varname>ttype &gt; ttype: boolean</varname></para>
					<programlisting>
SELECT tint '[1@2012-01-01, 1@2012-01-04)' &gt; tint '[2@2012-01-03, 2@2012-01-05)'
-- false
					</programlisting>
				</listitem>

				<listitem id="ttype_le">
					<para>Is the first temporal value less than or equal to the second one?</para>
					<para><varname>ttype &lt;= ttype: boolean</varname></para>
					<programlisting>
SELECT tint '[1@2012-01-01, 1@2012-01-04)' &lt;= tint '[2@2012-01-03, 2@2012-01-05)'
-- true
					</programlisting>
				</listitem>

				<listitem id="ttype_ge">
					<para>Is the first temporal value greater than or equal to the second one?</para>
					<para><varname>ttype &gt;= ttype: boolean</varname></para>
					<programlisting>
SELECT tint '[1@2012-01-01, 1@2012-01-04)' &gt;= tint '[2@2012-01-03, 2@2012-01-05)'
-- false
					</programlisting>
				</listitem>
			</itemizedlist>
		</sect1>

		<sect1>
			<title>Ever and Always Comparison Operators</title>
			<para>A possible generalization of the traditional comparison operators (<varname>=</varname>, <varname>&lt;&gt;</varname>, <varname>&lt;</varname>, <varname>&lt;=</varname>,  etc.) to temporal types, is to determine whether the comparison is ever or always true. In this case, the result is a Boolean value. MobilityDB provides operators to test whether the comparison of a temporal value and a value of the base type is ever or always true. These operators are denoted by prefixing the traditional comparison operators with, respectively, <varname>?</varname> (ever) and <varname>%</varname> (always). Some examples are <varname>?=</varname>, <varname>%&lt;&gt;</varname>, or <varname>?&lt;=</varname>. Ever/always equality and non-equality are available for all temporal types, while ever/always inequalities are only available for temporal types whose base type has a total order defined, that is, <varname>tint</varname>, <varname>tfloat</varname>, or <varname>ttext</varname>. The ever and always comparisons are inverse operators: for example, <varname>?=</varname> is the inverse of <varname>%&lt;&gt;</varname>, and <varname>?&gt;</varname> is the inverse of <varname>%&lt;=</varname>.</para>
			<itemizedlist>
				<listitem id="ttype_eveq">
					<para>Is the temporal value ever equal to the value?</para>
					<para><varname>ttype ?= base: bool</varname></para>
					<para>The function does not take into account whether the bounds are inclusive or not.</para>
					<programlisting>
SELECT tfloat '[1@2012-01-01, 3@2012-01-04)' ?= 2;
-- true
SELECT tfloat '[1@2012-01-01, 3@2012-01-04)' ?= 3;
-- true
SELECT tgeompoint '[Point(0 0)@2012-01-01, Point(2 2)@2012-01-04)' ?= 
	geometry 'Point(1 1)';
-- true
					</programlisting>
				</listitem>

				<listitem id="ttype_evne">
					<para>Is the temporal value ever different from the value?</para>
					<para><varname>ttype ?&lt;&gt; base: bool</varname></para>
					<programlisting>
SELECT tfloat '[1@2012-01-01, 3@2012-01-04)' ?&lt;&gt; 2;
-- false
SELECT tfloat '[2@2012-01-01, 2@2012-01-04)' ?&lt;&gt; 2;
-- true
SELECT tgeompoint '[Point(1 1)@2012-01-01, Point(1 1)@2012-01-04)' ?&lt;&gt; 
	geometry 'Point(1 1)';
-- true
					</programlisting>
				</listitem>

				<listitem id="ttype_evlt">
					<para>Is the temporal value ever less than the value?</para>
					<para><varname>tnumber ?&lt; number: bool</varname></para>
					<programlisting>
SELECT tfloat '[1@2012-01-01, 4@2012-01-04)' ?&lt; 2;
-- "{[t@2012-01-01, f@2012-01-02, f@2012-01-04)}"
SELECT tint '[2@2012-01-01, 2@2012-01-05)' ?&lt; tfloat '[1@2012-01-03, 3@2012-01-05)';
-- "{[f@2012-01-03, f@2012-01-04], (t@2012-01-04, t@2012-01-05)}"
					</programlisting>
				</listitem>

				<listitem id="ttype_evgt">
					<para>Is the temporal value ever greater than the value?</para>
					<para><varname>tnumber ?&gt; number: bool</varname></para>
					<programlisting>
SELECT tint '[1@2012-01-03, 1@2012-01-05)' ?&gt; 1;
-- "[f@2012-01-03, f@2012-01-05)"
					</programlisting>
				</listitem>

				<listitem id="ttype_evle">
					<para>Is the temporal value ever less than or equal to the value?</para>
					<para><varname>tnumber ?&lt;= number: bool</varname></para>
					<programlisting>
SELECT tint '[1@2012-01-01, 1@2012-01-05)' ?&lt;= tfloat '{2@2012-01-03, 3@2012-01-04}';
-- "{t@2012-01-03, t@2012-01-04}"
					</programlisting>
				</listitem>

				<listitem id="ttype_evge">
					<para>Is the temporal value ever greater than or equal to the value?</para>
					<para><varname>tnumber ?&gt;= number: bool</varname></para>
					<programlisting>
SELECT 'AAA'::text ?&gt; ttext '{[AAA@2012-01-01, AAA@2012-01-03), 
	[BBB@2012-01-04, BBB@2012-01-05)}';
-- "{[f@2012-01-01, f@2012-01-03), [t@2012-01-04, t@2012-01-05)}"
					</programlisting>
				</listitem>

				<listitem id="ttype_aleq">
					<para>Is the temporal value always equal to the value?</para>
					<para><varname>ttype %= base: bool</varname></para>
					<para>The function does not take into account whether the bounds are inclusive or not.</para>
					<programlisting>
SELECT tfloat '[1@2012-01-01, 3@2012-01-04)' %= 2;
-- true
SELECT tfloat '[1@2012-01-01, 3@2012-01-04)' %= 3;
-- true
SELECT tgeompoint '[Point(0 0)@2012-01-01, Point(2 2)@2012-01-04)' %= 
	geometry 'Point(1 1)';
-- true
					</programlisting>
				</listitem>

				<listitem id="ttype_alne">
					<para>Is the temporal value always different to the value?</para>
					<para><varname>ttype %&lt;&gt; base: bool</varname></para>
					<programlisting>
SELECT tfloat '[1@2012-01-01, 3@2012-01-04)' %&lt;&gt; 2;
-- false
SELECT tfloat '[2@2012-01-01, 2@2012-01-04)' %&lt;&gt; 2;
-- true
SELECT tgeompoint '[Point(1 1)@2012-01-01, Point(1 1)@2012-01-04)' %&lt;&gt;
	geometry 'Point(1 1)';
-- true
					</programlisting>
				</listitem>

				<listitem id="ttype_allt">
					<para>Is the temporal value always less than the value?</para>
					<para><varname>tnumber %&lt; number: bool</varname></para>
					<programlisting>
SELECT tfloat '[1@2012-01-01, 4@2012-01-04)' %&lt; 2;
-- "{[t@2012-01-01, f@2012-01-02, f@2012-01-04)}"
SELECT tint '[2@2012-01-01, 2@2012-01-05)' %&lt; tfloat '[1@2012-01-03, 3@2012-01-05)';
-- "{[f@2012-01-03, f@2012-01-04], (t@2012-01-04, t@2012-01-05)}"
					</programlisting>
				</listitem>

				<listitem id="ttype_algt">
					<para>Is the temporal value always greater than the value?</para>
					<para><varname>tnumber %&gt; number: bool</varname></para>
					<programlisting>
SELECT tint '[1@2012-01-03, 1@2012-01-05)' %&gt; 1;
-- "[f@2012-01-03, f@2012-01-05)"
					</programlisting>
				</listitem>

				<listitem id="ttype_alle">
					<para>Is the temporal value always less than or equal to the value?</para>
					<para><varname>tnumber %&lt;= number: bool</varname></para>
					<programlisting>
SELECT tint '[1@2012-01-01, 1@2012-01-05)' %&lt;= tfloat '{2@2012-01-03, 3@2012-01-04}';
-- "{t@2012-01-03, t@2012-01-04}"
					</programlisting>
				</listitem>

				<listitem id="ttype_alge">
					<para>Is the temporal value always greater than or equal to the value?</para>
					<para><varname>tnumber %&gt;= number: bool</varname></para>
					<programlisting>
SELECT 'AAA'::text %&gt; ttext '{[AAA@2012-01-01, AAA@2012-01-03), 
	[BBB@2012-01-04, BBB@2012-01-05)}';
-- "{[f@2012-01-01, f@2012-01-03), [t@2012-01-04, t@2012-01-05)}"
					</programlisting>
				</listitem>
			</itemizedlist>
		</sect1>

		<sect1>
			<title>Temporal Comparison Operators</title>
			<para>Another possible generalization of the traditional comparison operators (<varname>=</varname>, <varname>&lt;&gt;</varname>, <varname>&lt;</varname>, <varname>&lt;=</varname>,  etc.) to temporal types, is to determine whether the comparison is true or false at each instant. In this case, the result is a temporal Boolean. The temporal comparison operators are denoted by prefixing the traditional comparison operators with <varname>#</varname>. Some examples are <varname>#=</varname>  or <varname>#&lt;=</varname>. Temporal equality and non-equality are available for all temporal types, while temporal inequalities are only available for temporal types whose base type has a total order defined, that is, <varname>tint</varname>, <varname>tfloat</varname>, or <varname>ttext</varname>.</para>

			<itemizedlist>
				<listitem id="ttype_teq">
					<para>Temporal equal</para>
					<para><varname>{base, ttype} #= {base, ttype}: tbool</varname></para>
					<programlisting>
SELECT tfloat '[1@2012-01-01, 2@2012-01-04)' #= 3;
-- "{[f@2012-01-01, f@2012-01-04)}"
SELECT tfloat '[1@2012-01-01, 4@2012-01-04)' #= tint '[1@2012-01-01, 1@2012-01-04)';
-- "{[t@2012-01-01], (f@2012-01-01, f@2012-01-04)}"
SELECT tfloat '[1@2012-01-01, 4@2012-01-04)' #= tfloat '[4@2012-01-02, 1@2012-01-05)';
-- "{[f@2012-01-02, t@2012-01-03], (f@2012-01-03, f@2012-01-04)}"
SELECT tgeompoint '[Point(0 0)@2012-01-01, Point(2 2)@2012-01-03)' #= 
	geometry 'Point(1 1)';
-- "{[f@2012-01-01, t@2012-01-02], (f@2012-01-02, f@2012-01-03)}"
SELECT tgeompoint '[Point(0 0)@2012-01-01, Point(2 2)@2012-01-03)' #=
	tgeompoint '[Point(0 2)@2012-01-01, Point(2 0)@2012-01-03)';
-- "{[f@2012-01-01], (t@2012-01-01, t@2012-01-03)}"
					</programlisting>
				</listitem>

				<listitem id="ttype_tne">
					<para>Temporal different</para>
					<para><varname>{base, ttype} #&lt;&gt; {base, ttype}: tbool</varname></para>
					<programlisting>
SELECT tfloat '[1@2012-01-01, 4@2012-01-04)' #&lt;&gt; 2;
-- "{[t@2012-01-01, f@2012-01-02], (t@2012-01-02, 2012-01-04)}"
SELECT tfloat '[1@2012-01-01, 4@2012-01-04)' #&lt;&gt; tint '[2@2012-01-02, 2@2012-01-05)';
-- "{[f@2012-01-02], (t@2012-01-02, t@2012-01-04)}"
					</programlisting>
				</listitem>

				<listitem id="ttype_tlt">
					<para>Temporal less than</para>
					<para><varname>{base, torder} #&lt; {base, torder}: tbool</varname></para>
					<programlisting>
SELECT tfloat '[1@2012-01-01, 4@2012-01-04)' #&lt; 2;
-- "{[t@2012-01-01, f@2012-01-02, f@2012-01-04)}"
SELECT tint '[2@2012-01-01, 2@2012-01-05)' #&lt; tfloat '[1@2012-01-03, 3@2012-01-05)';
-- "{[f@2012-01-03, f@2012-01-04], (t@2012-01-04, t@2012-01-05)}"
					</programlisting>
				</listitem>

				<listitem id="ttype_tgt">
					<para>Temporal greater than</para>
					<para><varname>{base, torder} #&gt; {base, torder}: tbool</varname></para>
					<programlisting>
SELECT 1 #&gt; tint '[1@2012-01-03, 1@2012-01-05)';
-- "[f@2012-01-03, f@2012-01-05)"
					</programlisting>
				</listitem>

				<listitem id="ttype_tle">
					<para>Temporal less than or equal to</para>
					<para><varname>{base, torder} #&lt;= {base, torder}: tbool</varname></para>
					<programlisting>
SELECT tint '[1@2012-01-01, 1@2012-01-05)' #&lt;= tfloat '{2@2012-01-03, 3@2012-01-04}';
-- "{t@2012-01-03, t@2012-01-04}"
					</programlisting>
				</listitem>

				<listitem id="ttype_tge">
					<para>Temporal greater than or equal to</para>
					<para><varname>{base, torder} #&gt;= {base, torder}: tbool</varname></para>
					<programlisting>
SELECT 'AAA'::text #&gt; ttext '{[AAA@2012-01-01, AAA@2012-01-03), 
	[BBB@2012-01-04, BBB@2012-01-05)}';
-- "{[f@2012-01-01, f@2012-01-03), [t@2012-01-04, t@2012-01-05)}"
					</programlisting>
				</listitem>
			</itemizedlist>
		</sect1>
				
		<sect1>
			<title>Mathematical Functions and Operators</title>

			<itemizedlist>
				<listitem id="tnumber_add">
					<para>Temporal addition</para>
					<para><varname>{number, tnumber} + {number, tnumber}: tnumber</varname></para>
					<programlisting>
SELECT tint '[2@2012-01-01, 2@2012-01-04)' + 1.5;
-- "[3.5@2012-01-01, 3.5@2012-01-04)"
SELECT tint '[2@2012-01-01, 2@2012-01-04)' + tfloat '[1@2012-01-01, 4@2012-01-04)';
-- "[3@2012-01-01, 6@2012-01-04)"
SELECT tfloat '[1@2012-01-01, 4@2012-01-04)' +
	tfloat '{[1@2012-01-01, 2@2012-01-02), [1@2012-01-02, 2@2012-01-04)}';
-- "{[2@2012-01-01, 4@2012-01-04), [3@2012-01-02, 6@2012-01-04)}"
					</programlisting>
				</listitem>

				<listitem id="tnumber_sub">
					<para>Temporal subtraction</para>
					<para><varname>{number, tnumber} - {number, tnumber}: tnumber</varname></para>
					<programlisting>
SELECT tint '[1@2012-01-01, 1@2012-01-04)' - tint '[2@2012-01-03, 2@2012-01-05)';
-- "[-1@2012-01-03, -1@2012-01-04)"
SELECT tfloat '[3@2012-01-01, 6@2012-01-04)' - tint '[2@2012-01-01, 2@2012-01-04)';
-- "[1@2012-01-01, 4@2012-01-04)"
					</programlisting>
				</listitem>

				<listitem id="tnumber_mult">
					<para>Temporal multiplication</para>
					<para><varname>{number, tnumber} * {number, tnumber}: tnumber</varname></para>
					<programlisting>
SELECT tfloat '[1@2012-01-01, 4@2012-01-04)' * 2;
-- "[2@2012-01-01, 8@2012-01-04)"
SELECT tfloat '[1@2012-01-01, 4@2012-01-04)' * tint '[2@2012-01-01, 2@2012-01-04)';
-- "[2@2012-01-01, 8@2012-01-04)"
SELECT tfloat '[1@2012-01-01, 3@2012-01-03)' * '[3@2012-01-01, 1@2012-01-03)'
-- "{[3@2012-01-01, 4@2012-01-02, 3@2012-01-03)}"
					</programlisting>
				</listitem>

				<listitem id="tnumber_div">
					<para>Temporal division</para>
					<para><varname>{number, tnumber} / {number, tnumber}: tnumber</varname></para>
					<para>The function will raise an error if the denominator will ever be equal to zero during the common timespan of the arguments.</para>
					<programlisting>
SELECT 2 / tfloat '[1@2012-01-01, 3@2012-01-04)';
-- "[2@2012-01-01, 1@2012-01-02 12:00:00+00, 0.666666666666667@2012-01-04)"
SELECT tfloat '[1@2012-01-01, 5@2012-01-05)' / '[5@2012-01-01, 1@2012-01-05)'
-- "{[0.2@2012-01-01, 1@2012-01-03,2012-01-03, 5@2012-01-03,2012-01-05)}"
select 2 / tfloat '[-1@2000-01-01, 1@2000-01-02]'
-- ERROR:  Division by zero
select tfloat '[-1@2000-01-04, 1@2000-01-05]' / tfloat '[-1@2000-01-01, 1@2000-01-05]'
-- "[-2@2000-01-04, 1@2000-01-05]"
					</programlisting>
				</listitem>

				<listitem id="round">
					<para>Round to n decimal places</para>
					<para><varname>round(tfloat, integer): tfloat</varname></para>
					<programlisting>
SELECT round(tfloat '[0.785398163397448@2000-01-01, 2.35619449019234@2000-01-02]', 2);
-- "[0.79@2000-01-01, 2.36@2000-01-02]"
					</programlisting>
				</listitem>

				<listitem id="degrees">
					<para>Convert from radians to degrees</para>
					<para><varname>degrees(tfloat): tfloat</varname></para>
					<programlisting>
SELECT degrees(tfloat '[0.785398163397448@2000-01-01, 2.35619449019234@2000-01-02]');
-- "[45@2000-01-01, 135@2000-01-02]"
					</programlisting>
				</listitem>
			</itemizedlist>
		</sect1>

		<sect1>
			<title>Boolean Operators</title>
			<itemizedlist>
				<listitem id="tbool_and">
					<para>Temporal and</para>
					<para><varname>{bool, tbool} &amp; {bool, tbool}: tbool</varname></para>
					<programlisting>
SELECT tbool '[true@2012-01-03, true@2012-01-05)' &amp; 
	tbool '[false@2012-01-03, false@2012-01-05)';
-- "[f@2012-01-03, f@2012-01-05)"
SELECT tbool '[true@2012-01-03, true@2012-01-05)' &amp; 
	tbool '{[false@2012-01-03, false@2012-01-04), 
	[true@2012-01-04, true@2012-01-05)}';
-- "{[f@2012-01-03, t@2012-01-04, t@2012-01-05)}"
					</programlisting>
				</listitem>

				<listitem id="tbool_or">
					<para>Temporal or</para>
					<para><varname>{bool, tbool} | {bool, tbool}: tbool</varname></para>
					<programlisting>
SELECT tbool '[true@2012-01-03, true@2012-01-05)' | 
	tbool '[false@2012-01-03, false@2012-01-05)';
-- "[t@2012-01-03, t@2012-01-05)"
					</programlisting>
				</listitem>

				<listitem id="tbool_not">
					<para>Temporal not</para>
					<para><varname>~ tbool: tbool</varname></para>
					<programlisting>
SELECT ~ tbool '[true@2012-01-03, true@2012-01-05)';
-- "[f@2012-01-03, f@2012-01-05)"
					</programlisting>
				</listitem>
			</itemizedlist>
		</sect1>

		<sect1>
			<title>Text Functions and Operators</title>

			<itemizedlist>
				<listitem id="ttext_concat">
					<para>Temporal text concatenation</para>
					<para><varname>{text, ttext} || {text, ttext}: ttext</varname></para>
					<programlisting>
SELECT ttext '[AA@2012-01-01, AA@2012-01-04)' || text 'B';
-- "["AAB"@2012-01-01, "AAB"@2012-01-04)"
SELECT ttext '[AA@2012-01-01, AA@2012-01-04)' || ttext '[BB@2012-01-02, BB@2012-01-05)';
-- "["AABB"@2012-01-02, "AABB"@2012-01-04)"
SELECT ttext '[A@2012-01-01, B@2012-01-03, C@2012-01-04]' ||
	ttext '{[D@2012-01-01, D@2012-01-02), [E@2012-01-02, E@2012-01-04)}';
-- "{["DA"@2012-01-01, "EA"@2012-01-02, "EB"@2012-01-03, "EB"@2012-01-04)}"
					</programlisting>
				</listitem>

				<listitem id="ttext_upper">
					<para>Transform to uppercase</para>
					<para><varname>upper(ttext): ttext</varname></para>
					<programlisting>
SELECT upper(ttext '[AA@2000-01-01, bb@2000-01-02]');
-- "["AA"@2000-01-01, "BB"@2000-01-02]"
					</programlisting>
				</listitem>

				<listitem id="ttext_lower">
					<para>Transform to lowercase</para>
					<para><varname>lower(ttext): ttext</varname></para>
					<programlisting>
SELECT lower(ttext '[AA@2000-01-01, bb@2000-01-02]');
-- "["aa"@2000-01-01, "bb"@2000-01-02]"
					</programlisting>
				</listitem>
			</itemizedlist>
		</sect1>

		<sect1>
			<title>Bounding Box Operators</title>
			<para>These operators test whether the bounding boxes of their arguments satisfy the predicate and result in a Boolean value. As stated in <xref linkend="temporal_types" />, the bounding box associated to a temporal type depends on the base type: It is the <varname>period</varname> type for the <varname>tbool</varname> and <varname>ttext</varname> types, the <varname>tbox</varname> type for the <varname>tint</varname> and <varname>tfloat</varname> types, and the <varname>stbox</varname> type for the <varname>tgeompoint</varname> and <varname>tgeogpoint</varname> types. Furthermore, as seen in <xref linkend="casting_box_types" />, many PostgreSQL, PostGIS, or MobilityDB types can be cast to the <varname>tbox</varname> and <varname>stbox</varname> types. For example, numeric values and ranges can be casted to <varname>tbox</varname>, <varname>geometry</varname> and <varname>geography</varname> values can be casted to <varname>stbox</varname>, and time types and temporal types can be cast to <varname>tbox</varname> and <varname>stbox</varname> types.</para>


			<para>A first set of operators consider the relative position of the bounding boxes. The operators <varname>&lt;&lt;</varname>, <varname>&gt;&gt;</varname>, <varname>&amp;&lt;</varname>, and <varname>&amp;&gt;</varname> consider the value dimension for <varname>tint</varname> and <varname>tfloat</varname> types and the X coordinates for the <varname>tgeompoint</varname> and <varname>tgeogpoint</varname> types, the operators <varname>&lt;&lt;|</varname>, <varname>|&gt;&gt;</varname>, <varname>&amp;&lt;|</varname>, and <varname>|&amp;&gt;</varname> consider the Y coordinates for the <varname>tgeompoint</varname> and <varname>tgeogpoint</varname> types, the operators <varname>&lt;&lt;/</varname>, <varname>/&gt;&gt;</varname>, <varname>&amp;&lt;/</varname>, and <varname>/&amp;&gt;</varname> consider the Z coordinates for the <varname>tgeompoint</varname> and <varname>tgeogpoint</varname> types, and the operators <varname>&lt;&lt;#</varname>, <varname>#&gt;&gt;</varname>, <varname>#&amp;&lt;</varname>, and <varname>#&amp;&gt;</varname> consider the time dimension for all temporal types.</para>

			<para>Another set of operators consider the topological relationships between the bounding boxes. There are five topological operators: overlaps (<varname>&amp;&amp;</varname>), contains (<varname>@&gt;</varname>), contained (<varname>&lt;@</varname>), same (<varname>~=</varname>), and adjacent (<varname>-|-</varname>). The arguments of these operators can be a base type, a box, or a temporal type and the operators verify the topological relationship taking into account the value and/or the time dimension depending on the type of the arguments.</para>

			<para>We refer to <xref linkend="operators_box_types" /> for the bounding box operators.</para>
		</sect1>

		<sect1>
			<title>Distance Operators</title>
			<para>There are two distance operators. The first one computes the distance between either a temporal point and a geometry or between two temporal points at their nearest point of approach, which is a float. This is the same as the function <varname>nearestApproachDistance</varname> discussed before but as an operator it can be used for doing nearest neightbor searches using a GiST index (see <xref linkend="indexing_temporal_types" />).</para>

			<para>On the other hand, the temporal distance operator computes the distance at each instant of the intersection of the temporal extents of their arguments and results in a temporal float. Computing temporal distance is useful in many mobility applications. For example, a moving cluster (also known as convoy or flock) is defined as a set of objects that move close to each other for a long time interval. This requires to compute temporal distance between two moving objects.</para>
		
			<para>The temporal distance operator accepts a geometry/geography restricted to a point or a temporal point as arguments. Notice that the temporal types only consider linear interpolation between values, while the distance is a root of a quadratic function. Therefore, the temporal distance operator gives a linear approximation of the actual distance value for temporal sequence points. In this case, the arguments are synchronized in the time dimension, and for each of the composing line segments of the arguments, the spatial distance between the start point, the end point, and the nearest point of approach is computed, as shown in the examples below.</para>

			<itemizedlist>
				<listitem id="smallest_distance">
					<para>Get the smallest distance ever &Z_support; &geography_support;</para>
					<para><varname>{geometry, tgeompoint} |=| {geometry, tgeompoint}: float</varname></para>
					<programlisting>
SELECT tgeompoint '[Point(0 0)@2012-01-02, Point(1 1)@2012-01-04, Point(0 0)@2012-01-06)' 
	|=| geometry 'Linestring(2 2,2 1,3 1)';
-- "1"
SELECT tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03, Point(0 0)@2012-01-05)' 
	|=| tgeompoint '[Point(2 0)@2012-01-02, Point(1 1)@2012-01-04, Point(2 2)@2012-01-06)';
-- "0.5"
					</programlisting>
				</listitem>

				<listitem id="distance">
					<para>Get the temporal distance &Z_support; &geography_support;</para>
					<para><varname>{point, tpoint} &lt;-&gt; {point, tpoint}: tfloat</varname></para>
					<programlisting>
SELECT tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)' &lt;-&gt; 
	geometry 'Point(0 1)';
-- "[1@2012-01-01, 0.707106781186548@2012-01-02, 1@2012-01-03)"
SELECT tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)' &lt;-&gt;
	tgeompoint '[Point(0 1)@2012-01-01, Point(1 0)@2012-01-03)';
-- "[1@2012-01-01, 0@2012-01-02, 1@2012-01-03)"
SELECT tgeompoint '[Point(0 1)@2012-01-01, Point(0 0)@2012-01-03)' &lt;-&gt;
	tgeompoint '[Point(0 0)@2012-01-01, Point(1 0)@2012-01-03)';
-- "[1@2012-01-01, 0.707106781186548@2012-01-02, 1@2012-01-03)"
SELECT tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-02)' &lt;-&gt;
	tgeompoint '[Point(0 1)@2012-01-01, Point(1 2)@2012-01-02)';
-- "[1@2012-01-01,1@2012-01-02)"
					</programlisting>
				</listitem>
			</itemizedlist>
		</sect1>

		<sect1 id="topological_relationships_temporal_points">
			<title>Topological Relationships for Temporal Points</title>

			<para>The topological relationships such as <varname>ST_Intersects</varname> and <varname>ST_Relate</varname> can be generalized for temporal points. The arguments of these generalized functions are either a temporal point or a base type (that is, a geometry or a geography), but these functions do not allow a base type in both arguments. Furthermore, both arguments must be of the same base type, that is, these functions do not allow to have a temporal geometry point (or a geometry) and a temporal geography point (or a geography) as arguments.</para>

			<para>There are two versions of the temporal topological relationships:</para>
			<itemizedlist>
				<listitem>
					<para>The first version applies the traditional topological function to the union of all values taken by the temporal point (which is a <varname>geometry</varname> or <varname>geography</varname>) and returns a <varname>boolean</varname> or a <varname>text</varname>. Examples are the <varname>intersects</varname> and <varname>relate</varname> functions.</para>
				</listitem>

				<listitem>
					<para>The second version is defined with the temporal semantics, that is, the traditional topological function is computed at each instant and results in a <varname>tbool</varname> or a <varname>ttext</varname>. Examples are the <varname>tintersects</varname> and <varname>trelate</varname> functions.</para>
				</listitem>
			</itemizedlist>

			<para>All spatial relationships in the two versions are defined for temporal geometry points, while only four of them are defined for temporal geography points, namely, <varname>covers</varname>, <varname>coveredby</varname>, <varname>intersects</varname>, and <varname>dwithin</varname>, and the corresponding temporal versions.</para>

			<para>The semantics conveyed by the first version of the relationships varies depending on the relationship and the type of the arguments. For example, the following query
				<programlisting>
SELECT intersects(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',
	tgeompoint '[Point(0 1)@2012-01-01, Point(1 1)@2012-01-03)');
				</programlisting>
			tests whether the temporal point ever intersected the geometry, since the query is conceptually equivalent to the following one.
				<programlisting>
SELECT ST_Intersects(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))', 
	geometry 'Linestring(0 1,1 1)');
				</programlisting>
			where the second geometry is obtained by applying the <varname>trajectory</varname> function to the temporal point. On the other hand, the query
				<programlisting>
SELECT contains(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',
	tgeompoint '[Point(0 1)@2012-01-01, Point(1 1)@2012-01-03)');
				</programlisting>
				tests whether the geometry always contains the temporal point. Finally, the following query
				<programlisting>
SELECT intersects(tgeompoint '[Point(0 1)@2012-01-01, Point(1 0)@2012-01-03)',
	tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)');
				</programlisting>
				tests whether the temporal points may intersect, since the query above is conceptually equivalent to the following one 
				<programlisting>
SELECT ST_Intersects('Linestring(0 1,1 0)', 'Linestring(0 0,1 1)');
				</programlisting>
			</para>
						
			<para>The first versions of the relationships are typically used in combination with a spatio-temporal index when computing the temporal relationships. For example, the following query
				<programlisting>
SELECT T.TripId, R.RegionId, tintersects(T.Trip, R.Geom)
FROM Trips T, Regions R
WHERE intersects(T.Trip, R.Geom)
				</programlisting>
			which verifies whether a trip <varname>T</varname> (which is a temporal point) intersects a region <varname>R</varname> (which is a geometry), will benefit rom a spatio-temporal index on the column <varname>T.Trip</varname> since the <varname>intersects</varname> function will automatically perform the bounding box comparison <varname>T.Trip &amp;&amp; R.Geom</varname>. This is further explained later in this document.
			</para>
			
			<para>Three topological relationships available in PostGIS are not provided in the temporal version.
				<itemizedlist>
					<listitem>
						<para><varname>tcontainsproperly</varname> since it would always be equal to <varname>tcontains</varname>: <varname>ST_Contains</varname> returns true if and only if no points of B lie in the exterior of A, and at least one point of the interior of B lies in the interior of A. <varname>ST_ContainsProperly</varname> returns true if B intersects the interior of A but not the boundary (or exterior).</para>
					</listitem>

					<listitem>
						<para><varname>tcrosses</varname> since it would always returns false: <varname>ST_Crosses</varname> returns true if the supplied geometries have some, but not all, interior points in common.</para>
					</listitem>

					<listitem>
						<para><varname>toverlaps</varname> since it would always returns false: <varname>ST_Overlaps</varname> returns true if the geometries share space, are of the same dimension, but are not completely contained by each other.</para>
					</listitem>
				</itemizedlist>
				</para>

			<para>Similarly, only a few temporal topological relationships are meaningful when the two arguments are temporal points. Therefore, the relationships supported for two temporal geometry points are <varname>tdisjoint</varname>, <varname>tequals</varname>, <varname>tintersects</varname>, <varname>tdwithin</varname>, and <varname>trelate</varname> (with 2 and 3 arguments), while only <varname>tintersects</varname> and <varname>tdwithin</varname> are supported for two temporal geography points.</para>

		
			<para>The <varname>relate</varname> and the <varname>trelate</varname> functions have two forms with either two or three arguments. The two-argument forms consider the spatial relationship between the interior, the boundary, and the exterior of the arguments and return a <varname>text</varname> or a <varname>ttext</varname> value representing the maximum intersection matrix pattern. This pattern is defined using the Dimensionally Extended 9 Intersection Model or DE-9IM (see the PostGIS documentation for more details). The three-argument forms determine whether the first two arguments satisfy the intersection matrix pattern given as third argument (a <varname>text</varname> value) and return a Boolean or a temporal Boolean.</para>

			<sect2>
				<title>Possible Spatial Relationships</title>
				<itemizedlist>
					<listitem id="contains">
						<para>May contain</para>
						<para><varname>contains({geo, tgeompoint}, {geo, tgeompoint}): boolean</varname></para>
						<programlisting>
SELECT contains(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',
	tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)');
-- true
						</programlisting>
					</listitem>

					<listitem id="containsproperly">
						<para>May contain properly</para>
						<para><varname>containsproperly({geo, tgeompoint}, {geo, tgeompoint}): boolean</varname></para>
						<programlisting>
SELECT containsproperly(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',
	tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)');
-- false
						</programlisting>
					</listitem>

					<listitem id="covers">
						<para>May cover</para>
						<para><varname>covers({geo, tpoint}, {geo, tpoint}): boolean</varname></para>
						<programlisting>
SELECT covers(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',
	tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)');
-- true
						</programlisting>
					</listitem>

					<listitem id="coveredby">
						<para>May be covered by</para>
						<para><varname>coveredby({geo, tpoint}, {geo, tpoint}): boolean</varname></para>
						<programlisting>
SELECT coveredby(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',
	tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)');
-- false
						</programlisting>
					</listitem>

					<listitem id="crosses">
						<para>May cross</para>
						<para><varname>crosses({geo, tgeompoint}, {geo, tgeompoint}): boolean</varname></para>
						<programlisting>
SELECT crosses(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',
	tgeompoint '[Point(0 0)@2012-01-01, Point(2 2)@2012-01-03)');
-- true
						</programlisting>
					</listitem>

					<listitem id="disjoint">
						<para>May be disjoint</para>
						<para><varname>disjoint({geo, tgeompoint}, {geo, tgeompoint}): boolean</varname></para>
						<programlisting>
SELECT disjoint(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',
	tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)');
-- false
						</programlisting>
					</listitem>

					<listitem id="equals">
						<para>May be equal</para>
						<para><varname>equals({geo, tgeompoint}, {geo, tgeompoint}): boolean</varname></para>
						<programlisting>
SELECT equals(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',
	tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)');
-- false
						</programlisting>
					</listitem>

					<listitem id="intersects">
						<para>May intersect &Z_support;</para>
					<para><varname>intersects({geo, tpoint}, {geo, tpoint}): boolean</varname></para>
						<programlisting>
SELECT intersects(geometry 'Polygon((0 0 0,0 1 0,1 1 0,1 0 0,0 0 0))',
	tgeompoint '[Point(0 0 1)@2012-01-01, Point(1 1 1)@2012-01-03)');
-- false
SELECT intersects(geometry 'Polygon((0 0 0,0 1 1,1 1 1,1 0 0,0 0 0))',
	tgeompoint '[Point(0 0 1)@2012-01-01, Point(1 1 1)@2012-01-03)');
-- true
						</programlisting>
					</listitem>

					<listitem id="overlaps">
						<para>May overlap</para>
						<para><varname>overlaps({geo, tgeompoint}, {geo, tgeompoint}): boolean</varname></para>
						<programlisting>
SELECT overlaps(geometry 'Linestring(1 1,3 3)',
	tgeompoint '[Point(0 0)@2012-01-01, Point(2 2)@2012-01-03)');
-- true
						</programlisting>
					</listitem>

					<listitem id="touches">
						<para>May touch</para>
						<para><varname>touches({geo, tgeompoint}, {geo, tgeompoint}): boolean</varname></para>
						<programlisting>
SELECT touches(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',
	tgeompoint '[Point(0 0)@2012-01-01, Point(0 1)@2012-01-03)');
-- true
						</programlisting>
					</listitem>

					<listitem id="within">
						<para>May be within</para>
						<para><varname>within({geo, tgeompoint}, {geo, tgeompoint}): boolean</varname></para>
						<programlisting>
SELECT within(geometry 'LineString(1 1,2 2)',
	tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-03)');
-- true
						</programlisting>
					</listitem>

					<listitem id="dwithin">
						<para>May be at distance within &Z_support;</para>
					<para><varname>dwithin({geo, tpoint}, {geo, tpoint}, double): boolean</varname></para>
						<programlisting>
SELECT dwithin(geometry 'Polygon((0 0 0,0 1 1,1 1 1,1 0 0,0 0 0))',
	tgeompoint 'Point(0 2 1)@2000-01-01,Point(2 2 1)@2000-01-02', 1)
-- true
SELECT dwithin(geometry 'Polygon((0 0 0,0 1 1,1 1 1,1 0 0,0 0 0))',
	tgeompoint 'Point(0 2 2)@2000-01-01,Point(2 2 2)@2000-01-02', 1)
--	false
						</programlisting>
					</listitem>

					<listitem id="relate">
						<para>May relate</para>
						<para><varname>relate({geo, tgeompoint}, {geo, tgeompoint}): text</varname></para>
						<para><varname>relate({geo, tgeompoint}, {geo, tgeompoint}, text): boolean</varname></para>
						<programlisting>
SELECT relate(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',
	tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)');
-- "1F2F01FF2"
SELECT relate(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))',
	tgeompoint '[Point(0 0)@2012-01-01, Point(1 1)@2012-01-03)','1F2F01FF2');
-- true
						</programlisting>
					</listitem>
				</itemizedlist>
			</sect2>

			<sect2>
				<title>Temporal Spatial Relationships</title>
				<itemizedlist>
					<listitem id="tcontains">
						<para>Temporal contains</para>
						<para><varname>tcontains({geo, tgeompoint}, {geo, tgeompoint}): tbool</varname></para>
						<programlisting>
SELECT tcontains(geometry 'Polygon((1 1,1 2,2 2,2 1,1 1))',
	tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-04)');
-- "{[f@2012-01-01, f@2012-01-02], (t@2012-01-02, f@2012-01-03, f@2012-01-04)}"
						</programlisting>
					</listitem>

					<listitem id="tcovers">
						<para>Temporal covers &geography_support;</para>
						<para><varname>tcovers({geo, tpoint}, {geo, tpoint}): tbool</varname></para>
						<programlisting>
SELECT tcovers(geometry 'Polygon((1 1,1 2,2 2,2 1,1 1))',
	tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-04)');
-- "{[f@2012-01-01, t@2012-01-02, t@2012-01-03], (f@2012-01-03, f@2012-01-04]}"
						</programlisting>
					</listitem>

					<listitem id="tcoveredby">
						<para>Temporal covered by &geography_support;</para>
						<para><varname>tcoveredby({geo, tpoint}, {geo, tpoint}): tbool</varname></para>
						<programlisting>
SELECT tcoveredby(geometry 'Point(1 1)',
	tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-04)');
-- "{[f@2012-01-01, t@2012-01-02], (f@2012-01-02, f@2012-01-04)}"
						</programlisting>
					</listitem>

					<listitem id="tdisjoint">
						<para>Temporal disjoint &Z_support; &geography_support;</para>
						<para><varname>tdisjoint({geo, tgeompoint}, {geo, tgeompoint}): tbool</varname></para>
						<programlisting>
SELECT tdisjoint(geometry 'Polygon((1 1,1 2,2 2,2 1,1 1))',
	tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-04)');
-- "{[t@2012-01-01, f@2012-01-02, f@2012-01-03], (t@2012-01-03, t@2012-01-04]}"
SELECT tdisjoint(tgeompoint '[Point(0 3)@2012-01-01, Point(3 0)@2012-01-05)',
	tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-05)');
-- "{[t@2012-01-01, f@2012-01-03], (t@2012-01-03, t@2012-01-05)}"
						</programlisting>
					</listitem>

					<listitem id="tequals">
						<para>Temporal equals &Z_support; &geography_support;</para>
						<para><varname>tequals({point, tgeompoint}, {point, tgeompoint}): tbool</varname></para>
						<programlisting>
SELECT tequals(geometry 'Point(1 1)',
	tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-04)');
-- "{[f@2012-01-01, t@2012-01-02], (f@2012-01-02, f@2012-01-04]}"
SELECT tequals(tgeompoint '[Point(0 3)@2012-01-01, Point(3 0)@2012-01-05)',
	tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-05)');
-- "{[f@2012-01-01, t@2012-01-03], (f@2012-01-03, f@2012-01-05)}"
						</programlisting>
					</listitem>

					<listitem id="tintersects">
						<para>Temporal intersects &Z_support; &geography_support;</para>
					<para><varname>tintersects({geo, tpoint}, {geo, tpoint}): tbool</varname></para>
						<programlisting>
SELECT tintersects(geometry 'MultiPoint(1 1,2 2)',
	tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-04)');
-- "{[f@2012-01-01, t@2012-01-02], (f@2012-01-02, t@2012-01-03],
	(f@2012-01-03, f@2012-01-04]}"
SELECT tintersects(tgeompoint '[Point(0 3)@2012-01-01, Point(3 0)@2012-01-05)',
	tgeompoint '[Point(0 0)@2012-01-01, Point(3 3)@2012-01-05)');
-- "{[f@2012-01-01, t@2012-01-03], (f@2012-01-03, f@2012-01-05)}"
						</programlisting>
					</listitem>

					<listitem id="ttouches">
						<para>Temporal touches</para>
						<para><varname>ttouches({geo, tgeompoint}, {geo, tgeompoint}): tbool</varname></para>
						<programlisting>
SELECT ttouches(geometry 'Polygon((1 0,1 2,2 2,2 0,1 0))',
	tgeompoint '[Point(0 0)@2012-01-01, Point(3 0)@2012-01-04)');
-- "{[f@2012-01-01, t@2012-01-02, t@2012-01-03], (f@2012-01-03, f@2012-01-04]}"
						</programlisting>
					</listitem>

					<listitem id="twithin">
						<para>Temporal within</para>
						<para><varname>twithin({geo, tgeompoint}, {geo, tgeompoint}): tbool</varname></para>
						<programlisting>
SELECT twithin(geometry 'Point(1 1)',
	tgeompoint '[Point(0 0)@2012-01-01, Point(2 2)@2012-01-03)');
-- "{[f@2012-01-01, t@2012-01-02], (f@2012-01-02, f@2012-01-03]}"
						</programlisting>
					</listitem>

					<listitem id="tdwithin">
						<para>Temporal distance within &Z_support; &geography_support;</para>
						<para><varname>tdwithin({geo, tpoint}, {geo, tpoint}, double): tbool</varname></para>
						<programlisting>
SELECT tdwithin(geometry 'Polygon((1 1,1 2,2 2,2 1,1 1))',
	tgeompoint '[Point(0 0)@2012-01-01, Point(3 0)@2012-01-04)', 1);
-- "{[f@2012-01-01, t@2012-01-02, t@2012-01-03], (f@2012-01-03, f@2012-01-04)}"
SELECT tdwithin(tgeompoint '[Point(1 0)@2000-01-01, Point(1 4)@2000-01-05]', 
	tgeompoint 'Interp=Stepwise;[Point(1 2)@2000-01-01, Point(1 3)@2000-01-05]', 1);
-- "{[f@2000-01-01, t@2000-01-02, t@2000-01-04], (f@2000-01-04, t@2000-01-05]}"
						</programlisting>
					</listitem>

					<listitem id="trelate">
						<para>Temporal relate</para>
						<para><varname>trelate({geo, tgeompoint}, {geo, tgeompoint}, text): tbool</varname></para>
						<para><varname>trelate({geo, tgeompoint}, {geo, tgeompoint}): ttext</varname></para>
						<programlisting>
SELECT trelate(geometry 'Polygon((1 0,1 2,2 2,2 0,1 0))',
	tgeompoint '[Point(0 0)@2012-01-01, Point(3 0)@2012-01-04)');
-- "{[FF2FF10F2@2012-01-01, FF20F1FF2@2012-01-02, FF20F1FF2@2012-01-03],
	(FF2FF10F2@2012-01-03, FF2FF10F2@2012-01-04]}"
SELECT trelate(geometry 'Polygon((1 0,1 2,2 2,2 0,1 0))',
	tgeompoint '[Point(0 0)@2012-01-01, Point(3 0)@2012-01-04)', 'FF20F1FF2');
-- "{[f@2012-01-01, t@2012-01-02, t@2012-01-03], (f@2012-01-03, f@2012-01-04]}"
	2012-01-04)}"
						</programlisting>
					</listitem>
				</itemizedlist>
				</sect2>
		</sect1>

		<sect1>
			<title>Aggregate Functions for Temporal Types</title>

			<para>The temporal aggregate functions generalize the traditional aggregate functions. Their semantics is that they compute the value of the function at every instant t in the union of the temporal extents of the values to aggregate.</para>

			<para>For all temporal types, the function <varname>tcount</varname> generalize the traditional function <varname>count</varname>. The temporal count can be used to compute at each point in time the number of available or reporting objects (for example, number of cars in an area). For Boolean types, the functions <varname>tand</varname> and <varname>tor</varname> generalize the traditional functions <varname>and</varname> and <varname>or</varname>. For numeric types, two types of temporal aggregate functions are available. The functions <varname>tmin</varname>, <varname>tmax</varname>, <varname>tsum</varname>, and <varname>tavg</varname> generalize the traditional functions <varname>min</varname>, <varname>max</varname>, <varname>sum</varname>, and <varname>avg</varname>. Furthermore, the functions <varname>wmin</varname>, <varname>wmax</varname>, <varname>wcount</varname>, <varname>wsum</varname>, and <varname>wavg</varname> are window (or cumulative) versions of the traditional functions that, given a time interval w, compute the value of the function at an instant t by considering the values during the interval [t-w, t]. All window aggregate functions are available for temporal integers, while for temporal floats only window minimum and maximum are meaningful. For temporal text, the functions Finally, for temporal points the function <varname>tcentroid</varname>, generalizes the corresponding function <varname>ST_Centroid</varname> provided by PostGIS. For example, given set of objects that move together (that is, a convoy or a flock) the temporal centroid will produce a temporal point that represents at each instant the geometric center (or the center of mass) of all the moving objects.</para>
		
			<para>In addition to the above, function <varname>extent</varname> returns a bounding box that encloses a set of temporal values. Depending on the base type, the result of this function can be a <varname>period</varname>, a <varname>tbox</varname> or an <varname>stbox</varname>. This function is an &ldquo;aggregate&rdquo; function in SQL terminology since it operates on lists of data, in the same way the SUM() and AVG() functions do.</para>

			<para>In the examples that follow, we suppose the tables <varname>Department</varname> and <varname>Trip</varname> contain the two tuples introduced in <xref linkend="examples_temporal_types" />.</para>
			<itemizedlist>
				<listitem id="tcount">
					<para>Temporal count</para>
					<para><varname>tcount(ttype): {tinti, tints}</varname></para>
					<programlisting>
SELECT tcount(NoEmps) FROM Department;
-- "{[1@2012-01-01, 2@2012-02-01, 1@2012-08-01, 1@2012-10-01)}"
					</programlisting>
				</listitem>

				<listitem id="tand">
					<para>Temporal and</para>
					<para><varname>tand(tbool): tbool</varname></para>
					<programlisting>
SELECT tand(NoEmps #&gt; 6) FROM Department;
-- "{[t@2012-01-01, f@2012-04-01, f@2012-10-01)}"
					</programlisting>
				</listitem>

				<listitem id="tor">
					<para>Temporal or</para>
					<para><varname>tor(tbool): tbool</varname></para>
					<programlisting>
SELECT tor(NoEmps #&gt; 6) FROM Department;
-- "{[t@2012-01-01, f@2012-08-01, f@2012-10-01)}"
					</programlisting>
				</listitem>

				<listitem id="tmin">
					<para>Temporal minimum</para>
					<para><varname>tmin(ttype): {ttypei, ttypes}</varname></para>
					<programlisting>
SELECT tmin(NoEmps) FROM Department;
-- "{[10@2012-01-01, 4@2012-02-01, 6@2012-06-01, 6@2012-10-01)}"
					</programlisting>
				</listitem>

				<listitem id="tmax">
					<para>Temporal maximum</para>
					<para><varname>tmax(ttype): {ttypei, ttypes}</varname></para>
					<programlisting>
SELECT tmax(NoEmps) FROM Department;
-- "{[10@2012-01-01, 12@2012-04-01, 6@2012-08-01, 6@2012-10-01)}"
					</programlisting>
				</listitem>

				<listitem id="tsum">
					<para>Temporal sum</para>
					<para><varname>tsum(tnumber): {tnumi, tnums}</varname></para>
					<programlisting>
SELECT tsum(NoEmps) FROM Department;
-- "{[10@2012-01-01, 14@2012-02-01, 16@2012-04-01, 18@2012-06-01, 6@2012-08-01, 
	6@2012-10-01)}"
					</programlisting>
				</listitem>

				<listitem id="tavg">
					<para>Temporal average</para>
					<para><varname>tavg(tnumber): {tfloati, tfloats}</varname></para>
					<programlisting>
SELECT tavg(NoEmps) FROM Department;
-- "{[10@2012-01-01, 10@2012-02-01), [7@2012-02-01, 7@2012-04-01), 
	[8@2012-04-01, 8@2012-06-01), [9@2012-06-01, 9@2012-08-01), 
	[6@2012-08-01, 6@2012-10-01)"
					</programlisting>
				</listitem>

				<listitem id="wmin">
					<para>Window minimum</para>
					<para><varname>wmin(tnumber, interval): {tnumi, tnums}</varname></para>
					<programlisting>
SELECT wmin(NoEmps, interval '2 days') FROM Department;
-- "{[10@2012-01-01, 4@2012-04-01, 6@2012-06-03, 6@2012-10-03)}"
					</programlisting>
				</listitem>

				<listitem id="wmax">
					<para>Window maximum</para>
					<para><varname>wmax(tnumber, interval): {tnumi, tnums}</varname></para>
					<programlisting>
SELECT wmax(NoEmps, interval '2 days') FROM Department;
-- "{[10@2012-01-01, 12@2012-04-01, 6@2012-08-03, 6@2012-10-03)}"
					</programlisting>
				</listitem>

				<listitem id="wcount">
					<para>Window count</para>
					<para><varname>wcount(tnumber, interval): {tinti, tints}</varname></para>
					<programlisting>
SELECT wcount(NoEmps, interval '2 days') FROM Department;
-- "{[1@2012-01-01, 2@2012-02-01, 3@2012-04-01, 2@2012-04-03, 3@2012-06-01, 2@2012-06-03,
	1@2012-08-03, 1@2012-10-03)}"
					</programlisting>
				</listitem>

				<listitem id="wsum">
					<para>Window sum</para>
					<para><varname>wsum(tint, interval): {tinti, tints}</varname></para>
					<programlisting>
SELECT wsum(NoEmps, interval '2 days') FROM Department;
-- "{[10@2012-01-01, 14@2012-02-01, 26@2012-04-01, 16@2012-04-03, 22@2012-06-01, 
	18@2012-06-03, 6@2012-08-03, 6@2012-10-03)}"
					</programlisting>
				</listitem>

				<listitem id="wavg">
					<para>Window average</para>
					<para><varname>wavg(tint, interval): {tfloati, tfloats}</varname></para>
					<programlisting>
SELECT wavg(NoEmps, interval '2 days') FROM Department;
-- "{[10@2012-01-01, 10@2012-02-01), [7@2012-02-01, 7@2012-04-01),
	[8.66666666666667@2012-04-01, 8.66666666666667@2012-04-03), 
	[8@2012-04-03, 8@2012-06-01),
	[7.33333333333333@2012-06-01, 7.33333333333333@2012-06-03), 
	[9@2012-06-03, 9@2012-08-03), [6@2012-08-03, 6@2012-10-03)}"
					</programlisting>
				</listitem>

				<listitem id="tcentroid">
					<para>Temporal centroid</para>
					<para><varname>tcentroid(tgeompoint): tgeompoint</varname></para>
					<programlisting>
SELECT tcentroid(Trip) FROM Trips;
-- "{[POINT(0 0)@2012-01-01 08:00:00+00, POINT(1 0)@2012-01-01 08:05:00+00),
	[POINT(0.5 0)@2012-01-01 08:05:00+00, POINT(1.5 0.5)@2012-01-01 08:10:00+00,
	POINT(2 1.5)@2012-01-01 08:15:00+00),
	[POINT(2 2)@2012-01-01 08:15:00+00, POINT(3 3)@2012-01-01 08:20:00+00)}"
					</programlisting>
				</listitem>

				<listitem id="extent">
					<para>Bounding box extent</para>
					<para><varname>extent(temp): {period, tbox, stbox}</varname></para>
					<programlisting>
SELECT extent(noEmps) FROM Department;
-- "TBOX((4,2012-01-01 00:00:00+01),(12,2012-10-01 00:00:00+02))"
SELECT extent(Trip) FROM Trips;
-- "STBOX T((0,0,2012-01-01 08:00:00+01),(3,3,2012-01-01 08:20:00+01))"
					</programlisting>
				</listitem>

			</itemizedlist>
		</sect1>

		<sect1>
			<title>Utility Functions</title>
			<itemizedlist>
				<listitem id="mobdb_lib_version">
					<para>Version of the MobilityDB extension</para>
					<para><varname>mobdb_lib_version(): text</varname></para>
					<programlisting>
SELECT mobdb_lib_version();
-- "MobilityDB 1.0"
					</programlisting>
				</listitem>

				<listitem id="mobdb_full_version">
					<para>Versions of the MobilityDB extension and its dependencies</para>
					<para><varname>mobdb_full_version(): text</varname></para>
					<programlisting>
SELECT mobdb_full_version();
-- "MobilityDB 1.0 PostgreSQL 11.5 PostGIS 2.5"
					</programlisting>
				</listitem>
			</itemizedlist>
		</sect1>

		<sect1 id="indexing_temporal_types">
			<title>Indexing of Temporal Types</title>
			<para>GiST and SP-GiST indexes can be created for table columns of temporal types. The GiST index implements an R-tree for temporal alphanumeric types and for temporal point types. The SP-GiST index implements a Quad-tree for temporal alphanumeric types and an Oct-tree for temporal point types. Examples of index creation are as follows:
				<programlisting>
CREATE INDEX Department_NoEmps_Gist_Idx ON Department USING Gist(NoEmps);
CREATE INDEX Trips_Trip_SPGist_Idx ON Trips USING SPGist(Trip);
				</programlisting>
			</para>

			<para>The GiST and SP-GiST indexes store the bounding box for the temporal types. As explained in <xref linkend="temporal_types" />, these are
				<itemizedlist>
					<listitem>
						<para>the period <varname>period</varname> type for the <varname>tbool</varname> and <varname>ttext</varname> types,</para>
					</listitem>

					<listitem>
						<para>the <varname>tbox</varname> type for the <varname>tint</varname> and <varname>tfloat</varname> types,</para>
					</listitem>

					<listitem>
						<para>the <varname>stbox</varname> type for the <varname>tgeompoint</varname> and <varname>tgeogpoint</varname> types.</para>
					</listitem>
				</itemizedlist>
			</para>

			<para>A GiST or SP-GiST index can accelerate queries involving the following operators (see <xref linkend="operators_temporal_types" /> for more information):
				<itemizedlist>
					<listitem>
						<para><varname>&lt;&lt;</varname>, <varname>&amp;&lt;</varname>, <varname>&amp;&gt;</varname>, <varname>&gt;&gt;</varname>, which only consider the value dimension in temporal alphanumeric types,</para>
					</listitem>

					<listitem>
						<para><varname>&lt;&lt;</varname>, <varname>&amp;&lt;</varname>, <varname>&amp;&gt;</varname>, <varname>&gt;&gt;</varname>, <varname>&lt;&lt;|</varname>, <varname>&amp;&lt;|</varname>, <varname>|&amp;&gt;</varname>, <varname>|&gt;&gt;</varname>, <varname>&amp;&lt;/</varname>, <varname>&lt;&lt;/</varname>, <varname>/&gt;&gt;</varname>, and <varname>/&amp;&gt;</varname>, which only consider the spatial dimension in temporal point types,</para>
					</listitem>

					<listitem>
						<para><varname>&amp;&lt;#</varname>, <varname>&lt;&lt;#</varname>, <varname>#&gt;&gt;</varname>, <varname>#&amp;&gt;</varname>, which only consider the time dimension for all temporal types,</para>
					</listitem>

					<listitem>
						<para><varname>&amp;&amp;</varname>, <varname>@&gt;</varname>, <varname>&lt;@</varname>, and <varname>~=</varname>, which consider as many dimensions as they are shared by the indexed column and the query argument. These operators work on bounding boxes (that is, <varname>period</varname>, <varname>tbox</varname>, or <varname>stbox</varname>), not the entire values.</para>
					</listitem>
				</itemizedlist>
			</para>

			<para>In addition, a GiST index can accelerate nearest neighbor queries involving the <varname>|=|</varname> operator.</para>

			<para>For example, given the index defined above on the <varname>Department</varname> table and a query that involves a condition with the <varname>&amp;&amp;</varname> (overlaps) operator, if the right argument is a temporal float then both the value and the time dimensions are considered for filtering the tuples of the relation, while if the right argument is a float value, a float range, or a time type, then either the value or the time dimension will be used for filtering the tuples of the relation. Furthermore, a bounding box can be constructed from a value/range and/or a timestamp/period, which can be used for filtering the tuples of the relation. Examples of queries using the index on the <varname>Department</varname> table defined above are given next.
				<programlisting>
SELECT * FROM Department WHERE NoEmps &amp;&amp; 5;
SELECT * FROM Department WHERE NoEmps &amp;&amp; intrange '[1, 5)';
SELECT * FROM Department WHERE NoEmps &amp;&amp; timestamptz '2012-04-01';
SELECT * FROM Department WHERE NoEmps &amp;&amp; period '[2012-04-01, 2012-05-01)';
SELECT * FROM Department WHERE NoEmps &amp;&amp;
	tbox(intrange '[1, 5)', period '[2012-04-01, 2012-05-01)');
SELECT * FROM Department WHERE NoEmps &amp;&amp;
	tfloat '{[1@2012-01-01, 1@2012-02-01), [5@2012-04-01, 5@2012-05-01)}';
				</programlisting>
			</para>

			<para>Similarly, examples of queries using the index on the <varname>Trips</varname> table defined above are given next.
				<programlisting>
SELECT * FROM Trips WHERE Trip &amp;&amp; geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))';
SELECT * FROM Trips WHERE Trip &amp;&amp; timestamptz '2001-01-01';
SELECT * FROM Trips WHERE Trip &amp;&amp; period '[2001-01-01, 2001-01-05)';
SELECT * FROM Trips WHERE Trip &amp;&amp;
	stbox(geometry 'Polygon((0 0,0 1,1 1,1 0,0 0))', period '[2001-01-01, 2001-01-05]');
SELECT * FROM Trips WHERE Trip &amp;&amp;
	tgeompoint '{[Point(0 0)@2001-01-01, Point(1 1)@2001-01-02, Point(1 1)@2001-01-05)}';
				</programlisting>
			</para>

			<para>Finally, B-tree indexes can be created for table columns of all temporal types. For this index type, the only useful operation is equality. There is a B-tree sort ordering defined for values of temporal types, with corresponding <varname>&lt;</varname>, <varname>&lt;=</varname>, <varname>&gt;</varname>, <varname>&gt;=</varname> and operators, but the ordering is rather arbitrary and not usually useful in the real world. B-tree support for temporal types is primarily meant to allow sorting internally in queries, rather than creation of actual indexes.</para>

			<para>In order to speed up several of the functions in <xref linkend="manipulating_temporal_types" />, a bounding box comparison that make uses of the available indexes can be added in the <varname>WHERE</varname> clause of queries. For example, this would be typically the case for the functions that project the temporal types to the value/spatial and/or time dimensions. This will filter out the tuples with an index as shown in the following query.
				<programlisting>
SELECT atPeriod(T.Trip, period(2001-01-01, 2001-01-02))
FROM Trips T
-- Bouding box index filtering
WHERE T.Trip &amp;&amp; period(2001-01-01, 2001-01-02)
				</programlisting>
			</para>

			<para>In the case of temporal points, all spatial relationships with the &ldquo;ever&rdquo; semantics (see <xref linkend="topological_relationships_temporal_points" />), excepted <varname>disjoint</varname>and <varname>relate</varname>, will automatically include a bounding box comparison that will make use of any indexes that are available on the temporal points. For this reason, the first version of the relationships is typically used for filtering the tuples with the help of an index when computing the temporal relationships as shown in the following query.
				<programlisting>
SELECT tintersects(T.Trip, R.Geom)
FROM Trips T, Regions R
-- Bouding box index filtering
WHERE intersects(T.Trip, R.Geom);
				</programlisting>
			</para>
		</sect1>

		<sect1 id="statistics_temporal_types">
			<title>Statistics and Selectivity for Temporal Types</title>
			<sect2>
				<title>Statistics Collection</title>
				<para>The PostgreSQL planner relies on statistical information about the contents of tables in order to generate the most efficient execution plan for queries. These statistics include a list of some of the most common values in each column and a histogram showing the approximate data distribution in each column. For large tables, a random sample of the table contents is taken, rather than examining every row. This enables large tables to be analyzed in a small amount of time. The statistical information is gathered by the <varname>ANALYZE</varname> command and stored in the <varname>pg_statistic</varname> catalog table. Since different kinds of statistics may be appropriate for different kinds of data, the table only stores very general statistics (such as number of null values) in dedicated columns. Everything else is stored in five &ldquo;slots&rdquo;, which are couples of array columns that store the statistics for a column of an arbitrary type.</para>

				<para>The statistics collected for time types and temporal types are based on those collected by PostgreSQL for scalar types and range types. For scalar types, like <varname>float</varname>, the following statistics are collected:
					<orderedlist numeration="arabic">
						<listitem>
							<para>fraction of null values,</para>
						</listitem>
						<listitem>
							<para>average width, in bytes, of non-null values,</para>
						</listitem>
						<listitem>
							<para>number of different non-null values,</para>
						</listitem>
						<listitem>
							<para>array of most common values and array of their frequencies,</para>
						</listitem>
						<listitem>
							<para>histogram of values, where the most common values are excluded,</para>
						</listitem>
						<listitem>
							<para>correlation between physical and logical row ordering.</para>
						</listitem>
					</orderedlist>
				</para>

				<para>For range types, like <varname>tstzrange</varname>, three additional histograms are collected:
					<orderedlist continuation="continues" numeration="arabic">
						<listitem id="range_stat1">
							<para>length histogram of non-empty ranges,</para>
						</listitem>
						<listitem id="range_stat2">
							<para>histograms of lower and upper bounds.</para>
						</listitem>
					</orderedlist>
				</para>

				<para>For geometries, in addition to (1)&#x2013;(3), the following statistics are collected:
						<orderedlist continuation="continues" numeration="arabic">
							<listitem id="geom_stat1">
								<para>number of dimensions of the values, N-dimensional bounding box, number of rows in the table, number of rows in the sample, number of non-null values,</para>
							</listitem>
							<listitem id="geom_stat2">
								<para>N-dimensional histogram that divides the bounding box into a number of cells and keeps the proportion of values that intersects with each cell.</para>
							</listitem>
						</orderedlist>
				</para>

				<para>The statistics collected for the new time types <varname>timestampset</varname>, <varname>period</varname>, and <varname>periodset</varname> replicate those collected by PostgreSQL for the <varname>tstzrange</varname>. This is clear for the <varname>period</varname> type, which is equivalent to <varname>tszrange</varname>, excepted that periods cannot be empty. For the <varname>timestampset</varname> and the <varname>periodset</varname> types, a value is converted into its bounding box which is a <varname>period</varname>, then the <varname>period</varname> statistics are collected.</para>

				<para>The statistics collected for temporal types depend on their duration and their base type. In addition to statistics (1)&#x2013;(3) that are collected for all temporal types, statistics are collected for the value dimension and the time dimension independently. More precisely, the following statistics are collected for the time dimension:
					<itemizedlist>
						<listitem>
							<para>For temporal instant values, the statistics (4)&#x2013;(6) are collected for the timestamps.</para>
						</listitem>

						<listitem>
							<para>For all other durations, the statistics (7)&#x2013;(8) are collected for the (bounding box) periods.</para>
						</listitem>
					</itemizedlist>
				</para>

				<para>The following statistics are collected for the value dimension:
					<itemizedlist>
						<listitem>
							<para>For temporal types with stepwise interpolation (that is, temporal types whose base type is <varname>tbool</varname>, <varname>ttext</varname>, or <varname>tint</varname>):
								<itemizedlist>
									<listitem>
										<para>For the instant duration, the statistics (4)&#x2013;(6) are collected for the values.</para>
									</listitem>

									<listitem>
										<para>For all other durations, the statistics (7)&#x2013;(8) are collected for the values.</para>
									</listitem>
								</itemizedlist>
							</para>
						</listitem>

						<listitem>
							<para>For temporal float types (that is, <varname>tfloat</varname>):
								<itemizedlist>
									<listitem>
										<para>For instant values, the statistics (4)&#x2013;(6) are collected for the values.</para>
									</listitem>
									<listitem>
										<para>For all other durations, the statistics (7)&#x2013;(8) are collected for the (bounding) value ranges.</para>
									</listitem>
								</itemizedlist>
							</para>
						</listitem>

						<listitem>
							<para>For temporal point types (that is, <varname>tgeompoint</varname> and <varname>tgeogpoint</varname>) the statistics (9)&#x2013;(10) are collected for the points.</para>
						</listitem>
					</itemizedlist>
				</para>
			</sect2>

			<sect2>
				<title>Selectivity Estimation of Operators</title>
				<para>Boolean operators in PostgreSQL can be associated with two selectivity functions, which compute how likely a value of a given type will match a given criterion. These selectivity functions rely on the statistics collected. There are two types of selectivity functions. The restriction selectivity functions try to estimate the percentage of the rows in a table that satisfy a <varname>WHERE</varname>-clause condition of the form <varname>column OP constant</varname>. The join selectivity functions try to estimate the percentage of the rows in a table that satisfy a <varname>WHERE</varname>-clause condition of the form <varname>table1.column1 OP table2.column2</varname>.</para>

				<para>MobilityDB defines 23 classes of Boolean operators (such as <varname>=</varname>, <varname>&lt;</varname>, <varname>&amp;&amp;</varname>, <varname>&lt;&lt;</varname>, etc.), each of which can have as left or right arguments a built-in type (such as <varname>int</varname>, <varname>timestamptz</varname>, etc.) or a new type (such as <varname>period</varname>, <varname>tintseq</varname>, etc.). As a consequence, there is a very high number of operators with different arguments to be considered for the selectivity functions. The approach taken was to group these combinations into classes corresponding to the value and temporal features. The classes correspond to the type of statistics collected as explained in the previous section.</para>

				<para>Currently, only restriction selectivity functions are implemented for temporal types, while join selectivity functions give a default selectivity value depending on the operator. It is planned to implement joint selectivity functions in the future.</para>
			</sect2>
		</sect1>
	</chapter>

	<appendix id ="reference">
		<title>MobilityDB Reference</title>

		<sect1>
			<title>Functions and Operators for Time Types and Range Types</title>

			<sect2>
				<title>Constructor Functions</title>
				<itemizedlist>
					<listitem>
						<para><link linkend="period"><varname>period</varname></link>: Constructor for <varname>period</varname></para>
					</listitem>

					<listitem>
						<para><link linkend="timestampset"><varname>timestampset</varname></link>: Constructor for <varname>timestampset</varname></para>
					</listitem>

					<listitem>
						<para><link linkend="periodset"><varname>periodset</varname></link>: Constructor for <varname>periodset</varname></para>
					</listitem>
				</itemizedlist>
			</sect2>

			<sect2>
				<title>Casting</title>
				<itemizedlist>
					<listitem>
						<para><link linkend="timestamptz_cast"><varname>timestamptz::time</varname></link>: Cast a <varname>timestamptz</varname> to another time type</para>
					</listitem>
					<listitem>
						<para><link linkend="timestampset_cast"><varname>timestampset::periodset</varname></link>: Cast a <varname>timestampset</varname> to a <varname>periodset</varname></para>
					</listitem>
					<listitem>
						<para><link linkend="period_cast"><varname>period::type</varname></link>: Cast a <varname>period</varname> to another type</para>
					</listitem>
					<listitem>
						<para><link linkend="tstzrange_cast"><varname>tstzrange::period</varname></link>: Cast a <varname>tstzrange</varname> to a <varname>period</varname></para>
					</listitem>
				</itemizedlist>
			</sect2>
			<sect2>
				<title>Accessor Functions</title>

				<itemizedlist>
					<listitem>
						<para><link linkend="time_memSize"><varname>memSize</varname></link>: Get the memory size in bytes</para>
					</listitem>

					<listitem>
						<para><link linkend="lower"><varname>lower</varname></link>: Get the lower bound</para>
					</listitem>

					<listitem>
						<para><link linkend="upper"><varname>upper</varname></link>: Get the upper bound</para>
					</listitem>

					<listitem>
						<para><link linkend="lower_inc"><varname>lower_inc</varname></link>: Is the lower bound inclusive?</para>
					</listitem>

					<listitem>
						<para><link linkend="upper_inc"><varname>upper_inc</varname></link>: Is the upper bound inclusive?</para>
					</listitem>

					<listitem>
						<para><link linkend="timespan"><varname>timespan</varname></link>: Get the timespan</para>
					</listitem>

					<listitem>
						<para><link linkend="period"><varname>period</varname></link>: Get the period on which the timestamp set or period set is defined ignoring the potential time gaps</para>
					</listitem>

					<listitem>
						<para><link linkend="time_numTimestamps"><varname>numTimestamps</varname></link>: Get the number of different timestamps</para>
					</listitem>

					<listitem>
						<para><link linkend="time_startTimestamp"><varname>startTimestamp</varname></link>: Get the start timestamp</para>
					</listitem>

					<listitem>
						<para><link linkend="time_endTimestamp"><varname>endTimestamp</varname></link>: Get the end timestamp</para>
					</listitem>

					<listitem>
						<para><link linkend="time_timestampN"><varname>timestampN</varname></link>: Get the n-th different timestamp</para>
					</listitem>

					<listitem>
						<para><link linkend="time_timestamps"><varname>timestamps</varname></link>: Get the different timestamps</para>
					</listitem>

					<listitem>
						<para><link linkend="numPeriods"><varname>numPeriods</varname></link>: Get the number of periods</para>
					</listitem>

					<listitem>
						<para><link linkend="startPeriod"><varname>startPeriod</varname></link>: Get the start period</para>
					</listitem>

					<listitem>
						<para><link linkend="endPeriod"><varname>endPeriod</varname></link>: Get the end period</para>
					</listitem>

					<listitem>
						<para><link linkend="periodN"><varname>periodN</varname></link>: Get the n-th period</para>
					</listitem>

					<listitem>
						<para><link linkend="periods"><varname>periods</varname></link>: Get the periods</para>
					</listitem>
					
					<listitem>
						<para><link linkend="time_shift"><varname>shift</varname></link>: Shift the time value by an interval</para>
					</listitem>
				</itemizedlist>
			</sect2>
			
			<sect2>
				<title>Comparison Operators</title>
	
				<itemizedlist>
					<listitem>
						<para><link linkend="time_eq"><varname>=</varname></link>: Are the time values equal?</para>
					</listitem>

					<listitem>
						<para><link linkend="time_ne"><varname>&lt;&gt;</varname></link>: Are the time values different?</para>
					</listitem>

					<listitem>
						<para><link linkend="time_lt"><varname>&lt;</varname></link>: Is the first time value less than the second one?</para>
					</listitem>

					<listitem>
						<para><link linkend="time_gt"><varname>&gt;</varname></link>: Is the first time value greater than the second one?</para>
					</listitem>

					<listitem>
						<para><link linkend="time_le"><varname>&lt;=</varname></link>: Is the first time value less than or equal to the second one?</para>
					</listitem>

					<listitem>
						<para><link linkend="time_ge"><varname>&gt;=</varname></link>: Is the first time value greater than or equal to the second one?</para>
					</listitem>
				</itemizedlist>
			</sect2>
			
			<sect2>
				<title>Set Operators</title>
	
				<itemizedlist>
					<listitem>
						<para><link linkend="time_union"><varname>+</varname></link>: Union of the time values</para>
					</listitem>

					<listitem>
						<para><link linkend="time_intersection"><varname>*</varname></link>: Intersection of the time values</para>
					</listitem>

					<listitem>
						<para><link linkend="time_difference"><varname>-</varname></link>: Difference of the time values</para>
					</listitem>
				</itemizedlist>
			</sect2>
			
			<sect2>
				<title>Topological Operators</title>
	
				<itemizedlist>
					<listitem>
						<para><link linkend="time_overlaps"><varname>&amp;&amp;</varname></link>: Do the time values overlap (have points in common)?</para>
					</listitem>

					<listitem>
						<para><link linkend="time_contains"><varname>@&gt;</varname></link>: Does the first time value contain the second one?</para>
					</listitem>

					<listitem>
						<para><link linkend="time_containedby"><varname>&lt;@</varname></link>: Is the first time value contained by the second one?</para>
					</listitem>

					<listitem>
						<para><link linkend="time_adjacent"><varname>-|-</varname></link>: Is the first time value adjacent to the second one?</para>
					</listitem>
					
					<listitem>
						<para><link linkend="range_left"><varname>&lt;&lt;</varname></link>: Is the first numeric or range value scritly left of the second one?</para>
					</listitem>

					<listitem>
						<para><link linkend="range_right"><varname>&gt;&gt;</varname></link>: Is the first numeric or range value strictly right of the second one?</para>
					</listitem>

					<listitem>
						<para><link linkend="range_overleft"><varname>&amp;&lt;</varname></link>: Is the first numeric or range value not to the right of the second one?</para>
					</listitem>

					<listitem>
						<para><link linkend="range_overright"><varname>&amp;&gt;</varname></link>: Is the first numeric or range value not to the left of the second one?</para>
					</listitem>

					<listitem>
						<para><link linkend="range_adjacent"><varname>-|-</varname></link>: Is the first numeric or range value adjacent to the second one?</para>
					</listitem>
					
					<listitem>
						<para><link linkend="time_before"><varname>&lt;&lt;#</varname></link>: Is the first time value scritly before the second one?</para>
					</listitem>

					<listitem>
						<para><link linkend="time_after"><varname>#&gt;&gt;</varname></link>: Is the first time value strictly after the second one?</para>
					</listitem>

					<listitem>
						<para><link linkend="time_overbefore"><varname>&amp;&lt;#</varname></link>: Is the first time value not after the second one?</para>
					</listitem>

					<listitem>
						<para><link linkend="time_overafter"><varname>#&amp;&gt;</varname></link>: Is the first time value not before the second one?</para>
					</listitem>
				</itemizedlist>
			</sect2>
		</sect1>

		<sect1>
			<title>Functions and Operators for Box Types</title>

			<sect2>
				<title>Constructor Functions</title>
				<itemizedlist>
					<listitem>
						<para><link linkend="tbox"><varname>tbox</varname></link>: Constructor for <varname>tbox</varname></para>
					</listitem>

					<listitem>
						<para><link linkend="stbox"><varname>stbox, stboxt</varname></link>: Constructor for <varname>stbox</varname></para>
					</listitem>
				</itemizedlist>
			</sect2>

			<sect2>
				<title>Casting</title>
		
				<itemizedlist>
					<listitem>
						<para><link linkend="tbox_cast_to"><varname>tbox::type</varname></link>: Cast a <varname>tbox</varname> to another type</para>
					</listitem>

					<listitem>
						<para><link linkend="tbox_cast_from"><varname>type::tbox</varname></link>: Cast another type to a <varname>tbox</varname></para>
					</listitem>

					<listitem>
						<para><link linkend="stbox_cast_to"><varname>stbox::type</varname></link>: Cast an <varname>stbox</varname> to anoter type</para>
					</listitem>

					<listitem>
						<para><link linkend="stbox_cast_from"><varname>type::stbox</varname></link>: Cast another type to an <varname>stbox</varname></para>
					</listitem>
				</itemizedlist>
			</sect2>

			<sect2>
				<title>Accessor Functions</title>

				<itemizedlist>
					<listitem>
						<para><link linkend="Xmin"><varname>Xmin</varname></link>: Get the minimum X value</para>
					</listitem>

					<listitem>
						<para><link linkend="Xmax"><varname>Xmax</varname></link>: Get the maximum X value</para>
					</listitem>

					<listitem>
						<para><link linkend="Ymin"><varname>Ymin</varname></link>: Get the minimum Y value</para>
					</listitem>

					<listitem>
						<para><link linkend="Ymax"><varname>Ymax</varname></link>: Get the maximum Y value</para>
					</listitem>

					<listitem>
						<para><link linkend="Zmin"><varname>Zmin</varname></link>: Get the minimum Z value</para>
					</listitem>

					<listitem>
						<para><link linkend="Zmax"><varname>Zmax</varname></link>: Get the maximum Z value</para>
					</listitem>

					<listitem>
						<para><link linkend="Tmin"><varname>Tmin</varname></link>: Get the minimum timestamp</para>
					</listitem>

					<listitem>
						<para><link linkend="Tmax"><varname>Tmax</varname></link>: Get the maximum timestamp</para>
						<para></para>
					</listitem>
				</itemizedlist>
			</sect2>

			<sect2>
				<title>Modification Functions</title>
				<itemizedlist>
					<listitem>
						<para><link linkend="expandValue"><varname>expandValue</varname></link>: Expand the numeric value dimension of the bounding box by a float value</para>
						</listitem>

					<listitem>
						<para><link linkend="expandSpatial"><varname>expandSpatial</varname></link>: Expand the spatial value dimension of the bounding box by a float value</para>
						</listitem>

					<listitem>
						<para><link linkend="expandTemporal"><varname>expandTemporal</varname></link>: Expand the temporal dimension of the bounding box by a time interval</para>
					</listitem>

					<listitem>
						<para><link linkend="box_setPrecision"><varname>setPrecision</varname></link>: Round the value or the coordinates of the bounding box to a number of decimal places</para>
					</listitem>

				</itemizedlist>
			</sect2>

			<sect2>
				<title>Spatial Reference System Functions</title>

				<itemizedlist>
					<listitem>
						<para><link linkend="stbox_SRID"><varname>SRID</varname></link>: Get the spatial reference identifier</para>
					</listitem>

					<listitem>
						<para><link linkend="stbox_setSRID"><varname>setSRID</varname></link>: Set the spatial reference identifier</para>
						</listitem>

					<listitem>
						<para><link linkend="stbox_transform"><varname>transform</varname></link>: Transform to a different spatial reference</para>
					</listitem>
				</itemizedlist>
			</sect2>

			<sect2>
				<title>Comparison Operators</title>
				<itemizedlist>
					<listitem>
					<para><link linkend="box_eq"><varname>=</varname></link>: Are the bounding boxes equal?</para>
					</listitem>

					<listitem>
						<para><link linkend="box_ne"><varname>&lt;&gt;</varname></link>: Are the bounding boxes different?</para>
					</listitem>

					<listitem>
						<para><link linkend="box_lt"><varname>&lt;</varname></link>: Is the first bouding box less than the second one?</para>
					</listitem>

					<listitem>
						<para><link linkend="box_gt"><varname>&gt;</varname></link>: Is the first bouding box greater than the second one?</para>
					</listitem>

					<listitem>
						<para><link linkend="box_le"><varname>&lt;=</varname></link>: Is the first bouding box less than or equal to the second one?</para>
					</listitem>

					<listitem>
						<para><link linkend="box_ge"><varname>&gt;=</varname></link>: Is the first bouding box greater than or equal to the second one?</para>
					</listitem>
				</itemizedlist>
			</sect2>

			<sect2>
				<title>Set Operators</title>
				<itemizedlist>
					<listitem>
						<para><link linkend="box_union"><varname>+</varname></link>: Union of the bounding boxes</para>
					</listitem>

					<listitem>
						<para><link linkend="box_intersection"><varname>*</varname></link>: Intersection of the bounding boxes</para>
					</listitem>
				</itemizedlist>
			</sect2>

			<sect2>
				<title>Topological Operators</title>
				<itemizedlist>
					<listitem>
						<para><link linkend="tbox_left"><varname>&lt;&lt;</varname></link>: Are the X values of the first bounding box strictly less than those of the second one?</para>
					</listitem>

					<listitem>
						<para><link linkend="tbox_right"><varname>&gt;&gt;</varname></link>: Are the X values of the first bounding box strictly greater than those of the second one?</para>
					</listitem>

					<listitem>
						<para><link linkend="tbox_overleft"><varname>&amp;&lt;</varname></link>: Are the X values of the first bounding box not greater than those of the second one?</para>
					</listitem>

					<listitem>
						<para><link linkend="tbox_overright"><varname>&amp;&gt;</varname></link>: Are the X values of the first bounding box not less than those of the second one?</para>
					</listitem>

					<listitem>
						<para><link linkend="stbox_left"><varname>&lt;&lt;</varname></link>: Are the X values of the first bounding box strictly to the left of those of the second one?</para>
					</listitem>

					<listitem>
						<para><link linkend="stbox_right"><varname>&gt;&gt;</varname></link>: Are the X values of the first bounding box strictly to the right of those of the second one?</para>
					</listitem>

					<listitem>
						<para><link linkend="stbox_overleft"><varname>&amp;&lt;</varname></link>: Are the X values of the first bounding box not to the right of those of the second one?</para>
					</listitem>

					<listitem>
						<para><link linkend="stbox_overright"><varname>&amp;&gt;</varname></link>: Are the X values of the first bounding box not to the left of those of the second one?</para>
					</listitem>

					<listitem>
						<para><link linkend="stbox_below"><varname>&lt;&lt;|</varname></link>: Are the Y values of the first bounding box strictly below of those of the second one?</para>
					</listitem>

					<listitem>
						<para><link linkend="stbox_above"><varname>|&gt;&gt;</varname></link>: Are the Y values of the first bounding box strictly above of those of the second one?</para>
					</listitem>

					<listitem>
						<para><link linkend="stbox_overbelow"><varname>&amp;&lt;|</varname></link>: Are the Y values of the first bounding box not above of those of the second one?</para>
					</listitem>

					<listitem>
						<para><link linkend="stbox_overabove"><varname>|&amp;&gt;</varname></link>: Are the Y values of the first bounding box not below of those of the second one?</para>
					</listitem>

					<listitem>
						<para><link linkend="stbox_front"><varname>&lt;&lt;/</varname></link>: Are the Z values of the first bounding box strictly in front of those of the second one?</para>
					</listitem>

					<listitem>
						<para><link linkend="stbox_back"><varname>/&gt;&gt;</varname></link>: Are the Z values of the first bounding box strictly back of those of the second one?</para>
					</listitem>

					<listitem>
						<para><link linkend="stbox_overfront"><varname>&amp;&lt;/</varname></link>: Are the Z values of the first bounding box not back of those of the second one?</para>
					</listitem>

					<listitem>
						<para><link linkend="stbox_overback"><varname>/&amp;&gt;</varname></link>: Are the Z values of the first bounding box not in front of those of the second one?</para>
					</listitem>

					<listitem>
						<para><link linkend="box_before"><varname>&lt;&lt;#</varname></link>: Are the T values of the first bounding box strictly before those of the second one?</para>
					</listitem>

					<listitem>
						<para><link linkend="box_after"><varname>#&gt;&gt;</varname></link>: Are the T values of the first bounding box strictly after those of the second one?</para>
					</listitem>

					<listitem>
						<para><link linkend="box_overbefore"><varname>&amp;&lt;#</varname></link>: Are the T values of the first bounding box not after those of the second one?</para>
					</listitem>

					<listitem>
						<para><link linkend="box_overafter"><varname>#&amp;&gt;</varname></link>: Are the T values of the first bounding box not before those of the second one?</para>
					</listitem>

					<listitem>
						<para><link linkend="box_overlap"><varname>&amp;&amp;</varname></link>: Do the bounding boxes overlap?</para>
					</listitem>

					<listitem>
						<para><link linkend="box_contains"><varname>@&gt;</varname></link>: Does the first bounding box contain the second one?</para>
					</listitem>

					<listitem>
						<para><link linkend="box_containedby"><varname>&lt;@</varname></link>: Is the first bounding box contained in the second one?</para>
					</listitem>

					<listitem>
						<para><link linkend="box_same"><varname>~=</varname></link>: Are the bounding boxes equal in their common dimensions?</para>
					</listitem>

					<listitem>
						<para><link linkend="box_adjacent"><varname>-|-</varname></link>: Are the bounding boxes adjacent?</para>
					</listitem>
				</itemizedlist>
			</sect2>
		</sect1>
			
		<sect1>
			<title>Functions and Operators for Temporal Types</title>
							
			<sect2>
				<title>Constructor Functions</title>
				<itemizedlist>
					<listitem>
						<para><link linkend="ttypeinst"><varname>ttypeinst</varname></link>: Constructor for temporal types of instant duration</para>
					</listitem>

					<listitem>
						<para><link linkend="ttypei"><varname>ttypei</varname></link>: Constructor for temporal types of instant set duration</para>
					</listitem>

					<listitem>
						<para><link linkend="ttypeseq"><varname>ttypeseq</varname></link>: Constructor for temporal types of sequence duration</para>
					</listitem>

					<listitem>
						<para><link linkend="ttypes"><varname>ttypes</varname></link>: Constructor for temporal types of sequence set duration</para>
					</listitem>
				</itemizedlist>
			</sect2>

			<sect2>
				<title>Casting</title>

				<itemizedlist>
					<listitem>
						<para><link linkend="tint_tfloat"><varname>tint::tfloat</varname></link>: Cast a temporal integer to a temporal float</para>
					</listitem>

					<listitem>
						<para><link linkend="tfloat_tint"><varname>tfloat::tint</varname></link>: Cast a temporal float to a temporal integer</para>
					</listitem>

					<listitem>
						<para><link linkend="tgeompoint_tgeogpoint"><varname>tgeompoint::tgeogpoint</varname></link>: Cast a temporal geometry point to a temporal geography point</para>
					</listitem>

					<listitem>
						<para><link linkend="tgeogpoint_tgeompoint"><varname>tgeogpoint::tgeompoint</varname></link>: Cast a temporal geography point to a temporal geometry point</para>
					</listitem>

					<listitem>
						<para><link linkend="tgeompoint_geometry"><varname>tgeompoint::geometry, tgeogpoint::geography</varname></link>: Cast a temporal point to a PostGIS trajectory</para>
					</listitem>

					<listitem>
						<para><link linkend="geometry_tgeompoint"><varname>geometry::tgeompoint, geography::tgeogpoint</varname></link>: Cast a PostGIS trajectory to a temporal point</para>
					</listitem>
				</itemizedlist>
			</sect2>

			<sect2>
				<title>Transformation Functions</title>

				<itemizedlist>
					<listitem>
					<para><link linkend="ttype_transform"><varname>ttypeinst, ttypei, ttypeseq, ttypes</varname></link>: Transform a temporal value to another duration</para>
					</listitem>

					<listitem>
						<para><link linkend="toLinear"><varname>toLinear</varname></link>: Transform a temporal value with continuous base type from stepwise to linear interpolation</para>
					</listitem>

					<listitem>
					<para><link linkend="appendInstant"><varname>appendInstant</varname></link>: Append a temporal instant to a temporal value</para>
					</listitem>

					<listitem>
					<para><link linkend="merge"><varname>merge</varname></link>: Merge temporal values</para>
					</listitem>

				</itemizedlist>
			</sect2>

			<sect2>
				<title>Accessor Functions</title>
				<itemizedlist>
					<listitem>
					<para><link linkend="ttype_memSize"><varname>memSize</varname></link>: Get the memory size in bytes</para>
					</listitem>

					<listitem>
						<para><link linkend="duration"><varname>duration</varname></link>: Get the duration</para>
					</listitem>

					<listitem>
						<para><link linkend="interpolation"><varname>interpolation</varname></link>: Get the interpolation</para>
					</listitem>

					<listitem>
						<para><link linkend="getValue"><varname>getValue</varname></link>: Get the value</para>
					</listitem>

					<listitem>
						<para><link linkend="getValues"><varname>getValues</varname></link>: Get the values</para>
					</listitem>

					<listitem>
						<para><link linkend="startValue"><varname>startValue</varname></link>: Get the start value</para>
					</listitem>

					<listitem>
						<para><link linkend="endValue"><varname>endValue</varname></link>: Get the end value</para>
					</listitem>

					<listitem>
						<para><link linkend="minValue"><varname>minValue</varname></link>: Get the minimum value</para>
					</listitem>

					<listitem>
						<para><link linkend="maxValue"><varname>maxValue</varname></link>: Get the maximum value</para>
					</listitem>

					<listitem>
						<para><link linkend="valueRange"><varname>valueRange</varname></link>: Get the value range</para>
					</listitem>

					<listitem>
						<para><link linkend="valueAtTimestamp"><varname>valueAtTimestamp</varname></link>: Get the value at a timestamp</para>
					</listitem>

					<listitem>
						<para><link linkend="getTimestamp"><varname>getTimestamp</varname></link>: Get the timestamp</para>
					</listitem>

					<listitem>
						<para><link linkend="getTime"><varname>getTime</varname></link>: Get the time</para>
					</listitem>

					<listitem>
						<para><link linkend="timespan"><varname>timespan</varname></link>: Get the timespan</para>
					</listitem>

					<listitem>
						<para><link linkend="ttype_period"><varname>period</varname></link>: Get the period on which the temporal value is defined ignoring the potential time gaps</para>
					</listitem>

					<listitem>
						<para><link linkend="numInstants"><varname>numInstants</varname></link>: Get the number of different instants</para>
					</listitem>

					<listitem>
						<para><link linkend="startInstant"><varname>startInstant</varname></link>: Get the start instant</para>
					</listitem>

					<listitem>
						<para><link linkend="endInstant"><varname>endInstant</varname></link>: Get the end instant</para>
					</listitem>

					<listitem>
						<para><link linkend="instantN"><varname>instantN</varname></link>: Get the n-th different instant</para>
					</listitem>

					<listitem>
						<para><link linkend="instants"><varname>instants</varname></link>: Get the different instants</para>
					</listitem>

					<listitem>
						<para><link linkend="ttype_numTimestamps"><varname>numTimestamps</varname></link>: Get the number of different timestamps</para>
					</listitem>

					<listitem>
						<para><link linkend="ttype_startTimestamp"><varname>startTimestamp</varname></link>: Get the start timestamp</para>
					</listitem>

					<listitem>
						<para><link linkend="ttype_endTimestamp"><varname>endTimestamp</varname></link>: Get the end timestamp</para>
					</listitem>

					<listitem>
						<para><link linkend="ttype_timestampN"><varname>timestampN</varname></link>: Get the n-th different timestamp</para>
					</listitem>

					<listitem>
						<para><link linkend="ttype_timestamps"><varname>timestamps</varname></link>: Get the different timestamps</para>
					</listitem>

					<listitem>
						<para><link linkend="numSequences"><varname>numSequences</varname></link>: Get the number of sequences</para>
					</listitem>

					<listitem>
						<para><link linkend="startSequence"><varname>startSequence</varname></link>: Get the start sequence</para>
					</listitem>

					<listitem>
						<para><link linkend="endSequence"><varname>endSequence</varname></link>: Get the end sequence</para>
					</listitem>

					<listitem>
						<para><link linkend="sequenceN"><varname>sequenceN</varname></link>: Get the n-th sequence</para>
					</listitem>

					<listitem>
						<para><link linkend="sequences"><varname>sequences</varname></link>: Get the sequences</para>
					</listitem>

					<listitem>
						<para><link linkend="ttype_shift"><varname>shift</varname></link>: Shift the temporal value by an interval</para>
					</listitem>

					<listitem>
						<para><link linkend="intersectsTimestamp"><varname>intersectsTimestamp</varname></link>: Does the temporal value intersect the timestamp?</para>
					</listitem>

					<listitem>
						<para><link linkend="intersectsTimestampSet"><varname>intersectsTimestampSet</varname></link>: Does the temporal value intersect the timestamp set?</para>
					</listitem>

					<listitem>
						<para><link linkend="intersectsPeriod"><varname>intersectsPeriod</varname></link>: Does the temporal value intersect the period?</para>
					</listitem>

					<listitem>
						<para><link linkend="intersectsPeriodSet"><varname>intersectsPeriodSet</varname></link>: Does the temporal value intersect the period set?</para>
					</listitem>

					<listitem>
						<para><link linkend="twAvg"><varname>twAvg</varname></link>: Get the time-weighted average</para>
					</listitem>
				</itemizedlist>
			</sect2>

			<sect2>
				<title>Spatial Functions</title>

				<itemizedlist>
					<listitem>
						<para><link linkend="asText"><varname>asText</varname></link>: Get the Well-Known Text (WKT) representation</para>
					</listitem>

					<listitem>
						<para><link linkend="asEWKT"><varname>asEWKT</varname></link>: Get the Extended Well-Known Text (EWKT) representation</para>
					</listitem>

					<listitem>
						<para><link linkend="asMFJSON"><varname>asMFJSON</varname></link>: Get the Moving Features JSON representation</para>
					</listitem>

					<listitem>
						<para><link linkend="asBinary"><varname>asBinary</varname></link>: Get the Well-Known Binary (WKB) representation</para>
					</listitem>

					<listitem>
						<para><link linkend="asEWKB"><varname>asEWKB</varname></link>: Get the Extended Well-Known Binary (EWKB) representation</para>
					</listitem>

					<listitem>
						<para><link linkend="asHexEWKB"><varname>asHexEWKB</varname></link>: Get the Hexadecimal Extended Well-Known Binary (EWKB) representation as text </para>
					</listitem>

					<listitem>
						<para><link linkend="fromMFJSON"><varname>fromMFJSON</varname></link>: Input a temporal point from a Moving Features JSON representation</para>
					</listitem>

					<listitem>
						<para><link linkend="fromEWKB"><varname>fromEWKB</varname></link>: Input a temporal point from an Extended Well-Known Binary (EWKB) representation</para>
					</listitem>

					<listitem>
						<para><link linkend="tpoint_SRID"><varname>SRID</varname></link>: Get the spatial reference identifier</para>
					</listitem>

					<listitem>
						<para><link linkend="tpoint_setSRID"><varname>setSRID</varname></link>: Set the spatial reference identifier</para>
						</listitem>

					<listitem>
						<para><link linkend="tpoint_transform"><varname>transform</varname></link>: Transform to a different spatial reference</para>
					</listitem>

					<listitem>
						<para><link linkend="tpoint_setPrecision"><varname>setPrecision</varname></link>: Round the coordinate values to a number of decimal places</para>
					</listitem>

					<listitem>
						<para><link linkend="length"><varname>length</varname></link>: Get the length traversed by the temporal point</para>
					</listitem>

					<listitem>
						<para><link linkend="cumulativeLength"><varname>cumulativeLength</varname></link>: Get the cumulative length traversed by the temporal point</para>
					</listitem>

					<listitem>
						<para><link linkend="speed"><varname>speed</varname></link>: Get the speed of the temporal point in units per second</para>
					</listitem>

					<listitem>
						<para><link linkend="twCentroid"><varname>twCentroid</varname></link>: Get the time-weighted centroid</para>
					</listitem>

					<listitem>
						<para><link linkend="azimuth"><varname>azimuth</varname></link>: Get the temporal azimuth</para>
					</listitem>

					<listitem>
						<para><link linkend="nearestApproachInstant"><varname>nearestApproachInstant</varname></link>: Get the instant of the first temporal point at which the two arguments are at the nearest distance</para>
					</listitem>

					<listitem>
						<para><link linkend="nearestApproachDistance"><varname>nearestApproachDistance</varname></link>: Get the smallest distance ever</para>
					</listitem>

					<listitem>
						<para><link linkend="shortestLine"><varname>shortestLine</varname></link>: Get the line connecting the nearest approach point</para>
					</listitem>

					<listitem>
						<para><link linkend="simplify"><varname>simplify</varname></link>: Simplify a temporal point using a generalization of the Douglas-Peucker algorithm</para>
					</listitem>
					
					<listitem>
						<para><link linkend="geoMeasure"><varname>geoMeasure</varname></link>: Construct a geometry/geography with M measure from a temporal point and a temporal float</para>
					</listitem>					
				</itemizedlist>
			</sect2>

			<sect2>
				<title>Restriction Functions</title>

				<itemizedlist>
					<listitem>
						<para><link linkend="atValue"><varname>atValue</varname></link>: Restrict to a value</para>
					</listitem>

					<listitem>
						<para><link linkend="atValues"><varname>atValues</varname></link>: Restrict to an array of values</para>
					</listitem>

					<listitem>
						<para><link linkend="atRange"><varname>atRange</varname></link>: Restrict to a range</para>
					</listitem>

					<listitem>
						<para><link linkend="atRanges"><varname>atRanges</varname></link>: Restrict to an array of ranges</para>
					</listitem>

					<listitem>
						<para><link linkend="atMin"><varname>atMin</varname></link>: Restrict to the minimum value</para>
					</listitem>

					<listitem>
						<para><link linkend="atMax"><varname>atMax</varname></link>: Restrict to the maximum value</para>
					</listitem>

					<listitem>
						<para><link linkend="atGeometry"><varname>atGeometry</varname></link>: Restrict to a geometry</para>
					</listitem>

					<listitem>
						<para><link linkend="atTimestamp"><varname>atTimestamp</varname></link>: Restrict to a timestamp</para>
					</listitem>

					<listitem>
						<para><link linkend="atTimestampSet"><varname>atTimestampSet</varname></link>: Restrict to a timestamp set</para>
					</listitem>

					<listitem>
						<para><link linkend="atPeriod"><varname>atPeriod</varname></link>: Restrict to a period</para>
					</listitem>

					<listitem>
						<para><link linkend="atPeriodSet"><varname>atPeriodSet</varname></link>: Restrict to a period set</para>
					</listitem>

					<listitem>
						<para><link linkend="atTbox"><varname>atTbox</varname></link>: Restrict to a <varname>tbox</varname></para>
					</listitem>

					<listitem>
						<para><link linkend="atStbox"><varname>atStbox</varname></link>: Restrict to an <varname>stbox</varname></para>
					</listitem>
				</itemizedlist>
			</sect2>

			<sect2>
				<title>Difference Functions</title>

				<itemizedlist>
					<listitem>
					<para><link linkend="minusValue"><varname>minusValue</varname></link>: Difference with a value</para>
					</listitem>

					<listitem>
						<para><link linkend="minusValues"><varname>minusValues</varname></link>: Difference with an array of values</para>
					</listitem>

					<listitem>
						<para><link linkend="minusRange"><varname>minusRange</varname></link>: Difference with a range</para>
					</listitem>

					<listitem>
						<para><link linkend="minusRanges"><varname>minusRanges</varname></link>: Difference with an array of ranges</para>
					</listitem>

					<listitem>
						<para><link linkend="minusMin"><varname>minusMin</varname></link>: Difference with the minimum value</para>
					</listitem>

					<listitem>
						<para><link linkend="minusMax"><varname>minusMax</varname></link>: Difference with the maximum value</para>
					</listitem>

					<listitem>
						<para><link linkend="minusGeometry"><varname>minusGeometry</varname></link>: Difference with a geometry</para>
					</listitem>

					<listitem>
						<para><link linkend="minusTimestamp"><varname>minusTimestamp</varname></link>: Difference with a timestamp</para>
					</listitem>

					<listitem>
						<para><link linkend="minusTimestampSet"><varname>minusTimestampSet</varname></link>: Difference with a timestamp set</para>
					</listitem>

					<listitem>
						<para><link linkend="minusPeriod"><varname>minusPeriod</varname></link>: Difference with period</para>
					</listitem>

					<listitem>
						<para><link linkend="minusPeriodSet"><varname>minusPeriodSet</varname></link>: Difference with a period set</para>
					</listitem>

					<listitem>
						<para><link linkend="minusTbox"><varname>minusTbox</varname></link>: Difference with a <varname>tbox</varname></para>
					</listitem>

					<listitem>
						<para><link linkend="minusStbox"><varname>minusStbox</varname></link>: Difference with an <varname>stbox</varname></para>
					</listitem>
				</itemizedlist>
			</sect2>

			<sect2>
				<title>Comparison Operators</title>

				<itemizedlist>
					<listitem>
					<para><link linkend="ttype_eq"><varname>=</varname></link>: Are the temporal values equal?</para>
					</listitem>

					<listitem>
						<para><link linkend="ttype_ne"><varname>&lt;&gt;</varname></link>: Are the temporal values different?</para>
					</listitem>

					<listitem>
						<para><link linkend="ttype_lt"><varname>&lt;</varname></link>: Is the first temporal value less than the second one?</para>
					</listitem>

					<listitem>
						<para><link linkend="ttype_gt"><varname>&gt;</varname></link>: Is the first temporal value greater than the second one?</para>
					</listitem>

					<listitem>
						<para><link linkend="ttype_le"><varname>&lt;=</varname></link>: Is the first temporal value less than or equal to the second one?</para>
					</listitem>

					<listitem>
						<para><link linkend="ttype_ge"><varname>&gt;=</varname></link>: Is the first temporal value greater than or equal to the second one?</para>
					</listitem>
				</itemizedlist>
			</sect2>

			<sect2>
				<title>Ever and Always Comparison Operators</title>

				<itemizedlist>
					<listitem>
						<para><link linkend="ttype_eveq"><varname>?=</varname></link>: Is the temporal value ever equal to the value?</para>
					</listitem>

					<listitem>
						<para><link linkend="ttype_evne"><varname>?&lt;&gt;</varname></link>: Is the temporal value ever different from the value?</para>
					</listitem>

					<listitem>
						<para><link linkend="ttype_evlt"><varname>?&lt;</varname></link>: Is the temporal value ever less than the value?</para>
					</listitem>

					<listitem>
						<para><link linkend="ttype_evgt"><varname>?&gt;</varname></link>: Is the temporal value ever greater than the value?</para>
					</listitem>

					<listitem>
						<para><link linkend="ttype_evle"><varname>?&lt;=</varname></link>: Is the temporal value ever less than or equal to the value?</para>
					</listitem>

					<listitem>
						<para><link linkend="ttype_evge"><varname>?&gt;=</varname></link>: Is the temporal value ever greater than or equal to the value?</para>
					</listitem>

					<listitem>
						<para><link linkend="ttype_aleq"><varname>%=</varname></link>: Is the temporal value always equal to the value?</para>
					</listitem>

					<listitem>
						<para><link linkend="ttype_alne"><varname>%&lt;&gt;</varname></link>: Is the temporal value always different to the value?</para>
					</listitem>

					<listitem>
						<para><link linkend="ttype_allt"><varname>%&lt;</varname></link>: Is the temporal value always less than the value?</para>
					</listitem>

					<listitem>
						<para><link linkend="ttype_algt"><varname>%&gt;</varname></link>: Is the temporal value always greater than the value?</para>
					</listitem>

					<listitem>
						<para><link linkend="ttype_alle"><varname>%&lt;=</varname></link>: Is the temporal value always less than or equal to the value?</para>
					</listitem>

					<listitem>
						<para><link linkend="ttype_alge"><varname>%&gt;=</varname></link>: Is the temporal value always greater than or equal to the value?</para>
					</listitem>
				</itemizedlist>
			</sect2>

			<sect2>
				<title>Temporal Comparison Operators</title>

				<itemizedlist>
					<listitem>
						<para><link linkend="ttype_teq"><varname>#=</varname></link>: Temporal equal</para>
					</listitem>

					<listitem>
						<para><link linkend="ttype_tne"><varname>#&lt;&gt;</varname></link>: Temporal different</para>
					</listitem>

					<listitem>
						<para><link linkend="ttype_tlt"><varname>#&lt;</varname></link>: Temporal less than</para>
					</listitem>

					<listitem>
						<para><link linkend="ttype_tgt"><varname>#&gt;</varname></link>: Temporal greater than</para>
					</listitem>

					<listitem>
						<para><link linkend="ttype_tle"><varname>#&lt;=</varname></link>: Temporal less than or equal to</para>
					</listitem>

					<listitem>
						<para><link linkend="ttype_tge"><varname>#&gt;=</varname></link>: Temporal greater than or equal to</para>
					</listitem>
				</itemizedlist>
			</sect2>
				
			<sect2>
				<title>Mathematical Functions and Operators</title>

				<itemizedlist>
					<listitem>
						<para><link linkend="tnumber_add"><varname>+</varname></link>: Temporal addition</para>
					</listitem>

					<listitem>
						<para><link linkend="tnumber_sub"><varname>-</varname></link>: Temporal subtraction</para>
					</listitem>

					<listitem>
						<para><link linkend="tnumber_mult"><varname>*</varname></link>: Temporal multiplication</para>
					</listitem>

					<listitem>
						<para><link linkend="tnumber_div"><varname>/</varname></link>: Temporal division</para>
					</listitem>

					<listitem>
						<para><link linkend="round"><varname>round</varname></link>: Round to n decimal places</para>
					</listitem>

					<listitem>
						<para><link linkend="degrees"><varname>degrees</varname></link>: Convert from radians to degrees</para>
					</listitem>
				</itemizedlist>
			</sect2>

			<sect2>
				<title>Boolean Operators</title>
				<itemizedlist>
					<listitem>
						<para><link linkend="tbool_and"><varname>&amp;</varname></link>: Temporal and</para>
					</listitem>

					<listitem>
						<para><link linkend="tbool_or"><varname>|</varname></link>: Temporal or</para>
					</listitem>

					<listitem>
						<para><link linkend="tbool_not"><varname>~</varname></link>: Temporal not</para>
					</listitem>
				</itemizedlist>
			</sect2>

			<sect2>
				<title>Text Functions and Operators</title>

				<itemizedlist>
					<listitem>
						<para><link linkend="ttext_concat"><varname>||</varname></link>: Temporal text concatenation</para>
					</listitem>

					<listitem>
						<para><link linkend="ttext_upper"><varname>upper</varname></link>: Transform to uppercase</para>
					</listitem>

					<listitem>
						<para><link linkend="ttext_lower"><varname>lower</varname></link>: Transform to lowercase</para>
					</listitem>
				</itemizedlist>
			</sect2>

			<sect2>
				<title>Distance Operators</title>
			
				<itemizedlist>
					<listitem>
						<para><link linkend="smallest_distance"><varname>|=|</varname></link>: Get the smallest distance ever</para>
					</listitem>

					<listitem>
						<para><link linkend="distance"><varname>&lt;-&gt;</varname></link>: Get the temporal distance</para>
					</listitem>
				</itemizedlist>
			</sect2>

			<sect2>
				<title>Spatial Relationships for Temporal Points</title>

				<sect3>
					<title>Possible Spatial Relationships</title>
					<itemizedlist>
						<listitem>
							<para><link linkend="contains"><varname>contains</varname></link>: May contain</para>
						</listitem>

						<listitem>
							<para><link linkend="containsproperly"><varname>containsproperly</varname></link>: May contain properly</para>
						</listitem>

						<listitem>
							<para><link linkend="covers"><varname>covers</varname></link>: May cover</para>
						</listitem>

						<listitem>
							<para><link linkend="coveredby"><varname>coveredby</varname></link>: May be covered by</para>
						</listitem>

						<listitem>
							<para><link linkend="crosses"><varname>crosses</varname></link>: May cross</para>
						</listitem>

						<listitem>
							<para><link linkend="disjoint"><varname>disjoint</varname></link>: May be disjoint</para>
						</listitem>

						<listitem>
							<para><link linkend="equals"><varname>equals</varname></link>: May be equal</para>
						</listitem>

						<listitem>
							<para><link linkend="intersects"><varname>intersects</varname></link>: May intersect</para>
						</listitem>

						<listitem>
							<para><link linkend="overlaps"><varname>overlaps</varname></link>: May overlap</para>
						</listitem>

						<listitem>
							<para><link linkend="touches"><varname>touches</varname></link>: May touch</para>
						</listitem>

						<listitem>
							<para><link linkend="within"><varname>within</varname></link>: May be within</para>
						</listitem>

						<listitem>
							<para><link linkend="dwithin"><varname>dwithin</varname></link>: May be at distance within</para>
						</listitem>

						<listitem>
							<para><link linkend="relate"><varname>relate</varname></link>: May relate</para>
						</listitem>
					</itemizedlist>
				</sect3>

				<sect3>
					<title>Temporal Spatial Relationships</title>
					<itemizedlist>
						<listitem>
							<para><link linkend="tcontains"><varname>tcontains</varname></link>: Temporal contains</para>
						</listitem>

						<listitem>
							<para><link linkend="tcovers"><varname>tcovers</varname></link>: Temporal covers</para>
						</listitem>

						<listitem>
							<para><link linkend="tcoveredby"><varname>tcoveredby</varname></link>: Temporal covered by</para>
						</listitem>

						<listitem>
							<para><link linkend="tdisjoint"><varname>tdisjoint</varname></link>: Temporal disjoint</para>
						</listitem>

						<listitem>
							<para><link linkend="tequals"><varname>tequals</varname></link>: Temporal equals</para>
						</listitem>

						<listitem>
							<para><link linkend="tintersects"><varname>tintersects</varname></link>: Temporal intersects</para>
						</listitem>

						<listitem>
							<para><link linkend="ttouches"><varname>ttouches</varname></link>: Temporal touches</para>
						</listitem>

						<listitem>
							<para><link linkend="twithin"><varname>twithin</varname></link>: Temporal within</para>
						</listitem>

						<listitem>
							<para><link linkend="tdwithin"><varname>tdwithin</varname></link>: Temporal distance within</para>
						</listitem>

						<listitem>
							<para><link linkend="trelate"><varname>trelate</varname></link>: Temporal relate</para>
						</listitem>
					</itemizedlist>
					</sect3>
			</sect2>

			<sect2>
				<title>Aggregate Functions for Temporal Types</title>

				<itemizedlist>
					<listitem>
						<para><link linkend="tcount"><varname>tcount</varname></link>: Temporal count</para>
					</listitem>

					<listitem>
						<para><link linkend="tand"><varname>tand</varname></link>: Temporal and</para>
					</listitem>

					<listitem>
						<para><link linkend="tor"><varname>tor</varname></link>: Temporal or</para>
					</listitem>

					<listitem>
						<para><link linkend="tmin"><varname>tmin</varname></link>: Temporal minimum</para>
					</listitem>

					<listitem>
						<para><link linkend="tmax"><varname>tmax</varname></link>: Temporal maximum</para>
					</listitem>

					<listitem>
						<para><link linkend="tsum"><varname>tsum</varname></link>: Temporal sum</para>
					</listitem>

					<listitem>
						<para><link linkend="tavg"><varname>tavg</varname></link>: Temporal average</para>
					</listitem>

					<listitem>
						<para><link linkend="wmin"><varname>wmin</varname></link>: Window minimum</para>
					</listitem>

					<listitem>
						<para><link linkend="wmax"><varname>wmax</varname></link>: Window maximum</para>
					</listitem>

					<listitem>
						<para><link linkend="wcount"><varname>wcount</varname></link>: Window count</para>
					</listitem>

					<listitem>
						<para><link linkend="wsum"><varname>wsum</varname></link>: Window sum</para>
					</listitem>

					<listitem>
						<para><link linkend="wavg"><varname>wavg</varname></link>: Window average</para>
					</listitem>

					<listitem>
						<para><link linkend="tcentroid"><varname>tcentroid</varname></link>: Temporal centroid</para>
					</listitem>

					<listitem>
						<para><link linkend="extent"><varname>extent</varname></link>: Bounding box extent</para>
					</listitem>

				</itemizedlist>
			</sect2>

			<sect2>
				<title>Utility Functions</title>
				<itemizedlist>
					<listitem>
						<para><link linkend="mobdb_lib_version"><varname>mobdb_lib_version</varname></link>: Get the version of the MobilityDB extension</para>
					</listitem>

					<listitem>
						<para><link linkend="mobdb_full_version"><varname>mobdb_full_version</varname></link>: Get the versions of the MobilityDB extension and its dependencies</para>
					</listitem>
				</itemizedlist>
			</sect2>
		</sect1>
	</appendix>
</book>
