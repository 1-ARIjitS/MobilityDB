<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [

<!ENTITY geography_support
"<inlinemediaobject>
	<imageobject><imagedata fileref='images/world.pdf' width='16pt' /></imageobject>
	<imageobject><imagedata fileref='images/world.svg' width='16pt' /></imageobject>
	<imageobject><imagedata fileref='images/world.png' width='16pt' /></imageobject>
 </inlinemediaobject>
">

<!ENTITY Z_support
"<inlinemediaobject>
	<imageobject><imagedata fileref='images/cube.pdf' width='16pt' /></imageobject>
	<imageobject><imagedata fileref='images/cube.svg' width='16pt' /></imageobject>
	<imageobject><imagedata fileref='images/cube.png' width='16pt' /></imageobject>
 </inlinemediaobject>
">

<!ENTITY python_support
"<inlinemediaobject>
	<imageobject><imagedata fileref='images/python.pdf' width='16pt' /></imageobject>
	<imageobject><imagedata fileref='images/python.svg' width='16pt' /></imageobject>
	<imageobject><imagedata fileref='images/python.png' width='16pt' /></imageobject>
 </inlinemediaobject>
">
]>

<book lang="en">
	<bookinfo>
		<title>MobilityDB Data Generator Workshop</title>

		<author>
			<firstname>Mahmoud</firstname>
			<surname>SAKR</surname>
			<affiliation>
				<orgname>Universit&eacute; libre de Bruxelles, Belgium</orgname>
			</affiliation>
		</author>

		<author>
			<firstname>Esteban</firstname>
			<surname>ZIM&Aacute;NYI</surname>
			<affiliation>
				<orgname>Universit&eacute; libre de Bruxelles, Belgium</orgname>
			</affiliation>
		</author>

		<abstract>
			<para>
				Every module in this workshop illustrates a usage scenario of MobilityDB. The data sets, and the tools are described inside each of the modules. Eventually more modules will be added to discover more MobilityDB features. 
			</para>
			<para>
				While this workshop illustrates the usage of MobilityDB functions, it doesn't explain them in detail. If you need help concerning the functions of MobilityDB, please refer to the <ulink url="https://docs.mobilitydb.com/nightly/">documentation</ulink>.
			</para>
			<para>
				If you have questions, ideas, comments, etc, please contact me on <ulink url="mailto:mahmoud.sakr@ulb.ac.be">mahmoud.sakr@ulb.ac.be</ulink>. 
			</para>
			<para>
				<inlinemediaobject>
					<imageobject>
						<imagedata fileref='images/mobilitydb-logo.png' width='200pt' />
					</imageobject>
				</inlinemediaobject>
			</para>
		</abstract>
	</bookinfo>

	<chapter id ="datagen">
		<title>Generating Realistic Trajectory Datasets</title>

		<section id ="datagen_about">
			<title>Introduction</title>
			<para>Do you need an arbitrarily large trajectory dataset to tests your ideas. The workshop module on Managing GTFS Data <xref  linkend="GTFS"/> has already illustrated how to generate public transport trajectories as per the schedule. This chapter continues and illustrates how to generate car trips in a city. It implements the BerlinMOD benchmark data generator, that is described in:
			</para>
			<para>
			Düntgen, C., Behr, T. and Güting, R.H. BerlinMOD: a benchmark for moving object databases. The VLDB Journal 18, 1335 (2009). https://doi.org/10.1007/s00778-009-0142-5	
			</para>
			<para>
			The data generator simulates as many cars and as many simulation days as needed. It models people trips using their cars to and from work during the week as well as some additional trips at evenings or weekends. The simulation uses multiple ideas to be close to reality, including:
			</para>
			<para>
			<itemizedlist>
					<listitem>
						<para>The home locations are sampled with respect to the population statistics of the different administrative areas in the city</para>
					</listitem>
					<listitem>
						<para>Similarly the work locations are sampled with respect to employment statistics</para>
					</listitem>
					<listitem>
						<para>Drivers will try to accelerate to the maximum allowed speed of a road</para>
					</listitem>
					<listitem>
						<para>Random events will force drivers to slow down or even stop to simulate obstacle, traffic lights, etc</para>
					</listitem>
					<listitem>
						<para>Drives will slow down in curves</para>
					</listitem>
				</itemizedlist>
			</para>	
			<para>
				The generator is written in PL/pgSQL, so that it will be easy to include own simulation rules. It uses MobilityDB types and operations. The generated trajectories are also mobilityDB types. It is controlled by a single parameter, <emphasis> scale factor </emphasis>, that determines the size of the generated dataset. 
			</para>	
		</section>
		<section>
		<title>Contents</title>
			<para>This module covers the following topics:
				<itemizedlist>
					<listitem>
						<para>A quick start using the generator</para>
					</listitem>
					<listitem>
						<para>Exploring the generated data</para>
					</listitem>
					<listitem>
						<para>Customizing the generator to your city</para>
					</listitem>
					<listitem>
						<para>Tuning the generator parameters</para>
					</listitem>
					<listitem>
						<para>Hacking the generator, and changing the simulation scenario</para>
					</listitem>
					<listitem>
						<para>Creating a graph to be used for the generator</para>
					</listitem>
				</itemizedlist>
			</para>
		</section>		
		<section>
			<title>Tools</title>
			<itemizedlist>
				<listitem>
					<para>MobilityDB, hence PostgreSQL and PostGIS. The installation instruction can be found <ulink  url="https://github.com/ULB-CoDE-WIT/MobilityDB">here</ulink>. 
					</para>
				</listitem>
				<listitem>
					<para>pgRouting. The installation instruction can be found <ulink  url="https://pgrouting.org/">here</ulink>.</para>
				</listitem>
			</itemizedlist>
		</section>
		<section id ="datagen_quickstart">
			<title>Quick Start</title>
			<para>
			Running the generator is done in three steps:
			</para>
			<para>
			<emphasis>Firstly, load the street network: </emphasis>
				Create a new database <varname>brussels</varname>, then add both PostGIS, MobilityDB, and pgRouting to it.
				<programlisting>
CREATE EXTENSION MobilityDB CASCADE;
CREATE EXTENSION pgRouting;				
				</programlisting>
				Here we will use the OSM map of Brussels. In the next sections, we will explain how to use other maps. To download the map using the Overpass API, write the following in a terminal: 
				<programlisting>
CITY="brussels"
BBOX="4.22,50.75,4.5,50.92"
wget --progress=dot:mega -O "$CITY.osm" 
		"http://www.overpass-api.de/api/xapi?*[bbox=${BBOX}][@meta]"
				</programlisting>
				or download the map from any OSM server. 
			</para>
			<para>
				To reduce the size of the OSM file:
				<programlisting>
sed -r "s/version=\"[0-9]+\" timestamp=\"[^\"]+\" changeset=\"[0-9]+\" uid=\"[0-9]+\" user=\"[^\"]+\"//g" brussels.osm -i.org
				</programlisting>
				The resulting file brussels.osm is also provided in the data section of this workshop. The data from the Overpass API is by default in Spherical Mercator (SRID 3857), so it is good for calculating distances. Next load the map and convert it into a routable format suitable for pgRouting. 
				<programlisting>
osm2pgrouting -f brussels.osm --dbname brussels -c mapconfig_brussels.xml
				</programlisting>				
				The configuration file mapconfig_brussels.xml tells osm2pgrouting about the speed limits of the different road types. During the conversion, osm2pgrouting transforms the data into WGS84 (SRID 4326).
			</para>
			<para>
			<emphasis>Secondly, prepare the base data for the simulation: </emphasis>						
				Now the street network is ready in the database. The simulation scenario requires to sample home and work locations. To make it realisitc, we want to load a map of the administrative regoins of Brussuls (called communes), and feed the simulator with real statistics about the population, and the number of jobs in every commune.
			</para>
			<para>
				Load the administrative regions from the downloaded brussels.osm file, then run the brussels_generatedata.sql script using your postgresql client, for example:
				<programlisting>
osm2pgsql -c -d brussels brussels.osm
psql -d brussels -f brussels_preparedata.sql 
				</programlisting>
			</para>	
			<para>
			<emphasis>Finally run the generator</emphasis>
				<programlisting>
psql -d brussels -f berlinmod_datagenerator_batch.sql
psql -d brussels -c 'select berlinmod_generate(scaleFactor := 0.005)'
				</programlisting>
				If everything is correct, you should see an output like that starts with this:
				<programlisting>
NOTICE:  ------------------------------------------------------------------
NOTICE:  Starting the work week data generator with Scale Factor 0.005
NOTICE:  ------------------------------------------------------------------
NOTICE:  Parameters: 
NOTICE:  ------------
NOTICE:  No. of Cars = 141, No. of Days = 2, Start day = 2000-01-03
NOTICE:  Optimization = Fastest Path, Disturb data = f
...					
				</programlisting>	
				The generator will take about around 1 minute. It will generate trajectories, according to the default parameters, for 141 cars over 2 days Jan 3rd and 4th, 2000. As you may have guessed, it is possible to generate more or less data by respectively passing a bigger or a smaller scale factor value.  
			</para>
		</section>
		<section>
			<title>Exploring the Generated Data</title>
		</section>
		<section>
			<title>Customizing the Generator to Your City</title>
			<para>
				In order to customize the generator to a particular city the only thing we need is to define a bounding box that will be used to download the data from OSM. There are many ways to obtain such a bounding box, and a typical way to proceed is to use one of the multiple online services that allows one to visually define a bounding box over a map. <xref linkend="barcelona_bbox" /> shows how we can define the bounding box around Barcelona using the web site <ulink url="http://bboxfinder.com/">bboxfinder</ulink>.
			</para>
			<figure id="barcelona_bbox" float="start"><title>Defining the bounding box around Barcelona</title>
				<mediaobject>
					<imageobject><imagedata scalefit="1" fileref='workshopimages/barcelona_bbox.png' /></imageobject>
				</mediaobject>
			</figure>

			<para>
				After obtaining the bounding box, we can proceed as we stated in <xref linkend="datagen_quickstart" />.
				We create a new database <varname>barcelona</varname>, then add both PostGIS, MobilityDB, and pgRouting to it.
				<programlisting>
CREATE EXTENSION mobilitydb CASCADE;
CREATE EXTENSION pgRouting;
				</programlisting>
				Then, we download the OSM data from Barcelona using the Overpass API by writing the following in a terminal:
				<programlisting>
CITY="barcelona"
BBOX="2.042084,41.267743,2.258720,41.445043"
wget --progress=dot:mega -O "$CITY.osm" "http://www.overpass-api.de/api/xapi?*[bbox=${BBOX}][@meta]"
				</programlisting>

				We can optionally reduce the size of the OSM file as follows
				<programlisting>
sed -r "s/version=\"[0-9]+\" timestamp=\"[^\"]+\" changeset=\"[0-9]+\" uid=\"[0-9]+\" user=\"[^\"]+\"//g" barcelona.osm -i.org
				</programlisting>
				Finally, we load the map and convert it into a routable format suitable for pgRouting as follows.
				<programlisting>
osm2pgrouting -f barcelona.osm --dbname barcelona -c mapconfig_brussels.xml
				</programlisting>
			</para>
		</section>
		<section>
			<title>Tuning the Generator Parameters</title>
		</section>
		<sect1 id="deliveries" >
			<title>Changing the Simulation Scenario</title>
			<para>
				In this workshop, we have used until now the BerlinMOD scenario, which models the trajectories of persons going from home to work in the morning and returning back from work to home in the evening during the week days, with one possible leisure trip during the weekday nights and two possible leisure trips in the morning and in the afternoon of the weekend days. In this section, we devise another scenario for the data generator. This scenario corresponds to a home appliance shop that has several warehouses located in various places of the city. From each warehouse, the deliveries of appliances to customers are done by vehicles belonging to the warehouse. Although this scenario is different than BerlinMOD, many things can be reused and adapted. For example, home nodes can be replaced by warehouse locations, leisure destinations can be replaced by customer locations, and in this way many functions of the BerlinMOD SQL code will work directly. This is a direct benefit of having the simulation code written in SQL, so it will be easy to adapt to other scenarios. We describe next the needed changes.
			</para>
			<para>
				Each day of the week excepted Sundays, deliveries of appliances from the warehouses to the customers are organized as follows. Each warehouse has several vehicles that make the deliveries. To each vehicle is assigned a list of customers that must be delivered during a day. A trip for a vehicle starts and ends at the warehouse and make the deliveries to the customers in the order of the list. Notice that in a real-world situation, the scheduling of the deliveries to clients by the vehicles requires to take into account the availability of the customers in a time slot of a day and the time needed to make the delivery of the previous customers in the list.
			</para>
			<para>
				We describe next the main steps in the generation of the deliveries scenario.
			</para>
			<para>
				We start by generating the <varname>Warehouse</varname> table. Each warehouse is located at a random node of the network.
				<programlisting>
	DROP TABLE IF EXISTS Warehouse;
	CREATE TABLE Warehouse(warehouseId int, nodeId bigint, geom geometry(Point));

	FOR i IN 1..noWarehouses LOOP
		INSERT INTO Warehouse(warehouseId, nodeId, geom)
		SELECT i, id, geom
		FROM Nodes N
		ORDER BY id LIMIT 1 OFFSET random_int(1, noNodes);
	END LOOP;
				</programlisting>
				We create a relation <varname>Vehicle</varname> with all vehicles and the associated warehouse. Warehouses are associated to vehicles in a round-robin way.
				<programlisting>
	DROP TABLE IF EXISTS Vehicle;
	CREATE TABLE Vehicle(vehicleId int, warehouseId int, noNeighbours int);

	INSERT INTO Vehicle(vehicleId, warehouseId)
	SELECT id, 1 + ((id - 1) % noWarehouses)
	FROM generate_series(1, noVehicles) id;
				</programlisting>
				We then create a relation <varname>Neighbourhood</varname> containing for each vehicle the nodes with a distance less than the parameter <varname>P_NEIGHBOURHOOD_RADIUS</varname> to its warehouse node.
				<programlisting>
	DROP TABLE IF EXISTS Neighbourhood;
	CREATE TABLE Neighbourhood AS
	SELECT ROW_NUMBER() OVER () AS id, V.vehicleId, N2.id AS Node
	FROM Vehicle V, Nodes N1, Nodes N2
	WHERE V.warehouseId = N1.id AND ST_DWithin(N1.Geom, N2.geom, P_NEIGHBOURHOOD_RADIUS);

	CREATE UNIQUE INDEX Neighbourhood_id_idx ON Neighbourhood USING BTREE(id);
	CREATE INDEX Neighbourhood_vehicleId_idx ON Neighbourhood USING BTREE(VehicleId);

	UPDATE Vehicle V SET
		noNeighbours = (SELECT COUNT(*) FROM Neighbourhood N WHERE N.vehicleId = V.vehicleId);
				</programlisting>
			</para>

			<para>
				We create next the <varname>DeliveryTrip</varname> and <varname>Destinations</varname> tables that contain, respectively,  the list of source and destination nodes composing the delivery trip of a vehicle for a day, and the list of source and destination nodes for all vehicles.
				<programlisting>
DROP TABLE IF EXISTS DeliveryTrip;
CREATE TABLE DeliveryTrip(vehicle int, day date, seq int, source bigint, target bigint,
	PRIMARY KEY (vehicle, day, seq));
DROP TABLE IF EXISTS Destinations;
CREATE TABLE Destinations(id serial, source bigint, target bigint);
-- Loop for every vehicle
FOR i IN 1..noVehicles LOOP
	-- Get the warehouse node and the number of neighbour nodes
	SELECT W.node, V.noNeighbours INTO warehouseNode, noNeigh
	FROM Vehicle V, Warehouse W WHERE V.id = i AND V.warehouse = W.id;
	day = startDay;
	-- Loop for every generation day
	FOR j IN 1..noDays LOOP
		-- Generate delivery trips excepted on Sunday
		IF date_part('dow', day) &lt;&gt; 0 THEN
			-- Select a number of destinations between 3 and 7
			SELECT random_int(3, 7) INTO noDest;
			sourceNode = warehouseNode;
			FOR k IN 1..noDest + 1 LOOP
				IF k &lt;= noDest THEN
					targetNode = berlinmod_selectDestNode(i, noNeigh, noNodes);
				ELSE
					targetNode = warehouseNode;
				END IF;
				IF targetNode IS NULL THEN
					RAISE EXCEPTION '    Destination node cannot be NULL';
				END IF;
				-- Keep the start and end nodes of each subtrip
				INSERT INTO DeliveryTrip VALUES (i, day, k, sourceNode, targetNode);
				INSERT INTO Destinations(source, target) VALUES (sourceNode, targetNode);
				sourceNode = targetNode;
			END LOOP;
		END IF;
		day = day + 1 * interval '1 day';
	END LOOP;
END LOOP;
				</programlisting>
				For every vehicle and every day which is not Sunday we proceed as follows. We randomly chose a number between 3 and 7 destinations and call the function <varname>berlinmod_selectDestNode</varname> we have seen in previous sections for determining these destinations. This function choses either one node in the neighbourhood of the warehouse of the vehicle with 80% probability or a node from the complete graph with 20% probability. Then, the sequence of source and destination couples starting in the warehouse, visiting sequentially the clients to deliver and returning to the warehouse are added to the tables <varname>DeliveryTrip</varname> and <varname>Destinations</varname>.
			</para>

			<para>
				Next, we compute the paths between all source and target nodes that are in the  <varname>Destinations</varname> table. Such paths are generated by pgRouting and stored in the <varname>Paths</varname> table.
				<programlisting>
DROP TABLE IF EXISTS Paths;
CREATE TABLE Paths(seq int, path_seq int, start_vid bigint, end_vid bigint,
	node bigint, edge bigint, cost float, agg_cost float,
	-- These attributes are filled in the subsequent update
	geom geometry, speed float, category int);

-- Select query sent to pgRouting
IF pathMode = 'Fastest Path' THEN
	query1_pgr = 'SELECT id, source, target, cost_s AS cost, reverse_cost_s as reverse_cost FROM edges';
ELSE
	query1_pgr = 'SELECT id, source, target, length_m AS cost, length_m * sign(reverse_cost_s) as reverse_cost FROM edges';
END IF;
-- Get the total number of paths and number of calls to pgRouting
SELECT COUNT(*) INTO noPaths FROM (SELECT DISTINCT source, target FROM Destinations) AS T;
noCalls = ceiling(noPaths / P_PGROUTING_BATCH_SIZE::float);
FOR i IN 1..noCalls LOOP
	query2_pgr = format('SELECT DISTINCT source, target FROM Destinations ORDER BY source, target LIMIT %s OFFSET %s',
		P_PGROUTING_BATCH_SIZE, (i - 1) * P_PGROUTING_BATCH_SIZE);
	INSERT INTO Paths(seq, path_seq, start_vid, end_vid, node, edge, cost, agg_cost)
	SELECT * FROM pgr_dijkstra(query1_pgr, query2_pgr, true);
END LOOP;

UPDATE Paths SET geom =
		-- adjusting directionality
		CASE
			WHEN node = E.source THEN E.geom
			ELSE ST_Reverse(E.geom)
		END,
		speed = maxspeed_forward,
		category = berlinmod_roadCategory(tag_id)
	FROM Edges E WHERE E.id = edge;

CREATE INDEX Paths_start_vid_end_vid_idx ON Paths USING BTREE(start_vid, end_vid);
				</programlisting>
				After creating the <varname>Paths</varname> table, we set the query to be sent to pgRouting depending on whether we have want to compute the fastest or the shortest paths between two nodes. The generator uses the parameter <varname>P_PGROUTING_BATCH_SIZE</varname> to determine the maximum number of paths we compute in a single call to pgRouting. This parameter is set to 10,000 by default. Indeed, there is limit in the number of paths that pgRouting can compute in a single call and this depends in the available memory of the computer. Therefore, we need to determine the number of calls to pgRouting and compute the paths by calling the function <varname>pgr_dijkstra</varname>. Finally, we need to adjust the directionality of the geometry of the edges depending on which direction a trip traverses the edges, and set the speed and the category of the edges.
			</para>
			<para>
				The following procedure generates the trips for a number of vehicles and a number of days starting at a given day. The last argument correspond to the Boolean parameter <varname>P_DISTURB_DATA</varname> that determines whether simulated GPS errors are added to the trips.
				<programlisting>
DROP FUNCTION IF EXISTS deliveries_createTrips;
CREATE FUNCTION deliveries_createTrips(noVehicles int, noDays int, startDay Date,
	disturbData boolean)
RETURNS void LANGUAGE plpgsql STRICT AS $$
DECLARE
	-- Loops over the days for which we generate the data
	day date;
	-- 0 (Sunday) to 6 (Saturday)
	weekday int;
	-- Loop variables
	i int; j int;
BEGIN
	DROP TABLE IF EXISTS Trips;
	CREATE TABLE Trips(vehicle int, day date, seq int, source bigint,
		target bigint, trip tgeompoint,
		-- These columns are used for visualization purposes
		trajectory geometry, sourceGeom geometry,
		PRIMARY KEY (vehicle, day, seq));
	day = startDay;
	FOR i IN 1..noDays LOOP
		SELECT date_part('dow', day) into weekday;
		-- 6: saturday, 0: sunday
		IF weekday &lt;&gt; 0 THEN
			FOR j IN 1..noVehicles LOOP
				PERFORM deliveries_createDay(j, day, disturbData);
			END LOOP;
		END IF;
		day = day + 1 * interval '1 day';
	END LOOP;
	-- Add geometry attributes for visualizing the results
	UPDATE Trips SET sourceGeom = (SELECT geom FROM Nodes WHERE id = source);
	RETURN;
END; $$
				</programlisting>
				As can be seen, this procedure simply loops for each day (excepted Sundays) and for each vehicle and calls the function <varname>deliveries_createDay</varname> which is given next.
				<programlisting>
DROP FUNCTION IF EXISTS deliveries_createDay;
CREATE FUNCTION deliveries_createDay(vehicId int, aDay date, disturbData boolean)
RETURNS void LANGUAGE plpgsql STRICT AS $$
DECLARE
	-- Current timestamp
	t timestamptz;
	-- Start time of a trip to a destination
	startTime timestamptz;
	-- Number of trips in a delivery (number of destinations + 1)
	noTrips int;
	-- Loop variable
	i int;
	-- Time delivering a customer
	deliveryTime interval;
	-- Warehouse identifier
	warehouseNode bigint;
	-- Source and target nodes of one subtrip of a delivery trip
	sourceNode bigint; targetNode bigint;
	-- Path betwen start and end nodes
	path step[];
	-- Trip obtained from a path
	trip tgeompoint;
BEGIN
	-- 0: sunday
	IF date_part('dow', aDay) &lt;&gt; 0 THEN
		-- Start delivery
		t = aDay + time '07:00:00' + createPauseN(120);
		-- Get the number of trips (number of destinations + 1)
		SELECT count(*) INTO noTrips
		FROM DeliveryTrip D
		WHERE D.vehicle = vehicId AND D.day = aDay;
		FOR i IN 1..noTrips LOOP
			-- Get the source and destination nodes of the trip
			SELECT source, target INTO sourceNode, targetNode
			FROM DeliveryTrip D
			WHERE D.vehicle = vehicId AND D.day = aDay AND D.seq = i;
			-- Get the path
			SELECT array_agg((geom, speed, category) ORDER BY path_seq) INTO path
			FROM Paths P
			WHERE start_vid = sourceNode AND end_vid = targetNode AND edge > 0;
			IF path IS NULL THEN
				RAISE EXCEPTION 'The path of a trip cannot be NULL';
			END IF;
			startTime = t;
			trip = create_trip(path, t, disturbData);
			IF trip IS NULL THEN
				RAISE EXCEPTION 'A trip cannot be NULL';
			END IF;
			INSERT INTO Trips VALUES (vehicId, aDay, i, sourceNode, targetNode,
				trip, trajectory(trip));
			t = endTimestamp(trip);
			-- Add a delivery time in [10, 60] min using a bounded Gaussian distribution
			deliveryTime = random_boundedgauss(10, 60) * interval '1 min';
			t = t + deliveryTime;
		END LOOP;
	END IF;
END;
$$ LANGUAGE plpgsql STRICT;
				</programlisting>
				We first set the start time of a delivery trip by adding to 7 am a random non-zero duration of 120 minutes using a uniform distribution. Then, for every couple of source and destination nodes to be visited in the trip, we call the function <varname>create_trip</varname> that we have seen previously to generate the trip, wich is then inserted into the <varname>Trips</varname> table. Finally, we add a delivery time between 10 and 60 minutes using a bounded Gaussian distribution before starting the trip to the next customer or the return trip to the warehouse.
			</para>
			<para>
				<xref linkend="deliveries1" /> and <xref linkend="deliveries2" /> show visualizations of the data generated for the deliveries scenario.
			</para>
				<figure id="deliveries1" float="start"><title>Visualization of the data generated for the deliveries scenario. The road network is shown with blue lines, the warehouses are shown with a red star, the routes taken by the deliveries are shown with black lines, and the location of the customers with black points.</title>
					<mediaobject>
						<imageobject><imagedata scalefit="1" fileref='workshopimages/deliveries1.png' /></imageobject>
					</mediaobject>
					<mediaobject>
						<imageobject><imagedata scalefit="1" fileref='workshopimages/deliveries3.png' /></imageobject>
					</mediaobject>
				</figure>

				<figure id="deliveries2" float="start"><title>Visualization of the deliveries of one vehicle during one day. A delivery trip starts and ends at a warehouse and make the deliveries to several customers, four in this case.</title>
					<mediaobject>
						<imageobject><imagedata scalefit="1" fileref='workshopimages/deliveries4.png' /></imageobject>
					</mediaobject>
				</figure>
		</sect1>
		<sect1 id="creategraph">
			<title>Creating a Graph from Input Data</title>
			<para>
				In this workshop, we have used until now the network topology obtained by osm2pgrouting. However, in some circumstances it is necessary to build the network topology ourselves, for example, when the data comes from other sources than OSM, such as data from an official mapping agency. In this section we show how to build the network topology from input data. We import Brussels data from OSM into a PostgreSQL database using osm2pgsql. Then, we construct the network topology using SQL so that the resulting graph can be used with pgRouting. We show two approaches for doing this, depending on whether we want to keep the original roads of the input data or we want to merge roads when they have similar characteristics such as road type, direction, maximum speed, etc. At the end, we compare the two networks obtained with the one obtained by osm2pgrouting.
			</para>
			<sect2 id="create_graph">
				<title>Creating the Graph using SQL</title>
				<para>
					As we did at the beginning of this chapter, we load the OSM data from Brussels into PostgreSQL with the following command.
					<programlisting>
osm2pgsql --create --database brussels --host localhost brussels.osm
					</programlisting>
					The table <varname>planet_osm_line</varname> contains all linear features imported from OSM, in particular road data, but also many other features which are not relevant for our use case such as pedestrian paths, cycling ways, train ways, electric lines, etc. Therefore, we use the attribute <varname>highway</varname> to extract the roads from this table. We first create a table containing the road types we are interested in and associate to them a priority, a maximum speed, and a category as follows.
					<programlisting>
DROP TABLE IF EXISTS RoadTypes;
CREATE TABLE RoadTypes(id int PRIMARY KEY, type text, priority float, maxspeed float,
	category int);
INSERT INTO RoadTypes VALUES
(101, 'motorway', 1.0, 120, 1),
(102, 'motorway_link', 1.0, 120, 1),
(103, 'motorway_junction', 1.0, 120, 1),
(104, 'trunk', 1.05, 120, 1),
(105, 'trunk_link', 1.05, 120, 1),
(106, 'primary', 1.15, 90, 2),
(107, 'primary_link', 1.15, 90, 1),
(108, 'secondary', 1.5, 70, 2),
(109, 'secondary_link', 1.5, 70, 2),
(110, 'tertiary', 1.75, 50, 2),
(111, 'tertiary_link', 1.75, 50, 2),
(112, 'residential', 2.5, 30, 3),
(113, 'living_street', 3.0, 20, 3),
(114, 'unclassified', 3.0, 20, 3),
(115, 'service', 4.0, 20, 3),
(116, 'services', 4.0, 20, 3);
					</programlisting>
					Then, we create a table that contains the roads corresponding to one of the above types as follows.
					<programlisting>
DROP TABLE IF EXISTS Roads;
CREATE TABLE Roads AS
SELECT osm_id, admin_level, bridge, cutting, highway, junction, name, oneway, operator,
	ref, route, surface, toll, tracktype, tunnel, width, way AS geom
FROM planet_osm_line
WHERE highway IN (SELECT type FROM RoadTypes);

CREATE INDEX Roads_geom_idx ON Roads USING GiST(geom);
					</programlisting>
				</para>
				<para>
					We then create a table that contains all intersections between two roads as follows:
					<programlisting>
DROP TABLE IF EXISTS Intersections;
CREATE TABLE Intersections AS
WITH Temp1 AS (
	SELECT ST_Intersection(a.geom, b.geom) AS geom
	FROM Roads a, Roads b
	WHERE a.osm_id &lt; b.osm_id AND ST_Intersects(a.geom, b.geom)
),
Temp2 AS (
	SELECT DISTINCT geom
	FROM Temp1
	WHERE geometrytype(geom) = 'POINT'
	UNION
	SELECT (ST_DumpPoints(geom)).geom
	FROM Temp1
	WHERE geometrytype(geom) = 'MULTIPOINT'
)
SELECT ROW_NUMBER() OVER () AS id, geom
FROM Temp2;

CREATE INDEX Intersections_geom_idx ON Intersections USING GIST(geom);
					</programlisting>
					The temporary table <varname>Temp1</varname> computes all intersections between two different roads, while the temporary table <varname>Temp2</varname> selects all intersections of type point and splits the intersections of type multipoint into the component points with the function <varname>ST_DumpPoints</varname>. Finally, the last query adds a sequence identifier to the resulting intersections.
				</para>
				<para>
					Our next task is to use the table <varname>Intersections</varname> we have just created to split the roads. This is done as follows.
					<programlisting>
DROP TABLE IF EXISTS Segments;
CREATE TABLE Segments AS
SELECT DISTINCT osm_id, (ST_Dump(ST_Split(R.geom, I.geom))).geom
FROM Roads R, Intersections I
WHERE ST_Intersects(R.Geom, I.geom);

CREATE INDEX Segments_geom_idx ON Segments USING GIST(geom);
					</programlisting>
					The function <varname>ST_Split</varname> breaks the geometry of a road using an intersection and the function <varname>ST_Dump</varname> obtains the individual segments resulting from the splitting. However, as shown in the following query, there are duplicate segments with distinct <varname>osm_id</varname>.
					<programlisting>
SELECT S1.osm_id, S2.osm_id
FROM Segments S1, Segments S2
WHERE S1.osm_id &lt; S2.osm_id AND st_intersects(S1.geom, S2.geom) AND
	ST_Equals(S1.geom, S2.geom);
-- 490493551	740404156
-- 490493551	740404157
					</programlisting>
					We can remove those duplicates segments with the following query, which keeps arbitrarily the smaller <varname>osm_id</varname>.
					<programlisting>
DELETE FROM Segments S1
    USING Segments S2
WHERE S1.osm_id > S2.osm_id AND ST_Equals(S1.geom, S2.geom);
					</programlisting>
					We can obtain some characteristics of the segments with the following queries.
					<programlisting>
SELECT DISTINCT geometrytype(geom) FROM Segments;
-- "LINESTRING"

SELECT min(ST_NPoints(geom)), max(ST_NPoints(geom)) FROM Segments;
-- 2	283
					</programlisting>
				</para>
				<para>
					Now we are ready to obtain a first set of nodes for our graph.
					<programlisting>
DROP TABLE IF EXISTS TempNodes;
CREATE TABLE TempNodes AS
WITH Temp(geom) AS (
	SELECT ST_StartPoint(geom) FROM Segments UNION
	SELECT ST_EndPoint(geom) FROM Segments
)
SELECT ROW_NUMBER() OVER () AS id, geom
FROM Temp;

CREATE INDEX TempNodes_geom_idx ON TempNodes USING GIST(geom);
					</programlisting>
					The above query select as nodes the start and the end points of the segments and assigns to each of them a sequence identifier. We construct next the set of edges of our graph as follows.
					<programlisting>
DROP TABLE IF EXISTS Edges;
CREATE TABLE Edges(id bigint, osm_id bigint, tag_id int, length_m float, source bigint,
	target bigint, cost_s float, reverse_cost_s float, one_way int, maxspeed float,
	priority float, geom geometry);
INSERT INTO Edges(id, osm_id, source, target, geom, length_m)
SELECT ROW_NUMBER() OVER () AS id, S.osm_id, N1.id AS source, N2.id AS target, S.geom,
	ST_Length(S.geom) AS length_m
FROM Segments S, TempNodes N1, TempNodes N2
WHERE ST_Intersects(ST_StartPoint(S.geom), N1.geom) AND
	ST_Intersects(ST_EndPoint(S.geom), N2.geom);

CREATE UNIQUE INDEX Edges_id_idx ON Edges USING BTREE(id);
CREATE INDEX Edges_geom_index ON Edges USING GiST(geom);
					</programlisting>
					The above query connects the segments obtained previously to the source and target nodes. We can verify that all edges were connected correctly to their source and target nodes using the following query.
					<programlisting>
SELECT count(*) FROM Edges WHERE source IS NULL OR target IS NULL;
-- 0
					</programlisting>
				</para>
				<para>
					Now we can fill the other attributes of the edges. We start first with the attributes <varname>tag_id</varname>, <varname>priority</varname>, and <varname>maxspeed</varname>, which are obtained from the table <varname>RoadTypes</varname> using the attribute <varname>highway</varname>.
					<programlisting>
UPDATE Edges E
SET tag_id = T.id, priority = T.priority, maxspeed = T.maxSpeed
FROM Roads R, RoadTypes T
WHERE E.osm_id = R.osm_id AND R.highway = T.type;
					</programlisting>
					We continue with the attribute <varname>one_way</varname> according to the <ulink url="https://wiki.openstreetmap.org/wiki/Key:oneway">semantics</ulink> stated in the OSM documentation.
					<programlisting>
UPDATE Edges E
SET one_way = CASE
	WHEN R.oneway = 'yes' OR R.oneway = 'true' OR R.oneway = '1' THEN 1 -- Yes
	WHEN R.oneway = 'no' OR R.oneway = 'false' OR R.oneway = '0' THEN 2 -- No
	WHEN R.oneway = 'reversible' THEN 3 -- Reversible
	WHEN R.oneway = '-1' OR R.oneway = 'reversed' THEN -1 -- Reversed
	WHEN R.oneway IS NULL THEN 0 -- Unknown
	END
FROM Roads R
WHERE E.osm_id = R.osm_id;
					</programlisting>
					We compute the implied one way restriction based on OSM documentation as follows.
					<programlisting>
UPDATE Edges E
SET one_way = 1
FROM Roads R
WHERE E.osm_id = R.osm_id AND R.oneway IS NULL AND
	(R.junction = 'roundabout' OR R.highway = 'motorway');
					</programlisting>
					Finally, we compute the cost and reverse cost in seconds according to the length and the maximum speed of the edge.
					<programlisting>
UPDATE Edges E SET
	cost_s = CASE
		WHEN one_way = -1 THEN - length_m / (maxspeed / 3.6)
		ELSE length_m / (maxspeed / 3.6)
		END,
	reverse_cost_s = CASE
		WHEN one_way = 1 THEN - length_m / (maxspeed / 3.6)
		ELSE length_m / (maxspeed / 3.6)
		END;
					</programlisting>
				</para>
				<para>
					Our last task is to compute the strongly connected components of the graph. This is necessary to ensure that there is a path between every couple of arbritrary nodes in the graph.
					<programlisting>
DROP TABLE IF EXISTS Nodes;
CREATE TABLE Nodes AS
WITH Components AS (
	SELECT * FROM pgr_strongComponents(
		'SELECT id, source, target, length_m AS cost, '
		'length_m * sign(reverse_cost_s) AS reverse_cost FROM Edges')
),
LargestComponent AS (
	SELECT component, count(*) FROM Components
	GROUP BY component ORDER BY count(*) DESC LIMIT 1
),
Connected AS (
	SELECT geom
	FROM TempNodes N, LargestComponent L, Components C
	WHERE N.id = C.node AND C.component = L.component
)
SELECT ROW_NUMBER() OVER () AS id, geom
FROM Connected;

CREATE UNIQUE INDEX Nodes_id_idx ON Nodes USING BTREE(id);
CREATE INDEX Nodes_geom_idx ON Nodes USING GiST(geom);
					</programlisting>
					The temporary table <varname>Components</varname> is obtained by calling the function <varname>pgr_strongComponents</varname> from pgRouting, the temporary table <varname>LargestComponent</varname> selects the largest component from the previous table, and the temporary table <varname>Connected</varname> selects all nodes that belong to the largest component. Finally, the last query assigns a sequence identifier to all nodes.
				</para>
				<para>
					Now that we computed the nodes of the graph, we need to link the edges with the identifiers of these nodes. This is done as follows.
					<programlisting>
UPDATE Edges SET source = NULL, target = NULL;

UPDATE Edges E SET
	source = N1.id, target = N2.id
FROM Nodes N1, Nodes N2
WHERE ST_Intersects(E.geom, N1.geom) AND ST_StartPoint(E.geom) = N1.geom AND
	ST_Intersects(E.geom, N2.geom) AND ST_EndPoint(E.geom) = N2.geom;
					</programlisting>
					We first set the identifiers of the source and target nodes to NULL before connecting them to the identifiers of the node.

					Finally, we delete the edges whose source or target node has been removed.
					<programlisting>
DELETE FROM Edges WHERE source IS NULL OR target IS NULL;
-- DELETE 1080
					</programlisting>
				</para>

				<para>
					In order to compare the graph we have just obtained with the one obtained by osm2pgrouting we can issue the following queries.
					<programlisting>
SELECT count(*) FROM Ways;
-- 83017
SELECT count(*) FROM Edges;
-- 81073
SELECT count(*) FROM Ways_vertices_pgr;
-- 66832
SELECT count(*) FROM Nodes;
-- 45494
					</programlisting>
					As can be seen, we have reduced the size of the graph. This can also be shown in <xref linkend="node_comp1" />, where the nodes we have obtained are shown in blue and the ones obtained by osm2pgrouting are shown in red. It can be seen that osm2pgrouting adds many more nodes to the graph, in particular, at the intersection of a road and a pedestrian crossing. Our method only adds nodes when there is an intersection between two roads. We will show in the next section how this network can still be optimized by removing unnecessary nodes and merging the corresponding edges.
				</para>
				<figure id="node_comp1" float="start"><title>Comparison of the nodes obtained (in blue) with those obtained by osm2pgrouting (in red).</title>
					<mediaobject>
						<imageobject><imagedata scalefit="1" fileref='workshopimages/node_comp1.png' /></imageobject>
					</mediaobject>
				</figure>
			</sect2>
			<sect2>
				<title>Linear Contraction of the Graph</title>
				<para>
					We show next a possible approach to contract the graph. This approach corresponds to <ulink url="https://docs.pgrouting.org/3.0/en/contraction-family.html">linear contraction</ulink> provided by pgRouting although we do it differently by taking into account the type, the direction, and the geometry of the roads. For this, we get the initial roads to merge as we did previously but now we put them in a table <varname>TempRoads</varname>.
					<programlisting>
DROP TABLE IF EXISTS TempRoads;
CREATE TABLE TempRoads AS
SELECT osm_id, admin_level, bridge, cutting, highway, junction, name, oneway, operator,
	ref, route, surface, toll, tracktype, tunnel, width, way AS geom
FROM planet_osm_line
WHERE highway IN (SELECT type FROM RoadTypes);
-- SELECT 37045
CREATE INDEX TempRoads_geom_idx ON TempRoads USING GiST(geom);
					</programlisting>
					Then, we use the following procedure to merge the roads.
					<programlisting>
CREATE OR REPLACE FUNCTION mergeRoads()
RETURNS void LANGUAGE PLPGSQL AS $$
DECLARE
	i integer = 1;
	cnt integer;
BEGIN
	-- Create tables
	DROP TABLE IF EXISTS MergedRoads;
	CREATE TABLE MergedRoads AS
	SELECT *, '{}'::bigint[] AS path
	FROM TempRoads;
	CREATE INDEX MergedRoads_geom_idx ON MergedRoads USING GIST(geom);
	DROP TABLE IF EXISTS Merge;
	CREATE TABLE Merge(osm_id1 bigint, osm_id2 bigint, geom geometry);
	DROP TABLE IF EXISTS DeletedRoads;
	CREATE TABLE DeletedRoads(osm_id bigint);
	-- Iterate until no geometry can be extended
	LOOP
		RAISE INFO 'Iteration %', i;
		i = i + 1;
		-- Compute the union of two roads
		DELETE FROM Merge;
		INSERT INTO Merge
		SELECT R1.osm_id AS osm_id1, R2.osm_id AS osm_id2,
			ST_LineMerge(ST_Union(R1.geom, R2.geom)) AS geom
		FROM MergedRoads R1, TempRoads R2
		WHERE R1.osm_id &lt;&gt; R2.osm_id AND R1.highway = R2.highway AND
			R1.oneway = R2.oneway AND ST_Intersects(R1.geom, R2.geom) AND
			ST_EndPoint(R1.geom) =  ST_StartPoint(R2.geom)
			AND NOT EXISTS (
				SELECT * FROM TempRoads R3
				WHERE osm_id NOT IN (SELECT osm_id FROM DeletedRoads) AND
					R3.osm_id &lt;&gt; R1.osm_id AND R3.osm_id &lt;&gt; R2.osm_id AND
					ST_Intersects(R3.geom, ST_StartPoint(R2.geom)))
			AND geometryType(ST_LineMerge(ST_Union(R1.geom, R2.geom))) = 'LINESTRING'
			AND NOT St_Equals(ST_LineMerge(ST_Union(R1.geom, R2.geom)), R1.geom);
		-- Exit if there is no more roads to extend
		SELECT count(*) INTO cnt FROM Merge;
		RAISE INFO 'Extended % roads', cnt;
		EXIT WHEN cnt = 0;
		-- Extend the geometries
		UPDATE MergedRoads R SET
			geom = M.geom,
			path = R.path || osm_id2
		FROM Merge M
		WHERE R.osm_id = M.osm_id1;
		-- Keep track of redundant roads
		INSERT INTO DeletedRoads
		SELECT osm_id2 FROM Merge
		WHERE osm_id2 NOT IN (SELECT osm_id FROM DeletedRoads);
	END LOOP;
	-- Delete redundant roads
	DELETE FROM MergedRoads R USING DeletedRoads M
	WHERE R.osm_id = M.osm_id;
	-- Drop tables
	DROP TABLE Merge;
	DROP TABLE DeletedRoads;
	RETURN;
END; $$
					</programlisting>
				</para>
				<para>
					The procedure starts by creating a table <varname>MergedRoads</varname> obtained by adding a column <varname>path</varname> to the table <varname>TempRoads</varname> created before. This column keeps track of the identifiers of the roads that are merged with the current one and is initialized to an empty array. It also creates two tables <varname>Merge</varname> and <varname>DeletedRoads</varname> that will contain, respectively, the result of merging two roads, and the identifiers of the roads that will be deleted at the end of the process. The procedure then iterates while there is at least one road that can be extended with the geometry of another one to which it connects to. More precisely, a road can be extended with the geometry of another one if they are of the same type and the same direction (as indicated by the attributes <varname>highway</varname> and <varname>one_way</varname>), the end point of the road is the start point of the other road, and this common point is not a crossing, that is, there is no other road that starts and this common point. Notice that we only merge roads if their resulting geometry is a linestring and we avoid infinite loops by verifying that the merge of the two roads is different from the original geometry. After that, we update the roads with the new geometries and add the identifier of the road used to extend the geometry into the <varname>path</varname> attribute and the <varname>DeletedRoads</varname> table. After exiting the loop, the procedure finishes by removing unnecessary roads.
				</para>
				<para>
The above procedure iterates 20 times for the largest segment that can be assembled, which is located in the ring-road around Brussels between two exits. It takes 15 minutes to execute in my laptop.
					<programlisting>
INFO:  Iteration 1
INFO:  Extended 3431 roads
INFO:  Iteration 2
INFO:  Extended 1851 roads
INFO:  Iteration 3
INFO:  Extended 882 roads
INFO:  Iteration 4
INFO:  Extended 505 roads
[...]
INFO:  Iteration 17
INFO:  Extended 3 roads
INFO:  Iteration 18
INFO:  Extended 2 roads
INFO:  Iteration 19
INFO:  Extended 1 roads
INFO:  Iteration 20
INFO:  Extended 0 roads
					</programlisting>
				</para>

				<para>
					After we apply the above procedure to merge the roads, we are ready to create a new set of roads from which we can construct the graph.
					<programlisting>
CREATE TABLE Roads AS
SELECT osm_id || path AS osm_id,
	admin_level, bridge, cutting, highway, junction, name, oneway,
	operator, ref, route, surface, toll, tracktype, tunnel, width, geom
FROM MergedRoads;

CREATE INDEX Roads_geom_idx ON Roads USING GiST(geom);
					</programlisting>
					Notice that now the attribute <varname>osm_id</varname> is an array of OSM identifiers (which are big integers), whereas in the previous section it was a single big integer.
				</para>
				<para>
					We then proceed as we did in <xref linkend="create_graph" /> to compute the set of nodes and the set of edges, which we will store now for comparison purposes into tables <varname>Nodes1</varname> and <varname>Edges1</varname>. We can issue the following queries to compare the two graphs we have obtained and the one obtained by osm2pgrouting .
					<programlisting>
SELECT count(*) FROM Ways;
-- 83017
SELECT count(*) FROM Edges;
-- 81073
SELECT count(*) FROM Edges1;
-- 77986
SELECT count(*) FROM Ways_vertices_pgr;
-- 66832
SELECT count(*) FROM Nodes;
-- 45494
SELECT count(*) FROM Nodes1;
-- 42156
					</programlisting>
					<xref linkend="node_comp2" /> shows the nodes for the three graphs, those obtained after contracting the graph are shown in black, those before contraction are shown in blue, and those obtained by osm2pgrouting are shown in red. The figure shows in particular how several segments of the ring-road around Brussels are merged together since the have the same road type, direction, and maximum speed, The figure also shows in read a road that was removed since it does not belong to the strongly connected components of the graph.
				</para>

				<figure id="node_comp2" float="start"><title>Comparison of the nodes obtained by contracting the graph (in black), before contraction (in blue), and those obtained by osm2pgrouting (in red).</title>
					<mediaobject>
						<imageobject><imagedata scalefit="1" fileref='workshopimages/node_comp2.png' /></imageobject>
					</mediaobject>
				</figure>
			</sect2>
		</sect1>

	</chapter>	
</book>
